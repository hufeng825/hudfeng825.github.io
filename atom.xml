<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[阿峰的技术窝窝]]></title>
  <subtitle><![CDATA[专注于移动互联网]]></subtitle>
  <link href="http://hufeng825.github.com/atom.xml" rel="self"/>
  <link href="http://hufeng825.github.com"/>
  <updated>2013-09-11T16:42:33.616Z</updated>
  <id>http://hufeng825.github.com/</id>
  <author>
    <name><![CDATA[Jason Hu]]></name>
    <email><![CDATA[hufeng@hufengvip.cn]]></email>
  </author>
  <generator uri="http://zespia.tw/hexo">Hexo</generator>
  <entry>
    <title type="html"><![CDATA[ios开发--block应该知道的那几件事]]></title>
    <link href="http://hufeng825.github.com/2013/09/11/ios22/"/>
    <id>http://hufeng825.github.com/2013/09/11/ios22/</id>
    <published>2013-09-11T15:32:18.000Z</published>
    <updated>2013-09-11T16:40:52.000Z</updated>
    <content type="html"><![CDATA[<p>block 现在已经基本上已经使用非常普遍了,在引用中也又很多坑,下面把block开发中应该知道的那几件事总结下.<br><a id="more"></a></p>
<h2>:内联(inline)Block</h2>
<blockquote>
<p>内联block 说白了就是block被嵌入到一个函数中<br>例如:</p>
</blockquote>
<p><strong>typedef void (^HelloBlock)(void);</strong></p>
<figure class="highlight"><pre><span class="pp">- <span class="params">(void)</span> BlockTest{
HelloBlock myBlock= ^<span class="params">(void)</span>{
NSLog<span class="params">(@<span class="string">"Hello Block"</span>)</span>;
};
myBlock<span class="params">()</span>;
}
</pre></figure>

<h2>注意事项</h2>
<h3>1.内联的block中内部定义的变量 自己本身有读写权限</h3>
<h3>2.block内部要修改外部变量 需要将外部变量声明__block</h3>
<h3>3.Block retain是无效的，要想保留block生命周期，可以通过copy来实现，记得release</h3>
<h3>4.被block的应用的对象，retainCount会自动加一，为了打破这种 retain circle，可以在对象前加__block，这样block块就不会维护这个对象了</h3>
<p> 下面的写法如果不加上_block a无法dealloc</p>
<figure class="highlight"><pre>
__block A  a =[ <span class="string">[[A alloc] init] withBlock:^{

 [a action];

 [ a release];

}]; //这样A的dealloc方法就会调用
</pre></figure>

<figure class="highlight"><pre>
@<span class="class"><span class="keyword">interface</span> <span class="id">ViewController</span> ： <span class="id">UIViewViewController</span> </span>
 {
        <span class="built_in">NSString</span> *_string;
 }

 __block ViewController *controller = <span class="keyword">self</span>;   
    _block = ^{
         <span class="built_in">NSLog</span>(@<span class="string">"string %@"</span>,controller-&gt;_string);
    };
</pre></figure>

<h3>5.在独立的block中不能引用self，如果需要访问可以使用参数传递的方法(可以把其考虑成c+中参数传入函数指针对应copy)**</h3>
<h3>6.不要随便用.语法</h3>
<figure class="highlight"><pre><span class="preprocessor">#import &lt;UIKit/UIKit.h&gt;   </span>
@<span class="class"><span class="keyword">interface</span> <span class="title">AppDelegate</span> : <span class="title">NSObject</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;
@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">strong</span>) <span class="title">NSString</span> *<span class="title">stringProperty</span>;  
@<span class="title">end</span>
</pre></figure>

<figure class="highlight"><pre><span class="preprocessor">#import <span class="title">"GCDAppDelegate.h"</span> </span>
@<span class="class"><span class="keyword">implementation</span> <span class="id">AppDelegate</span> </span>
@<span class="keyword">synthesize</span> stringProperty;  
- (<span class="keyword">void</span>) BlockTestError{
HelloBlock myBlock= ^(<span class="keyword">void</span>){
	<span class="keyword">self</span><span class="variable">.stringProperty</span> = @<span class="string">"Block Objects"</span>; 
	<span class="built_in">NSLog</span>(@<span class="string">"String property = %@"</span>, <span class="keyword">self</span><span class="variable">.stringProperty</span>);<span class="comment">//运行错误</span>
};
myBlock();
}}  

- (<span class="keyword">void</span>) BlockTestCorrect{
	HelloBlock myBlock= ^(<span class="keyword">void</span>){
		[<span class="keyword">self</span> setStringProperty:@<span class="string">"Block Objects"</span>];
	    <span class="built_in">NSLog</span>(@<span class="string">"self.stringProperty = %@"</span>, [<span class="keyword">self</span> stringProperty]); <span class="comment">//运行ok</span>
	};
myBlock();
}}  
@<span class="keyword">end</span>
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[git 系类教程之 懂的这些配置能让git 更好用]]></title>
    <link href="http://hufeng825.github.com/2013/09/02/git4/"/>
    <id>http://hufeng825.github.com/2013/09/02/git4/</id>
    <published>2013-09-02T10:16:59.000Z</published>
    <updated>2013-09-10T15:17:08.000Z</updated>
    <content type="html"><![CDATA[<p>是不是抱怨git操作太过于复杂,是不是想要让log 更加漂亮 是不是想要让git 跟svn 一样支持st ci 等等这样的缩写命令……<br><a id="more"></a><br>下面的这些配置能够满足你.</p>
<p>打开终端 执行</p>
<figure class="highlight"><pre><span class="title">cd</span>
<span class="title">vi</span> .git/.gitconfig
</pre></figure>

<p>然后修改gitconfig</p>
<figure class="highlight"><pre><span class="title">[</span><span class="comment">alias</span>]
  <span class="comment">logs</span> <span class="comment">=</span> <span class="comment">log</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">color</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">graph</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">pretty=format:'%Cred%h%Creset</span> <span class="literal">-</span><span class="comment">%C(yellow)%d%Creset</span> <span class="comment">%s</span> <span class="comment">%Cgreen(%cr)</span> <span class="comment">%C(bold</span> <span class="comment">blue)</span>&lt;<span class="comment">%an</span>&gt;<span class="comment">%Creset'</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">abbrev</span>-<span class="comment">commit</span>
  <span class="comment">st</span> <span class="comment">=</span> <span class="comment">status</span>
  <span class="comment">ci</span> <span class="comment">=</span> <span class="comment">commit</span>
  <span class="comment">br</span> <span class="comment">=</span> <span class="comment">branch</span>
  <span class="comment">co</span> <span class="comment">=</span> <span class="comment">checkout</span>
  <span class="comment">df</span> <span class="comment">=</span> <span class="comment">diff</span>
  <span class="comment">lg</span> <span class="comment">=</span> <span class="comment">log</span> <span class="literal">-</span><span class="comment">p
</pre></figure>

<p>如果想要把 rebase 當做 git pull 的預設值，可以在專在 .gitconfig 加上</p>
<figure class="highlight"><pre>
[branch <span class="string">"master"</span>]
  remote = origin
  merge = refs<span class="regexp">/heads/m</span>aster
  rebase = <span class="literal">true</span>
</pre></figure>

<p>也可以直接加到 ~/.gitconfig 讓所有的 tracked branches 都自動���用這個設定：</p>
<figure class="highlight"><pre><span class="matrix">[branch]</span>  
	autosetuprebase = always
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/git/" term="git"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[git 系列教程之 提交信息的后悔药 修改提交信息]]></title>
    <link href="http://hufeng825.github.com/2013/09/02/git3/"/>
    <id>http://hufeng825.github.com/2013/09/02/git3/</id>
    <published>2013-09-02T10:06:42.000Z</published>
    <updated>2013-09-10T15:17:08.000Z</updated>
    <content type="html"><![CDATA[<p>有没有提交过“修改bug” “上传代码” 等等类似脑残的提交信息. code review 时看到这样的提交信息 每个team leader 肯定不会容忍的. 下面要介绍的是如何修改之前提交的历史信息<br><a id="more"></a></p>
<h2>方法一 可以修改最后一次 commit</h2>
<pre><code> <span class="comment">git</span> <span class="comment">commit</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">amend</span> </code></pre>
<hr>
<h2>方法二 交互式修改</h2>
<h3>步骤一</h3>
<pre><code>git rebase -i master~<span class="number">1</span> <span class="comment">//最</span>
git rebase -i master~<span class="number">5</span> <span class="comment">//最后五次</span></code></pre>
<h3>步骤二</h3>
<p> // 显示结果如下，修改 pick 为 edit ，并 :wq 保存退出<br>     pick 91b495b 2012-01-08: “提交信息内容”</p>
<pre><code><span class="preprocessor"># Rebase 9ef2b1f..91b495b onto 9ef2b1f</span>
<span class="preprocessor">#</span>
<span class="preprocessor"># Commands:</span>
<span class="preprocessor">#  pick = use commit</span>
<span class="preprocessor">#  edit = use commit, but stop for amending //改上面的 pick 为 edit</span>
<span class="preprocessor">#  squash = use commit, but meld into previous commit</span>
<span class="preprocessor">#</span>
<span class="preprocessor"># If you remove a line here THAT COMMIT WILL BE LOST.</span>
<span class="preprocessor"># However, if you remove everything, the rebase will be aborted.</span>
<span class="preprocessor">#</span></code></pre>
<h3>步骤三</h3>
<p> 使用</p>
<pre><code>git rebase --<span class="keyword">continue</span> <span class="comment">//完成操作</span></code></pre>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/git/" term="git"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[git 系类教程之 log显示]]></title>
    <link href="http://hufeng825.github.com/2013/09/02/git2/"/>
    <id>http://hufeng825.github.com/2013/09/02/git2/</id>
    <published>2013-09-02T09:59:59.000Z</published>
    <updated>2013-09-10T15:17:08.000Z</updated>
    <content type="html"><![CDATA[<p>查看log是程序员常用的操作之一,不要以为一个git log了事,下面介绍下git log 的高级操作.<br><a id="more"></a></p>
<ol>
<li><p>显示所有提交记录的包括提交时间 提交人员联系方式等等: git log</p>
</li>
<li><p>显示所有提交记录 只显示提交信息: git shortlog</p>
</li>
<li><p>显⽰示版本历史,以及版本间的内容差异:git log -p</p>
</li>
<li><p>只显⽰示最近⼀一次提交:git log -1</p>
</li>
<li><p>显⽰示最近的20个提交:以及版本间的内容差异:git log -20 -p</p>
</li>
<li><p>显⽰示最近6⼩小时的提交:git log —since=“6 hours”</p>
</li>
<li><p>显⽰示两天之前的提交:git log —before=“2 days”</p>
</li>
</ol>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/git/" term="git"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[在Finder标题栏上显示完整路径]]></title>
    <link href="http://hufeng825.github.com/2013/09/02/ios21/"/>
    <id>http://hufeng825.github.com/2013/09/02/ios21/</id>
    <published>2013-09-02T01:57:17.000Z</published>
    <updated>2013-09-02T02:02:01.000Z</updated>
    <content type="html"><![CDATA[<p>打开终端，输入以下命令并回车：</p>
<pre><code>defaults write com<span class="variable">.apple</span><span class="variable">.finder</span> _FXShowPosixPathInTitle -<span class="keyword">bool</span> <span class="literal">YES</span></code></pre>
<p>然后再把finder关了再打开，你会发现路径栏变成这个样子了：</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
    <category scheme="http://hufeng825.github.com/categories/ios/mac/" term="mac"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Block 定时器 让我们解放了]]></title>
    <link href="http://hufeng825.github.com/2013/09/02/ios20/"/>
    <id>http://hufeng825.github.com/2013/09/02/ios20/</id>
    <published>2013-09-02T01:28:52.000Z</published>
    <updated>2013-09-10T15:17:08.000Z</updated>
    <content type="html"><![CDATA[<p>Block 没有出现前 ios写个定时器太麻烦了,好在Block的让我们小爽了一把,以后写timer 简单的要命了<br><a id="more"></a><br>    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 0.5 * NSEC_PER_SEC), dispatch_get_current_queue(), ^{</p>
<pre><code>     [bgColorView removeFromSuperview]<span class="comment">;</span>

})<span class="comment">;</span></code></pre>
<p>或者</p>
<pre><code>double delayInSeconds = <span class="number">2.0</span>;
dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);
dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>){
    <span class="xml"><span class="tag">&lt;<span class="title">#code</span> <span class="attribute">to</span> <span class="attribute">be</span> <span class="attribute">executed</span> <span class="attribute">on</span> <span class="attribute">the</span> <span class="attribute">main</span> <span class="attribute">queue</span> <span class="attribute">after</span> <span class="attribute">delay</span>#&gt;</span>
});</span></code></pre>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[如何得到中英文混合下的NSString的长度?]]></title>
    <link href="http://hufeng825.github.com/2013/09/02/ios19/"/>
    <id>http://hufeng825.github.com/2013/09/02/ios19/</id>
    <published>2013-09-02T01:21:21.000Z</published>
    <updated>2013-09-02T01:27:19.000Z</updated>
    <content type="html"><![CDATA[<p>这个貌似很简单但却是把我跟招行的兄弟难为了好久,为毛?还不是因为招行信用卡中心的网络无法连接外网无法谷歌度娘最后我们只能查看文档写test<br>下面是最后我们得到的两个方法<br><a id="more"></a></p>
<h2>方法一:</h2>
<pre><code>- (<span class="keyword">int</span>)getStringLength:(NSString<span class="variable">*)</span>strtemp
{

NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_200<span class="number">0</span>);

    NSData* da = [strtemp dataUsingEncoding:enc];

    <span class="keyword">return</span> [da <span class="keyword">length</span>];

}</code></pre>
<h2>方法二:</h2>
<pre><code>- (<span class="keyword">int</span>)convertToInt:(NSString<span class="variable">*)</span>strtemp

{

    <span class="keyword">int</span> strlength = <span class="number">0</span>;

    char* p = (char<span class="variable">*)</span>[strtemp cStringUsingEncoding:NSUnicodeStringEncoding];

    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;[strtemp lengthOfBytesUsingEncoding:NSUnicodeStringEncoding] ;i++) {

        <span class="keyword">if</span> (<span class="variable">*p</span>) {

            p++;

            strlength++;

        }

        <span class="keyword">else</span> {

            p++;

        }



    }

    <span class="keyword">return</span> strlength;

}</code></pre>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[父View禁用touch 如何让子view还能获取touch event]]></title>
    <link href="http://hufeng825.github.com/2013/09/02/ios18/"/>
    <id>http://hufeng825.github.com/2013/09/02/ios18/</id>
    <published>2013-09-02T01:14:30.000Z</published>
    <updated>2013-09-02T01:18:18.000Z</updated>
    <content type="html"><![CDATA[<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1e87vwh4ocsj20a70dcjrp.jpg" class="left" width="300" height="400">

<p><a id="more"></a><br>如上图 当view2 包含在view1中,默认清空下 view1 的touch事件被禁用掉侯view2 肯定是接收不到touch事件的,那有没有什么办法能够让view2接收到touch事件呢?<br>其实很简单hitTest 可以帮我们实现这个需求</p>
<figure class="highlight"><pre>uiview addition
-(<span class="keyword">id</span>)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(UIEvent *)event {
    <span class="keyword">id</span> hitView = [<span class="keyword">super</span> hitTest:point withEvent:event];
    <span class="keyword">if</span> (hitView == <span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">nil</span>;
    <span class="keyword">else</span> <span class="keyword">return</span> hitView;
}
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[(NSDate) 时间 (time )比较]]></title>
    <link href="http://hufeng825.github.com/2013/09/02/ios17/"/>
    <id>http://hufeng825.github.com/2013/09/02/ios17/</id>
    <published>2013-09-02T00:31:25.000Z</published>
    <updated>2013-09-02T00:57:41.000Z</updated>
    <content type="html"><![CDATA[<p>做订餐app时对下单时间的时间判断<br>下面是规则</p>
<ul>
<li>9:00-14:00 可以订餐</li>
<li>14:00以后掌上餐厅仅接收晚餐订餐</li>
<li>21:00以后掌上餐厅不接收订餐</li>
</ul>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1e87ve4c3ynj208q0abt9n.jpg" class="left" title="截图 300 400">


<h2><a id="more"></a></h2>
<h2>转换函数</h2>
<p> 将传入的小时和分钟 转换成当日的date</p>
<p> 例如传入 8：00 的str 返回 2013-01-01 08：00 的nsdate</p>
<figure class="highlight"><pre>-(NSDate <span class="variable">*)</span>CurrentDayTime:(NSString <span class="variable">*)</span>dataStr

{

    <span class="regexp">//</span>设置转换的<span class="keyword">format</span>

    NSDateFormatter <span class="variable">*dateFormatter</span> = [[[NSDateFormatteralloc]init]autorelease];

    [dateFormatter setLocale:[NSLocalecurrentLocale]];

    

    [dateFormatter setDateFormat:<span class="variable">@"</span>yyyy-MM-dd HH:mm<span class="string">"];

    //获取当前年月日 

    NSDate <span class="variable">*currentdate</span> = [NSDatedate];

    NSCalendar <span class="variable">*calendar</span> = [NSCalendarcurrentCalendar];

    NSDateComponents <span class="variable">*components</span> = [calendarcomponents:(

                                                         NSYearCalendarUnit  |

                                                         NSMonthCalendarUnit |

                                                         NSDayCalendarUnit |

                                                         NSHourCalendarUnit |

                                                         NSMinuteCalendarUnit

                                                         ) fromDate:currentdate];

   NSInteger year = [components year];

   NSInteger month = [components month];

   NSInteger day = [components day];

   NSString <span class="variable">*strDate</span> = [NSString stringWithFormat:<span class="variable">@"</span><span class="variable">%d</span>-<span class="variable">%d</span>-<span class="variable">%d</span> <span class="variable">%@</span>"</span>,year,month,day,dataStr];

   NSDate <span class="variable">*date</span> = [dateFormatter dateFromString:strDate];

   <span class="keyword">return</span> date;

}
</pre></figure>

<hr>
<h2>比较算法</h2>
<figure class="highlight"><pre>NSLog(<span class="variable">@"</span><span class="variable">%@</span>\n<span class="variable">%@</span><span class="string">",[selfCurrentDayTime:<span class="variable">@"</span>18:00"</span>] ,[NSDatedate]);

    NSDate <span class="variable">*date</span> = [NSDatedate];

    <span class="keyword">if</span> ([datecompare:[selfCurrentDayTime:<span class="variable">@"</span><span class="number">18</span>:<span class="number">00</span><span class="string">"]] ==NSOrderedDescending)

    {

        NSLog(<span class="variable">@"</span>date1 is later than date2"</span>);

        

    } <span class="keyword">else</span> <span class="keyword">if</span> ([datecompare:[selfCurrentDayTime:<span class="variable">@"</span><span class="number">18</span>:<span class="number">00</span><span class="string">"]] ==NSOrderedAscending)

    {

        NSLog(<span class="variable">@"</span>date1 is earlier than date2"</span>);

        

    } <span class="keyword">else</span>

    {

        NSLog(<span class="variable">@"</span>dates are the same<span class="string">");

        

    }
</pre></figure>

<h2>用法如下</h2>
<figure class="highlight"><pre>-(BOOL)checkCanDinner

{

    NSDate *currentDate = [NSDatedate];

    <span class="keyword">if</span> ([currentDate compare:[selfCurrentDayTime:<span class="string">@"08:59"</span>]] == NSOrderedDescending <span class="comment">//late</span>

        && [currentDate compare:[selfCurrentDayTime:<span class="string">@"13:59"</span>]] == NSOrderedAscending <span class="comment">//early</span>

        )

    {

        <span class="comment">//9:00-14:00 可以订餐</span>

        <span class="keyword">return</span> YES;

    }

    <span class="keyword">else</span> <span class="keyword">if</span>([currentDatecompare:[self CurrentDayTime:<span class="string">@"09:00"</span>]] ==NSOrderedAscending <span class="comment">//early</span>

            && [currentDate compare:[selfCurrentDayTime:<span class="string">@"00:00"</span>]] ==  NSOrderedDescending<span class="comment">//late</span>

            )

    {

        HFAlert(<span class="string">@"因较多餐厅休息,9:00之前掌上餐厅不接收订餐，为您带来的不便请谅解。"</span>);

        <span class="keyword">return</span> NO;

    }

    <span class="keyword">else</span> <span class="keyword">if</span>([currentDatecompare:[self CurrentDayTime:<span class="string">@"17:59"</span>]] ==NSOrderedAscending <span class="comment">//early</span>

            && [currentDate compare:[selfCurrentDayTime:<span class="string">@"14:00"</span>]] ==  NSOrderedDescending<span class="comment">//late</span>

            )

    {

        HFAlert(<span class="string">@"因较多餐厅休息,14:00以后掌上餐厅仅接收晚餐订餐,为您带来的不便请谅解。"</span>);

        <span class="keyword">return</span> YES;

    }

    <span class="keyword">else</span> <span class="keyword">if</span>([currentDatecompare:[self CurrentDayTime:<span class="string">@"21:00"</span>]] ==NSOrderedAscending <span class="comment">//early</span>

            && [currentDate compare:[selfCurrentDayTime:<span class="string">@"18:00"</span>]] ==  NSOrderedDescending<span class="comment">//late</span>

            )

    {

        <span class="comment">//接受晚上的订单</span>

        <span class="keyword">return</span> YES;

    }

    <span class="keyword">else</span> <span class="keyword">if</span>([currentDatecompare:[self CurrentDayTime:<span class="string">@"23:59"</span>]] ==NSOrderedAscending <span class="comment">//early</span>

            && [currentDate compare:[selfCurrentDayTime:<span class="string">@"21:00"</span>]] ==  NSOrderedDescending<span class="comment">//late</span>

            )

    {

        HFAlert(<span class="string">@"因较多餐厅休息,21:00以后掌上餐厅不接收订餐,为您带来的不便请谅解。"</span>);

        <span class="keyword">return</span> NO;

    }

    <span class="keyword">return</span> YES;

}
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[善用 NSAutoreleasePool 节约宝贵内存]]></title>
    <link href="http://hufeng825.github.com/2013/09/02/ios16/"/>
    <id>http://hufeng825.github.com/2013/09/02/ios16/</id>
    <published>2013-09-02T00:26:20.000Z</published>
    <updated>2013-09-02T00:28:11.000Z</updated>
    <content type="html"><![CDATA[<p>autorelease自动释放内存，并不会立即把内存释放掉，而是要等到下一个事件周期才会释放掉。问题是一些资源我们不得不使用autorelease类型，比如作为函数的返回值，而且系统api及项目是的大部分也都是这么做的，如果全都依靠我们手动释放很容易造成内存泄漏。<br><a id="more"></a></p>
<pre><code>     <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;= <span class="number">10000</span>; i ++) {

        //创建一个自动释放池

         NSAutoreleasePool *pool = [NSAutoreleasePool new];

         NSString *filePath = <span class="string">[[NSBundle mainBundle] pathForResource:@"hf" ofType:@"PNG"];

         UIImage *image = [[UIImage alloc] initWithContentsOfFile:filePath];

         UIImage *scalimage = [image imageByScalingAndCroppingForSize:CGSizeMake(320, 640)];

         [image release];

        //将自动释放池内存释放，它会同时释放掉上面代码中产生的临时变量image2

         [pool drain];

     }</code></pre>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[如何禁用禁用uwebiview 的反弹功能(bounces)]]></title>
    <link href="http://hufeng825.github.com/2013/09/02/ios15/"/>
    <id>http://hufeng825.github.com/2013/09/02/ios15/</id>
    <published>2013-09-02T00:23:19.000Z</published>
    <updated>2013-09-02T00:25:47.000Z</updated>
    <content type="html"><![CDATA[<p>UIWebView默认允许当网页内容处于最顶端时，用户可以用手指往下拖动，露出空白的背景<br>如何禁用呢<br>// iOS 5之前</p>
<pre><code><span class="keyword">for</span> (id subview <span class="keyword">in</span> webView.subviews)
  <span class="keyword">if</span> (<span class="string">[[subview class] isSubclassOfClass: [UIScrollView class]]</span>)
    ((UIScrollView *)subview).bounces = NO;</code></pre>
<p>// iOS 5+</p>
<pre><code>webView<span class="variable">.scrollView</span><span class="variable">.bounces</span> = <span class="literal">NO</span>;</code></pre>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[如何清空 NSUserDefaults 下所有数据]]></title>
    <link href="http://hufeng825.github.com/2013/09/02/ios14/"/>
    <id>http://hufeng825.github.com/2013/09/02/ios14/</id>
    <published>2013-09-02T00:18:20.000Z</published>
    <updated>2013-09-02T00:22:03.000Z</updated>
    <content type="html"><![CDATA[<p>每个app 难免要在NSUserDefaults中记一些数据,但这些数据某些清空下药全部清空,比如系统版本升级啦,后台存储数据结构变更啦<br><a id="more"></a><br>下面给出的代码端就是清空NSUserDefaults的一个实现</p>
<figure class="highlight"><pre>  <span class="keyword">if</span> (!<span class="string">[[NSUserDefaults standardUserDefaults] boolForKey:@"dontClearHXCache"])

    {

        NSString *appDomainStr = [[NSBundle mainBundle] bundleIdentifier];

        [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomainStr];

        [[NSUserDefaults standardUserDefaults] setBool:YES forKey:@"dontClearHXCache"];

       [[NSUserDefaults standardUserDefaults]synchronize];

    }

    else

    {

        [[NSUserDefaults standardUserDefaults] setBool:YES forKey:@"dontClearHXCache"];

        [[NSUserDefaults standardUserDefaults]synchronize];



    }
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[mac 下 git svn 的代理设置]]></title>
    <link href="http://hufeng825.github.com/2013/09/02/mac1/"/>
    <id>http://hufeng825.github.com/2013/09/02/mac1/</id>
    <published>2013-09-02T00:10:34.000Z</published>
    <updated>2013-09-10T15:17:08.000Z</updated>
    <content type="html"><![CDATA[<p>所干的工作 因为涉及到金融行业网络安全性比较高 公司的网络设置了代理 这导致了git svn 双双挂了。<br><a id="more"></a><br>废话少说 下面介绍如何对git svn 设置代理</p>
<ol>
<li><p>$HOME 下 我的路径为/Users/jason:</p>
</li>
<li><p>进入$HOME/.subversion </p>
<p>编辑servers 文件 添加</p>
<pre><code><span class="matrix">[global]</span>
 http-proxy-host = <span class="transposed_variable">XX.</span><span class="transposed_variable">XX.</span><span class="transposed_variable">XX.</span>XX
 http-proxy-port = XXXX
<span class="matrix">[groups]</span></code></pre>
</li>
<li><p>编辑$HOME/.gitconfig</p>
<pre><code>[http]        

     proxy = http://XX<span class="preprocessor">.XX</span><span class="preprocessor">.XX</span><span class="preprocessor">.XX</span>:XXXX

[https]
      proxy = http://XX<span class="preprocessor">.XX</span><span class="preprocessor">.XX</span><span class="preprocessor">.XX</span>:XXXX</code></pre>
</li>
<li><p>或者直接用命令</p>
<pre><code> git config --global http<span class="preprocessor">.proxy</span> http://XX<span class="preprocessor">.XX</span><span class="preprocessor">.XX</span><span class="preprocessor">.XX</span>:XXXX
 git config --global https<span class="preprocessor">.proxy</span> http://XX<span class="preprocessor">.XX</span><span class="preprocessor">.XX</span><span class="preprocessor">.XX</span>:XXXX</code></pre>
</li>
</ol>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/git/" term="git"/>
    <category scheme="http://hufeng825.github.com/categories/git/svn/" term="svn"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[复杂页面消退的一个简单实例]]></title>
    <link href="http://hufeng825.github.com/2013/08/31/ios13/"/>
    <id>http://hufeng825.github.com/2013/08/31/ios13/</id>
    <published>2013-08-31T14:42:52.000Z</published>
    <updated>2013-09-10T15:17:08.000Z</updated>
    <content type="html"><![CDATA[<p>如图</p>
<img src="http://ww3.sinaimg.cn/mw690/a43af4ffjw1e8680v5hirj20df09qglv.jpg" class="left" height="400" title="600">


<p><a id="more"></a><br>实现上面的这个又两种实现方式 </p>
<ul>
<li><p>一种是给页面1 发广播通知 </p>
</li>
<li><p>另外一种就是我要介绍的</p>
</li>
</ul>
<figure class="highlight"><pre> [(<span class="built_in">UINavigationController</span>*)<span class="keyword">self</span><span class="variable">.parentViewController</span><span class="variable">.presentingViewController</span>

     popToRootViewControllerAnimated:<span class="literal">YES</span>];

    [<span class="keyword">self</span> dismissModalViewControllerAnimated:<span class="literal">YES</span>];
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ios 开发之 序列化]]></title>
    <link href="http://hufeng825.github.com/2013/08/31/ios12/"/>
    <id>http://hufeng825.github.com/2013/08/31/ios12/</id>
    <published>2013-08-31T14:26:47.000Z</published>
    <updated>2013-09-02T00:08:23.000Z</updated>
    <content type="html"><![CDATA[<p>序列化</p>
<p>参考原始文档：</p>
<p><a href="https://github.com/mystcolor/JTObjectMapping" target="_blank">https://github.com/mystcolor/JTObjectMapping</a></p>
<p><a id="more"></a><br>使用方法</p>
<p>========</p>
<p>绝大多数情况下，需要用到的就是一个方法：</p>
<p>[NSObject objectFromJSONObject:stateObject mapping:nil];</p>
<p>其中，把NSObject换成我们想映射成的类的名字。</p>
<p>稍微复杂一点，假设类的属性和JSON里的key名字不是一一对应的，那么就要写一个映射关系表作为mapping参数：</p>
<pre><code>NSDictionary <span class="variable">*mapping</span> = [NSDictionary dictionaryWithObjectsAndKeys:

                         <span class="variable">@"</span>myState<span class="string">", <span class="variable">@"</span>state"</span>,

                         <span class="variable">@"</span>movieList<span class="string">", <span class="variable">@"</span>movie"</span>,

                         nil];

[NSObject objectFromJSONObject:stateObject mapping:mapping];</code></pre>
<p>如果再复杂一点，我们需要映射一个数组，数组的每个元素映射到一个对象，那么就用到第2个方法：</p>
<p>[NSObject mappingWithKey:@“responseState” mapping:nil]</p>
<p>同样，把NSObject换成数组元素对应的类，key是用来存放整个数组的那个属性。</p>
<p>注意</p>
<p>====</p>
<p>JSON里的字符串，是能自动映射成NSNumber或者int型的，不需要特别写代码。如果想把一个字符串日期，映射成NSDate型，请参考原始文档。</p>
<p>具体举个例子</p>
<p>===========</p>
<p>假设我们有这样一段JSON：</p>
<p> {</p>
<p> “state”:[</p>
<p> {</p>
<p> “respCode”:“0000”,</p>
<p> “respMsg”:“1”</p>
<p> }</p>
<p> ],</p>
<p> “movie”:[</p>
<p> {</p>
<p> “body”:“    一开始，这只是叶问的故事他生于佛山”,</p>
<p> “pics”:“/images/jz/4779-1-20121225133147.jpg,/images/jz/4779-2-20121225133147.jpg”,</p>
<p> “name”:“一代宗师”,</p>
<p> “movid”:“4779”,</p>
<p> “length”:“120”,</p>
<p> “hasplan”:“1”,</p>
<p> “trailor”:“/4779.m4v”,</p>
<p> “director”:“梁朝伟 章子怡 张震 ”,</p>
<p> “type”:“动作/传记/剧情/IMAX”,</p>
<p> “url”:&quot;<a href="http://img.fun-guide.mobi/show?src=http://zhaohang.fun-guide.mobi:8080/tm/images/hb/4779-20121225133147.jpg&amp;w=140" target="_blank">http://img.fun-guide.mobi/show?src=http://zhaohang.fun-guide.mobi:8080/tm/images/hb/4779-20121225133147.jpg&amp;w=140</a>&quot;,</p>
<p> “popularity”:“6”</p>
<p> },</p>
<p> {</p>
<p> …</p>
<p> }</p>
<p> ]</p>
<p> }</p>
<p>现在，想把它映射到自定义的对象中去。有几种情况：</p>
<p>第一种情况，简单地把state数组里面的第一个元素映射成一个FGStateModel类</p>
<p>那么就是，取出这个节点：</p>
<pre><code>NSDictionary *stateObject = <span class="string">[[self.json objectForKey:@"state"] objectAtIndex:0];</code></pre>
<p>然后，执行映射：</p>
<pre><code><span class="keyword">self</span>.state = [<span class="class">FGStateModel</span> <span class="method">objectFromJSONObject:</span>stateObject <span class="method">mapping:</span><span class="keyword">nil</span>];</code></pre>
<p>第二种情况，把movie这个字典数组映射成一个数组，数组的每个元素是FGMovieModel</p>
<pre><code><span class="class">NSArray</span> *movieObject = [<span class="keyword">self</span>.json <span class="method">objectForKey:</span>@<span class="comment">"movie"</span>];

<span class="keyword">self</span>.movieList = [<span class="class">FGMovieModel</span> <span class="method">objectFromJSONObject:</span>movieObject <span class="method">mapping:</span><span class="keyword">nil</span>];</code></pre>
<p>第三种情况，如果对象的属性和JSON名字不一样，可以使用映射表，例如我们想把上面整个json对象映射成一个 FGResponseModel 对象，其中，state数组映射成 responseState 属性，movie 数组映射成 movieList 属性。那么，我们需要告诉映射器这个数组里的元素要映射成什么对象。</p>
<p>所以，通过 mapping 这个参数告诉它：“请把 JSON 里的 state 数组里的每个元素映射成一个 FGStateModel 对象，并且把最终的数组放到responseState这个属性里。另外，把 movie 这个数组映射成一个 FGMovieModel 数组，并且保存到 movieList 这个属性中。“</p>
<pre><code><span class="class">NSDictionary</span> *mapping = [<span class="class">NSDictionary</span> <span class="method">dictionaryWithObjectsAndKeys:</span>

                         [<span class="class">FGStateModel</span> <span class="method">mappingWithKey:</span>@<span class="comment">"responseState"</span> <span class="method">mapping:</span><span class="keyword">nil</span>], @<span class="comment">"state"</span>,

                         [<span class="class">FGMovieModel</span> <span class="method">mappingWithKey:</span>@<span class="comment">"movieList"</span> <span class="method">mapping:</span><span class="keyword">nil</span>], @<span class="comment">"movie"</span>,

                         <span class="keyword">nil</span>];

<span class="keyword">self</span>.response = [<span class="class">FGResponseModel</span> <span class="method">objectFromJSONObject:</span><span class="keyword">self</span>.json <span class="method">mapping:</span>mapping];</code></pre>
<figure class="highlight"><pre><span class="preprocessor">#import &lt;Foundation/Foundation.h&gt;</span>


@<span class="class"><span class="keyword">interface</span> <span class="title">FGMovieModel</span> : <span class="title">NSObject</span>


@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">retain</span>) <span class="title">NSString</span> *<span class="title">body</span>;

@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">retain</span>) <span class="title">NSString</span> *<span class="title">pics</span>;

@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">retain</span>) <span class="title">NSString</span> *<span class="title">name</span>;

@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">assign</span>) <span class="title">NSInteger</span> <span class="title">movid</span>;

@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">retain</span>) <span class="title">NSNumber</span> *<span class="title">length</span>;


@<span class="title">end</span>
</pre></figure>

<figure class="highlight"><pre><span class="preprocessor">#import &lt;Foundation/Foundation.h&gt;</span>


@<span class="class"><span class="keyword">interface</span> <span class="title">FGResponseModel</span> : <span class="title">NSObject</span>

@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">retain</span>) <span class="title">NSArray</span> *<span class="title">responseState</span>;

@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">retain</span>) <span class="title">NSArray</span> *<span class="title">movieList</span>;

@<span class="title">end</span>

 
#<span class="title">import</span> &lt;<span class="title">Foundation</span>/<span class="title">Foundation</span>.<span class="title">h</span>&gt;


@<span class="title">interface</span> <span class="title">FGStateModel</span> : <span class="title">NSObject</span>


@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">retain</span>) <span class="title">NSString</span> *<span class="title">respCode</span>;

@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">retain</span>) <span class="title">NSString</span> *<span class="title">respMsg</span>;


@<span class="title">end</span>
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/hexo/" term="hexo"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[银行支付控件之 自动随机(shuffle)密码键盘的实现算法]]></title>
    <link href="http://hufeng825.github.com/2013/08/31/ios11/"/>
    <id>http://hufeng825.github.com/2013/08/31/ios11/</id>
    <published>2013-08-31T14:05:28.000Z</published>
    <updated>2013-08-31T14:22:21.000Z</updated>
    <content type="html"><![CDATA[<p>为了广大用户的支付安全,输入密码的页面密码键盘要用随机排序,因为有版权问题无法把自己写的代码全部贴出 所以下面只把关键的洗牌算法贴出来</p>
<h2>算法一</h2>
<figure class="highlight"><pre>NSMutableArray *randSequence = <span class="string">[[NSMutableArray alloc] initWithCapacity:8];
for (int ii = 0; ii &lt; 10; ++ii)
    [randSequence addObject:[NSNumber numberWithInt:ii]]</span>;

<span class="keyword">for</span> (int ii = <span class="number">9</span>; ii &gt; -<span class="number">1</span>; <span class="comment">--ii) {</span>
    int r = arc4random() % <span class="number">9</span>
    [randSequence exchangeObjectAtIndex:ii withObjectAtIndex:r];
</pre></figure>

<h2>算法二</h2>
<figure class="highlight"><pre>
@<span class="class"><span class="keyword">interface</span> <span class="title">NSMutableArray</span> (<span class="title">Shuffling</span>)
- (<span class="title">void</span>)<span class="title">shuffle</span>;
@<span class="title">end</span>


//  <span class="title">NSMutableArray_Shuffling</span>.<span class="title">m</span>

#<span class="title">import</span> "<span class="title">NSMutableArray_Shuffling</span>.<span class="title">h</span>"

@<span class="title">implementation</span> <span class="title">NSMutableArray</span> (<span class="title">Shuffling</span>)

- (<span class="title">void</span>)<span class="title">shuffle</span>
{</span>
    NSUInteger <span class="keyword">count</span> = [self <span class="keyword">count</span>];
    <span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; <span class="keyword">count</span>; ++i) {
        <span class="comment">// Select a random element between i and end of array to swap with.</span>
        NSInteger nElements = <span class="keyword">count</span> - i;
        NSInteger n = (arc4random() % nElements) + i;
        [self exchangeObjectAtIndex:i withObjectAtIndex:n];
    }
}

@end
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[mac 下的默认配置]]></title>
    <link href="http://hufeng825.github.com/2013/08/31/ios10/"/>
    <id>http://hufeng825.github.com/2013/08/31/ios10/</id>
    <published>2013-08-31T13:45:59.000Z</published>
    <updated>2013-09-02T02:02:39.000Z</updated>
    <content type="html"><![CDATA[<p>请几天安装其他的shell 结果把默认的shell更改了  有没有快捷的方法更换会默认配置 <a id="more"></a>其实mac 下 有一个很简单命令可以搞定这些用户默认设置<br>打开终端社着敲敲如下的命令</p>
<pre><code><span class="attribute">chsh</code></pre>
<img src="http://ww3.sinaimg.cn/mw690/a43af4ffjw1e866tu4f66j20a107sq3i.jpg" class="left" title="运行效果 300  400">
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
    <category scheme="http://hufeng825.github.com/categories/ios/mac/" term="mac"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Xcode的持续集成指南]]></title>
    <link href="http://hufeng825.github.com/2013/08/31/ios9/"/>
    <id>http://hufeng825.github.com/2013/08/31/ios9/</id>
    <published>2013-08-31T13:11:39.000Z</published>
    <updated>2013-08-31T13:44:09.000Z</updated>
    <content type="html"><![CDATA[<h2>采用持续集成工作流</h2>
<p>设置MAC作为服务器，在其上运行Xcode的服务。然后确保你的本地项目，发布源代码库。要完成设立一个持续集成的工作流程，配置的机器人，不知疲倦地进行集成和时间表。<br><a id="more"></a></p>
<h2>OS X Server的安装和配置的Xcode服务</h2>
<p>要运行的Xcode的服务，您必须先安装运行的是Mac OS X v10.9开发者预览版OS X Server的预览。您还必须在服务器上安装Xcode开发者预览。自动构建，分析，测试，和归档您的产品，您将使用Xcode的服务。</p>
<h3>要安装和运行Xcode的服务</h3>
<ol>
<li><p>转到<a href="http://developer.apple.com/downloads的，并获得OS" target="_blank">http://developer.apple.com/downloads的，并获得OS</a> X v10.9开发者预览版，OS X Server的预览，和Xcode开发者预览版的预发布版本。</p>
</li>
<li><p>安装OS X v10.9开发者预览版，Mac OS X Server的预览，和Xcode开发者预览版的Mac上，你会运行Xcode的服务。</p>
</li>
<li><p>启动服务器应用程序/应用。</p>
</li>
<li><p>在服务器应用程序边栏中，选择的Xcode的服务。</p>
</li>
<li><p>当您第一次打开Xcode的服务在一个特定的服务器上，该服务会询问您确定的Xcode版本，它应该用来执行其任务。</p>
</li>
<li><p>点击选择的Xcode，并选择使用的Xcode版本。</p>
</li>
<li><p>点击On / Off开关打开服务</p>
</li>
</ol>
<p>接下来，添加你的服务器允许访问Xcode的服务团队，如资产配置的配置文件和签名证书为iOS设备构建产品开发团队。你必须是一个管理员或开发团队的代理，这样才能把服务器加进来。</p>
<h3>要添加您的服务器开发团队</h3>
<ol>
<li><p>在服务器应用程序边栏中，选择的Xcode的服务。</p>
</li>
<li><p>在“设置”窗格中，单击“添加”按钮，旁边的开发团队标签。</p>
</li>
<li><p>输入您的Apple开发者证书，并选择一个团队。</p>
</li>
</ol>
<p>加入团队后，Xcode的���务，您可以添加iOS开发设备运行单元测试时使用。</p>
<h3>要添加一个iOS开发设备的Xcode服务</h3>
<ol>
<li><p>在服务器应用程序边栏中，选择的Xcode的服务。</p>
</li>
<li><p>将设备连接到服务器，并等待，直到它出现在设备列表中。</p>
</li>
<li><p>点击“加入队伍”按钮旁边的列表中的设备。</p>
</li>
</ol>
<p>添加帐户资料库和您的服务器配置开发的Mac。你会写你的Mac上的使用Xcode代码，你就会让OS X服务器进行持续集成。您还必须发布或您当地的项目转移到资料库，可通过Xcode的服务。</p>
<h3>你开发的Mac OS X Server的帐户添加到Xcode</h3>
<ol>
<li><p>在Xcode的开发Mac上，单击“帐户”首选项“窗口。</p>
</li>
<li><p>点击添加按钮（+），并选择“添加服务器”。</p>
</li>
<li><p>从服务器列表中选择服务器，输入服务器地址，然后单击“下一步”按钮。</p>
</li>
<li><p>指定您的连接到服务器的凭据，然后单击“添加”。</p>
</li>
</ol>
<p>您可以添加到您的帐户资料库，加快结帐操作。（你也可以添加库到您的清单后，当您检查的项目）。</p>
<h3>要添加存储库到您的帐户</h3>
<ol>
<li><p>在Xcode的开发Mac上，单击“帐户”首选项“窗口。</p>
</li>
<li><p>点击添加按钮（+），并选择“添加库。</p>
</li>
<li><p>在文本字段中，输入库添加的地址，然后单击“完成”按钮。</p>
</li>
</ol>
<h2>Xcode的服务和团队成员共享项目</h2>
<p>对于Xcode的服务，您的项目进行集成，它必须包含这些项目的存储库的访问。启用访问托管Git仓库在服务器上运行的Xcode服务或Git或Subversion版本库，包含你的项目添加连接信息。</p>
<p>如果同一个团队开发，持续集成涉及到整个团队。谁的作品在产品上的人都必须能够访问所有产品的资源，使任何人都可以引起谁都可能解决问题。如果你有一个不保持源代码库中的项目或工作区，你必须检查你的文件到存储库，让其他团队成员可以在这些产品上。</p>
<p><strong>您可以在服务器上创建一个Xcode服务器，托管Git仓库</strong><br>开发团队可以共享更改产品OS X服务器托管在一个Git仓库。创建一个Xcode服务器托管Git仓库之前，你必须：</p>
<ol>
<li><p>确保都有谁应该能够访问存储库服务器上的用户帐户。</p>
</li>
<li><p>打开系统偏好设置中的服务器上的远程登录服务。</p>
</li>
</ol>
<h3>要创建一个Xcode服务器托管您的服务器上的Git仓库</h3>
<ol>
<li><p>在服务器应用程序边栏中，选择Xcode的服务，然后单击“存储库”按钮。</p>
</li>
<li><p>点击添加按钮（+），并指定存储库的信息：</p>
<ul>
<li>选择“主机一个Git仓库。”</li>
<li>名称：输入资料库的名称（例如，项目名称）。</li>
<li>访问：确定允许用户访问存储库。</li>
</ul>
</li>
<li><p>单击“创建”。</p>
<p> 新的资料库资料库列表中出现。如果你有一个发展的Mac上现有的Git管理的项目，你可以把你的变化，这个新的储存库，将其配置为远程，如未来。</p>
</li>
</ol>
<h3>从发展的Mac，您可以共享现有的Git管理项目</h3>
<p>当您共享一个项目，其中包含一个Git仓库，是当地发展的Mac，Xcode的服务可以检查出来进行集成。共享一个项目之前，你必须：</p>
<ol>
<li>作为OS X服务器运行Xcode的服务的管理员进行身份验证。</li>
<li>确保服务器和Xcode的服务的，允许远程登录访问，通过安全Shell（SSH），它承载的存储库。在OS X服务器，你可以配置远程登录，在“系统偏好设定”中的“共享”窗格中。</li>
</ol>
<h4>要共享项目</h4>
<ol>
<li><p>打开项目发展的Mac上，并选择源控制&gt; PROJECT_NAME &gt;配置PROJECT_NAME。</p>
</li>
<li><p>按一下远程控制。</p>
</li>
<li><p>点击“添加”按钮（+）。</p>
</li>
<li><p>选择“创建新的远程。</p>
</li>
<li><p>选择一台服务器。</p>
</li>
<li><p>输入远程名称。</p>
</li>
<li><p>单击“创建”。</p>
</li>
<li><p>单击“完成”。</p>
</li>
<li><p>这使得共享资源库的上游库项目存​​储库。</p>
</li>
</ol>
<h3>您可以创建一个新项目开发的Mac OS X服务器和主机守则</h3>
<p>当您创建您的开发Mac上的项目，你可以创建一个共享库。创建一个共享的项目之前，你必须：</p>
<ol>
<li>作为OS X服务器运行Xcode的服务的管理员进行身份验证。</li>
<li>确保服务器和Xcode的服务的，允许远程登录访问，通过安全Shell（SSH），它承载的存储库。在OS X服务器，你可以配置远程登录，在“系统偏好设定”中的“共享”窗格中。</li>
</ol>
<h4>要创建共享项目</h4>
<ol>
<li><p>选择“文件”&gt;“新建”&gt;“项目。</p>
</li>
<li><p>为您的项目中选择一个模板。</p>
</li>
<li><p>指定项目的选项，并单击“下一步”。</p>
</li>
<li><p>指定的位置。</p>
</li>
<li><p>选择“创建git仓库”选项。</p>
</li>
<li><p>确定服务器。</p>
</li>
</ol>
<p>单击“创建”。</p>
<p>您可以使用Git来管理你的开发Mac上的非托管的工作区目录<br>当你创建一个Xcode的工作区或项目，你必须包括一个Git仓库中生成的工作区目录的选项。如果您没有选择该选项，您的工作区目录不包括一个Git仓库。与他人使用Git版本控制系统要共享工作区目录，在该目录中，你必须初始化一个Git仓库。</p>
<p>您可以使用Subversion的管理项目<br>Xcode的服务可以连接你的Subversion版本库，并从它的检查项目。</p>
<h2>使用搜索引擎来生成，运行静态分析，测试和存档</h2>
<p>您可以运行一个项目的集成通过三个计划行动：</p>
<ol>
<li>分析，进行静态分析。</li>
<li>测试，运行一组测试案例。</li>
<li>存档，建立一个归档的产品，计划建成。</li>
</ol>
<p>您可以手动执行这些操作，为您做出更改产品。然而，手动集成可以是乏味且容易出错。例如，你可能会忘记发布一个小的变化，打破你的队友的单元测试之前进行测试操作。Xcode的服务提供了一个具有成本效益的方式自动执行集成：机器人。机器人会自动执行你的集成：</p>
<ol>
<li>每次更改发布到存储库。</li>
<li>上定期（比如说，每天进行集成，需要很长的时间才能完成）。<br>Â 机器人运行通过Xcode的服务，以在资源库中的项目的当前版本进行集成，是一个过程。包括一个集成构建，分析，测试，归档产品上。可以是成功的积分（即，所有的整合动作传递没有问题）的或不成功的。计划中定义的集成自动化，您必须共享该方案，并创建一个或多个机器人来执行这些集成。</li>
</ol>
<p>要充分利用您的产品开发流程的持续集成环境中，遵循以下做法：</p>
<ol>
<li><p>制定适当的单元测试套件和测试用例，显影单元测试后，包括他们在你的机器人运行计划。要了解关于单元测试的更多信息，请参见Xcode的单元测试指南<br>为了帮助确保您所做的更改都破不了您或其他人后，你应​​该配合这些变化与单元测试，确定是否规定一种或一组序列功能的方法。有些球队在它的头把这种方法首先开发测试，通过测试的方法，然后执行。</p>
</li>
<li><p>执行静态分析，你应该在您的集成包括静态分析。<br>静态分析是深刻检查你的代码，下面的代码路径，您的应用程序可能不遵循正常的发展过程中。这个过程揭示难以发现的编码错误，还确定了在你的代码不遵循建议的API的用法，比如基金会和AppKit的成语。</p>
</li>
<li><p>确保您的产品建立和正���打包。您您的产品作出了重大变化，特别是结构性的变化，如添加或删除文件后，应归档。让你的机器人自动为您归档。<br>当您的产品中包含的结构性问题，Xcode可以创建一个归档它为你的团队成员之间共享或提交到App Store。建立和归档产品的能力是你的代码更改的正确性的主要指标。</p>
</li>
</ol>
<h2>分享计划</h2>
<p>共享的计划被确定为在一个项目中共享和发布共享资源库，以及与其他共享项目文件。你可以分享计划之前，你必须检查的项目。</p>
<h3>要共享计划</h3>
<ol>
<li><p>开发的Mac上，打开的项目，其中包含共享的计划。</p>
</li>
<li><p>选择产品&gt;计划&gt;管理计划。</p>
</li>
<li><p>分享的计划，选择共享选项，并单击“确定”。</p>
</li>
<li><p>选择源控制&gt;提交。</p>
</li>
<li><p>选择共享的资料夹。</p>
</li>
<li><p>指定你提交的信息：</p>
<ul>
<li>在文本字段中输入你的提交信息。</li>
<li>选择“推到远程”选项（如果您的项目使用Git管理）。</li>
</ul>
</li>
<li><p>点击“提交文件”按钮。</p>
</li>
</ol>
<h2>创建机器人</h2>
<p>共享计划后，你可以创建一个机器人来执行持续集成。</p>
<p>要创建一个僵尸</p>
<p>开发的Mac上，打开的项目，其中包含计划，定义的行动，以自动化。</p>
<p>选择产品&gt;创建BOT，指定机器人的标识属性，并单击“下一步”。</p>
<p>与指定库凭据机器人，并单击“下一步”。</p>
<p>指定的整合时间表，行动的机器人来执行，以及是否清洁产品前建设。</p>
<p>附表：指定往往机器人集成。</p>
<p>定期：整合每小时，每天或每周。<br>在提交更改时集成发布到存储库。<br>手册：机器人不会自动整合。<br>操作：选择机器人作为整合的一部分执行的行动。</p>
<p>清洁：指定机器人是否重用以前的版本。</p>
<p>单击“下一步”。</p>
<p>如果您选择创建机器人执行第一次整合，整合的结果，出现在日志中的导航仪。</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/hexo/" term="hexo"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[xcode 5.0 的持续继承]]></title>
    <link href="http://hufeng825.github.com/2013/08/31/ios8/"/>
    <id>http://hufeng825.github.com/2013/08/31/ios8/</id>
    <published>2013-08-31T12:41:27.000Z</published>
    <updated>2013-08-31T13:42:46.000Z</updated>
    <content type="html"><![CDATA[<p>&gt;<br>Xcode的支持持续集成通过Xcode的服务流程。Xcode的服务，可在OS X服务器，自动一体化建设过程中，您的应用程序的分析，测试和归档。<a id="more"></a>从开发的Mac，您可以创建机器人上运行一个单独的服务器，在那里他们执行这些集成。机器人可以帮助确保您的产品始终处于释放状态，当有故障时，服务会通知你的人或代码变化引起的故障。</p>
<img src="http://img.blog.csdn.net/20130617220248765" class="left" width="400" height="600">


<hr>
<h2>概览</h2>
<p>按照本文档中列出的步骤，建立一个持续集成的工作流程，使用Xcode和Xcode服务。<br>    注：持续集成工作流程通常依赖于一个或多个开发Mac上运行Xcode和一个独立的OS X服务器运行Xcode的服务。但是，您可以安装开发的Mac OS X Server的。这样的配置可以有助于评估如何采用持续集成。之后，你会发现它有一个专门的OSX服务器运行Xcode的托管服务，你的资料库，并远程执行集成更多有用的。</p>
<hr>
<h2>设置和自定义的Xcode服务</h2>
<pre><code>即使你从来没有架设一台服务器，你会发现OSX服务器上设立了Xcode服务是简单的过程。后服务运行起来，你可以添加开发设备，配置机器人，并指定发布标准。</code></pre>
<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/200-Adopting_a_Continuous_Integration_Workflow/adopt_continuous_integration.html#//apple_ref/doc/uid/TP40013292-CH3-SW1" target="_blank">有关章节： “采用持续集成工作流”</a></p>
<hr>
<h2>创建和运行僵尸</h2>
<pre><code>机器人的自动化工作流程的心脏。机器人构建和测试产品与您选择的方案。随着Xcode的服务能够访问你的项目的源代码库中，您可以创建并安排定期运行或在每个源代码提交的机器人。您也可以设定机器人发送邮件通知其集成的成功或失败。</code></pre>
<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots/ConfigureBots.html#//apple_ref/doc/uid/TP40013292-CH9-SW1" target="_blank">有关章节： “配置机器人执行连续集成”</a></p>
<h2>监控和​​管理集成</h2>
<pre><code>机器人的自动化工作流程的心脏。机器人构建和测试您的产品，您所选择的计划。Xcode的服务提供了日志管理机器人，查看测试结果，并读取整合日志导航。该服务还提供了通过一个网页，在那里您可以查看bot活动的总结以及集成细节的结果。</code></pre>
<p><a href="https://daw.apple.com/cgi-bin/WebObjects/DSAuthWeb.woa/wa/login?appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&amp;path=%2F%2Flibrary%2Fprerelease%2Fios%2Fdocumentation%2FIDEs%2FConceptual%2Fxcode_guide-continuous_integration%2F300-Working_with_Bots%2Fview_integration_results%2Ehtml#//apple_ref/doc/uid/TP40013292-CH4-SW1" target="_blank">有关章节： “工作与机器人”</a></p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[快速清除subviews之 隐私循环]]></title>
    <link href="http://hufeng825.github.com/2013/08/29/ios7/"/>
    <id>http://hufeng825.github.com/2013/08/29/ios7/</id>
    <published>2013-08-29T10:48:47.000Z</published>
    <updated>2013-09-10T15:17:08.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>问：如何快速把当前view下的所有子view 及其子子view们删除掉<br><a id="more"></a><br>解答这个问题前先介绍下 NSArray </p>
</blockquote>
<p>NSArray 类定义的方法</p>
<ol>
<li>makeObjectsPerformSelector:@select（aMethod）</li>
</ol>
<p>简介：让数组中的每个元素 都调用 aMethod </p>
<ol>
<li><p>makeObjectsPerformSelector:@select（aMethod）</p>
<p>　　　　              withObject:oneObject</p>
</li>
</ol>
<p><strong>ps：让数组中的每个元素 都调用 aMethod  并把 withObject 后边的 oneObject 对象做为参数传给方法aMethod</strong></p>
<p>因此可以利用隐私循环来快速清除subviews</p>
<p>[[self.view subviews] makeObjectsPerformSelector:@selector(removeFromSuperview)];</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
</feed>
