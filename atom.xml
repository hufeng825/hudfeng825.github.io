<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[阿峰的技术窝窝]]></title>
  <subtitle><![CDATA[专注于移动互联网]]></subtitle>
  <link href="http://hufeng825.github.com/atom.xml" rel="self"/>
  <link href="http://hufeng825.github.com"/>
  <updated>2013-09-22T15:00:01.385Z</updated>
  <id>http://hufeng825.github.com/</id>
  <author>
    <name><![CDATA[Jason Hu]]></name>
    <email><![CDATA[hufeng@hufengvip.cn]]></email>
  </author>
  <generator uri="http://zespia.tw/hexo">Hexo</generator>
  <entry>
    <title type="html"><![CDATA[ios7之Sprite Kit vs Cocos2D]]></title>
    <link href="http://hufeng825.github.com/2013/09/22/ios29/"/>
    <id>http://hufeng825.github.com/2013/09/22/ios29/</id>
    <published>2013-09-22T11:50:03.000Z</published>
    <updated>2013-09-22T14:47:47.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Xcode5正式版发布了，全新的ui当然带来了全新的功能。今天阿峰就给大家来介绍下Sprite Kit。</p>
</blockquote>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1e8vnf9f1k4j20jt0d3abu.jpg" class="center 500 400">


<a id="more"></a> 

<h2>一、什么是Sprite Kit</h2>
<p>打开app store 下载最多的的是2D 游戏。比较有名不如 愤怒的小鸟 割绳子啦。 这些游戏之所以能够如此受欢迎跟他们 出色的粒子特效 物理引擎 炫酷的动画 还有漂亮的界面和声音效果离不开。</p>
<p>在ios7 发布之前 想要做出这样的游戏 只能依靠第三方的游戏引擎库，比较有名的就是Cocos2d 以及衍生的Cocos2d-X。现在ios7发布了 我们可以不借助第三方工具就可以实现了。Sprite Kit 提供了 包括 动画精灵，形状，粒子（火焰，烟雾），动画，物理效果，音频 视频等。Xcode5 还提供支持了纹理包和粒子设计哦。</p>
<p>Sprite Kit 可以在逻辑上分为以下的三个部分</p>
<h3>Scenes(场景)</h3>
<p>在cocos2d的游戏场景的视觉层。他提供了物体（如树木，汽车，飞机，头像等）的背景。</p>
<h3>Actions(动作)</h3>
<p>流畅的动画是游戏的重要组成部分。苹果设计的Actions非常简洁。他可以让你实现你想要做的任何事情。比如说一些常见的动作:移动 淡入淡出 缩放 旋转 动画纹理 组动画等等。 如果这些你还不满足，你可以自己创建一个代码块来实现自己想要的动作来操控对象。</p>
<h3>Physics(物理引擎)</h3>
<p>你想让你一个游戏具有很强的现实感，那物理引擎你一定用的到。 不然射出的子弹永远不会落地，橡胶球落地不会弹起来哈。</p>
<hr>
<h2>二、选择Sprite Kit的理由</h2>
<h3>性能</h3>
<p>苹果自家推出的东西在自家平台上肯定有着得天独厚的优势（尽管很多游戏开发商需要让他们的游戏在不同的系统上运行）。但是苹果在系统和硬件上累计的经验足够说服开发商选用自家的游戏引擎了。</p>
<h3>平台集成</h3>
<p>如上所述。Sprite Kit 跟Xcode 5 集成的天衣无缝。Xcode5 为游戏提供了很多开发组件。</p>
<h3>版本升级</h3>
<p>使用第三方库或者游戏引擎编写游戏肯定会有这方面的担忧。我们永远不知道将来的对系统的兼容性如何。不如说已死的Tree20 等等。 ios 每出一个版本都会有API的变动。虽然会有开源社区对其第三方库进行维护 但是这需要时间哈。用苹果自家的东西 就不用担心这方面了。</p>
<p>随着Sprite Kit的退出。苹果已经提供了一套工具，以确保开发的游戏代码能够在任何苹果版本和机型正常运行。 注意的是Sprite Kit 并不只是ios的框架。 开发人员也可以来开发OS X 上的游戏。</p>
<h3>友好的开发接口</h3>
<p>cocos2d之所以成功离不开其较低的门槛。相比起OpenGL ES 那些晦涩的接口 恼人的实现来说cocos2d ,简直太方便了。</p>
<p>Sprite Kit遵循了这点。其提供的接口非常简洁方便。另外其文档也非常详细 设计工具也很棒。甚至连cocos2d的首席开发工程师也在”此处和谐 国外被墙聊天工具“上感慨说</p>
<blockquote>
<p>prite Kit is very good. With less features than Cocos2D, but better. I like the physics integration.</p>
</blockquote>
<hr>
<h2>三、Sprite Kit &amp; Cocos2D Features</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>Sprite Kit</th>
<th>Cocos2D</th>
</tr>
</thead>
<tbody>
<tr>
<td>Open Source</td>
<td><code>No</code></td>
<td>Yes</td>
</tr>
<tr>
<td>Objective-C  Native Support</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Graphics Engine</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Animations</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Physics Simulation</td>
<td>Yes (Integrated)</td>
<td><code>No (Requires Box2D or Chipmunk)</code></td>
</tr>
<tr>
<td>Particle Effects</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Xcode Native Integration</td>
<td>Yes</td>
<td><code>No</code></td>
</tr>
<tr>
<td>Automatic Atlas Creation</td>
<td>Yes</td>
<td><code>No</code></td>
</tr>
<tr>
<td>Built-In Particle Editor</td>
<td>Yes</td>
<td><code>No</code></td>
</tr>
<tr>
<td>Shaders</td>
<td><code>No</code></td>
<td>Yes</td>
</tr>
<tr>
<td>Camera</td>
<td><code>No</code></td>
<td>Yes</td>
</tr>
</tbody>
</table>
<hr>
<h2>四、项目对比</h2>
<p>对比 Sprite Kit  和  Cocos2D 区别 还是看代码比较合适<br><a href="http://cdn.tutsplus.com/mobile.tutsplus.com/uploads/2013/09/ios7SpriteKit.zip" target="_blank">Sprite Kit 工程</a><br><a href="http://cdn.tutsplus.com/mobile.tutsplus.com/uploads/2013/09/ios7cocos2d.zip" target="_blank">Cocos2D 工程</a></p>
<h2>五、代码比较</h2>
<p>下面我们将从概念上来比较两者的不同</p>
<h3>CClayer vs. SKScene</h3>
<p>CCLayer或SkScene 是最主要的对象用来绘制其他的对象。 你可以把他想象成默认的一个view，这个view 可以接收所有的对象，动画或者touch 事件。</p>
<p>在Cocos2d进行场景切换 需要下面几步：</p>
<pre><code>GameScene* gameScene = <span class="string">[[GameScene alloc] init];
[ [CCDirector sharedDirector] replaceScene:gameScene ];</code></pre>
<p>注意GameScene.h 中 必须继承CCLayer 且初始化一个CCScene</p>
<pre><code>@<span class="class"><span class="keyword">interface</span> <span class="title">GameScene</span> : <span class="title">CCLayer</span> {</span>}
+(CCScene *) scene;</code></pre>
<p>在 GameScene.m, 初始化:</p>
<pre><code>+(CCScene *)scene
{
    CCScene *scene = [CCScene node];
    GameScene *layer = [GameScene node];
    [scene addChild: layer];
    <span class="keyword">return</span> scene;
}
-(<span class="keyword">id</span>) init{
    <span class="keyword">if</span>( (<span class="keyword">self</span>=[<span class="keyword">super</span> init] )) {
        <span class="comment">// Your code here</span>
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}</code></pre>
<p>在 Sprite Kit 中只需要如下</p>
<pre><code>GameScene* gameScene = [ [GameScene alloc] initWithSize:CGSizeMake(<span class="number">1024</span>, <span class="number">768</span>) ]<span class="comment">;</span>
[ self<span class="preprocessor">.scene</span><span class="preprocessor">.view</span> presentScene:gameScene ]<span class="comment">;</span>
}</code></pre>
<p>GameScene 必须继承 SKScene , 调用如下 -(id)initWithSize:(CGSize)size 初始化:</p>
<pre><code>-(<span class="keyword">id</span>)initWithSize:(<span class="built_in">CGSize</span>)size
{
    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithSize:size])
    {
        <span class="comment">// Your code</span>
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}</code></pre>
<h3>CCSprite vs. SKSpriteNode</h3>
<p>精灵对象通常用来显示某种图形。他有如下几种属性：旋转 缩放 位移 框架 等等。Cocos2D 实现如下：</p>
<pre><code>CCSprite* aSprite<span class="comment">;</span>
aSprite = [CCSprite spriteWithFile:@<span class="string">"player.png"</span>]<span class="comment">;</span>
aSprite<span class="preprocessor">.scale</span> = <span class="number">.5</span><span class="comment">;</span>
aSprite<span class="preprocessor">.position</span> = ccp(_size<span class="preprocessor">.width</span>/<span class="number">1.30</span>, _size<span class="preprocessor">.height</span>/<span class="number">1.25</span>)<span class="comment">;</span>
[self addChild:aSprite]<span class="comment">;</span></code></pre>
<p>Sprite Kit 实现如下：</p>
<pre><code>SKSpriteNode* planeShadow = [SKSpriteNode spriteNodeWithImageNamed:@<span class="string">"player.png"</span>]<span class="comment">;</span>
planeShadow<span class="preprocessor">.scale</span> = <span class="number">0.5</span><span class="comment">;</span>
planeShadow<span class="preprocessor">.position</span> = CGPointMake(CGRectGetMidX(self<span class="preprocessor">.frame</span>)+<span class="number">100</span>,CGRectGetMidY(self<span class="preprocessor">.frame</span>)+<span class="number">200</span>)<span class="comment">;</span>
[self addChild:planeShadow]<span class="comment">;</span></code></pre>
<h3>CCLabelTTF vs. SKLabelNode</h3>
<p>Label对象用于显示文字。它可以有几个属性，包括文字，文字大小，文字颜色，位置等等。Cocos2D和Sprite Kit是相似的。<br>Cocos2D：</p>
<pre><code>CCLabelTTF *label = [CCLabelTTF labelWithString:@<span class="string">"Hello World"</span> fontName:@<span class="string">"Marker Felt"</span> fontSize:<span class="number">64</span>];
// ask director <span class="keyword">for</span> the window size
CGSize size = <span class="string">[[CCDirector sharedDirector] winSize];
label.position =  ccp( size.width /2 , size.height/2 );
[self addChild: label];</code></pre>
<p>Sprite Kit:</p>
<pre><code><span class="class">SKLabelNode</span>* gameScene = [<span class="class">SKLabelNode</span> <span class="method">labelNodeWithFontNamed:</span>@<span class="comment">"Chalkduster"</span>];
[gameScene <span class="method">setText:</span>@<span class="comment">"New Game"</span>];
[gameScene <span class="method">setFontSize:</span><span class="number">18</span>];
gameScene <span class="method">setPosition:</span><span class="class">CGPointMake</span>(<span class="class">CGRectGetMidX</span>(<span class="keyword">self</span>.frame)+<span class="number">5</span>,<span class="class">CGRectGetMidY</span>(<span class="keyword">self</span>.frame)-<span class="number">40</span>)];
[<span class="keyword">self</span> <span class="method">addChild:</span>gameScene];</code></pre>
<h3>CCMenu and CCMenuItem vs. Sprite Kit Menu</h3>
<p>Cocos2D中创建菜单需要两个对象：CCMenu 和 CCMenuItem. 下面是创建两个菜单项的例子</p>
<pre><code><span class="class">CGSize</span> size = [[<span class="class">CCDirector</span> sharedDirector] winSize];
[<span class="class">CCMenuItemFont</span> <span class="method">setFontSize:</span><span class="number">28</span>];
<span class="class">CCMenuItem</span> *itemNewGame = [<span class="class">CCMenuItemFont</span> <span class="method">itemWithString:</span>@<span class="comment">"New Game"</span> <span class="method">block:</span>^(id sender) {
    // <span class="class">Your</span> code
}];
<span class="class">CCMenuItem</span> *itemOptions = [<span class="class">CCMenuItemFont</span> <span class="method">itemWithString:</span>@<span class="comment">"Options"</span> <span class="method">block:</span>^(id sender) {
    <span class="class">NSLog</span>(@<span class="comment">"Second item"</span>);
}];
<span class="class">CCMenu</span> *menu = [<span class="class">CCMenu</span> <span class="method">menuWithItems:</span>itemNewGame, itemOptions, <span class="keyword">nil</span>];
[menu <span class="method">alignItemsHorizontallyWithPadding:</span><span class="number">20</span>];
[menu <span class="method">setPosition:</span>ccp( size.width/<span class="number">2</span>, size.height/<span class="number">2</span> - <span class="number">50</span>)];
[<span class="keyword">self</span> <span class="method">addChild:</span>menu];</code></pre>
<p>Spite Kit不包括任何类型的菜单的特定对象。<br>下面的例子我们用了 SKLabelNode作为 menu item. 首先我们定义 SKLabelNode:</p>
<pre><code><span class="class">SKLabelNode</span>*  gameScene = [<span class="class">SKLabelNode</span> <span class="method">labelNodeWithFontNamed:</span>@<span class="comment">"Chalkduster"</span>];
[gameScene <span class="method">setText:</span>@<span class="comment">"New Game"</span>];
[gameScene <span class="method">setFontSize:</span><span class="number">18</span>];
[gameScene <span class="method">setPosition:</span><span class="class">CGPointMake</span>(<span class="class">CGRectGetMidX</span>(<span class="keyword">self</span>.frame)+<span class="number">5</span>,<span class="class">CGRectGetMidY</span>(<span class="keyword">self</span>.frame)-<span class="number">40</span>)];
[<span class="keyword">self</span> <span class="method">addChild:</span>gameScene];</code></pre>
<p>在 <strong>-(void)touchesBegan:(NSSet <em>)touches withEvent:(UIEvent </em>)event</strong> 方法里面 我们创建截获事件</p>
<pre><code><span class="keyword">for</span> (UITouch *touch <span class="keyword">in</span> touches)
{
    CGPoint location = [touch locationInNode:self];
    <span class="keyword">if</span> ([gameScene containsPoint:location]) {
        // Scene Transition Animation
        SKTransition* reveal = [SKTransition revealWithDirection:SKTransitionDirectionDown duration:<span class="number">1</span>];
        GameScene* gameScene = <span class="string">[[GameScene alloc] initWithSize:CGSizeMake(1024, 768)];
        [self.scene.view presentScene:gameScene transition:reveal];
        NSLog(@"Touched gameScene!!!!");
    }
} </code></pre>
<p>上面代码做了下面几件事情</p>
<ol>
<li>激活触摸时间</li>
<li>将敲击的坐标转换成内部坐标</li>
<li>验证敲击的坐标是否在SKLabelNode的动画场景内</li>
<li>创建过渡动画</li>
<li>转换场景</li>
</ol>
<h3>Action vs. SKAction</h3>
<p>区别最大的是Action 。SKAction是一个较复杂的对象。Action在Cocos2D 仅仅是一个动作。程序员必须定义 调用 创建。<br>但是Sprite Kit中，SKAction 提供了如下的开发比如旋转 缩放 重复, 消失 播放声音 等等。 SKaction是一个抽象类能够处理任何种类的动作。<br>在cocos2d 我们需要定义一个调节调用的自定义方法<br>    [self schedule:@selector(addSprite:) interval:1];<br>然后在自定义的方法中添加我们自定义的动画:</p>
<pre><code>- (void) addSprite:(ccTime)dt
{
    CCSprite* aMovableSprite = [CCSprite spriteWithFile:@<span class="string">"frankenstein.png"</span>]<span class="comment">;</span>
    aMovableSprite<span class="preprocessor">.scale</span> = <span class="number">.8</span><span class="comment">;</span>
    [self addChild:aMovableSprite]<span class="comment">;</span>
    CGSize winSize = [CCDirector sharedDirector]<span class="preprocessor">.winSize</span><span class="comment">;</span>
    int minX = aMovableSprite<span class="preprocessor">.contentSize</span><span class="preprocessor">.width</span> / <span class="number">2</span><span class="comment">;</span>
    int maxX = winSize<span class="preprocessor">.width</span> - aMovableSprite<span class="preprocessor">.contentSize</span><span class="preprocessor">.width</span>/<span class="number">2</span><span class="comment">;</span>
    int rangeX = maxX - minX<span class="comment">;</span>
    int actualY = (arc4random() % rangeX) + minX<span class="comment">;</span>
    CCCallBlockN * actionMoveDone = [CCCallBlockN actionWithBlock:^(CCNode *node) {
        NSLog(@<span class="string">"Sprite free!"</span>)<span class="comment">;</span>
    }]<span class="comment">;</span>
    NSMutableArray *arrayBezier = [[NSMutableArray alloc] init]<span class="comment">;</span>
    ccBezierConfig bezier<span class="comment">;</span>
    id bezierAction1<span class="comment">;</span>
    float splitDuration = <span class="number">6</span> / <span class="number">6.0</span><span class="comment">;</span>
    for(int i = <span class="number">0</span><span class="comment">; i&lt; 6; i++){</span>
        if(i % <span class="number">2</span> == <span class="number">0</span>){
            bezier<span class="preprocessor">.controlPoint</span>_1 = ccp(actualY+<span class="number">100</span>,winSize<span class="preprocessor">.height</span>-(<span class="number">100</span>+(i*<span class="number">200</span>)))<span class="comment">;</span>
            bezier<span class="preprocessor">.controlPoint</span>_2 = ccp(actualY+<span class="number">100</span>,winSize<span class="preprocessor">.height</span>-(<span class="number">100</span>+(i*<span class="number">200</span>)))<span class="comment">;</span>
            bezier<span class="preprocessor">.endPosition</span> = ccp(actualY,winSize<span class="preprocessor">.height</span>-(<span class="number">200</span>+(i*<span class="number">200</span>)))<span class="comment">;</span>
            bezierAction1 = [CCBezierTo actionWithDuration:splitDuration bezier:bezier]<span class="comment">;</span>
        }
        else{
            bezier<span class="preprocessor">.controlPoint</span>_1 = ccp(actualY-<span class="number">100</span>,winSize<span class="preprocessor">.height</span>-(<span class="number">100</span>+(i*<span class="number">200</span>)))<span class="comment">;</span>
            bezier<span class="preprocessor">.controlPoint</span>_2 = ccp(actualY-<span class="number">100</span>,winSize<span class="preprocessor">.height</span>-(<span class="number">100</span>+(i*<span class="number">200</span>)))<span class="comment">;</span>
            bezier<span class="preprocessor">.endPosition</span> = ccp(actualY,winSize<span class="preprocessor">.height</span>-(<span class="number">200</span>+(i*<span class="number">200</span>)))<span class="comment">;</span>
            bezierAction1 = [CCBezierTo actionWithDuration:splitDuration bezier:bezier]<span class="comment">;</span>
        }
        [arrayBezier addObject:bezierAction1]<span class="comment">;</span>
    }
    [arrayBezier addObject:actionMoveDone]<span class="comment">;</span>
    id seq = [CCSequence actionsWithArray:arrayBezier]<span class="comment">;</span>
    [aMovableSprite runAction:seq]<span class="comment">;</span>
}</code></pre>
<p>在Sprite Kit中 我们使用SKAction来控制对象开始和结束的运行状况</p>
<pre><code><span class="class">SKSpriteNode</span>* playerSprite = [<span class="class">SKSpriteNode</span> <span class="method">spriteNodeWithImageNamed:</span>@<span class="comment">"player.png"</span>];
[playerSprite <span class="method">setScale:</span><span class="number">0.4</span>];
<span class="class">SKAction</span> *movement =[<span class="class">SKAction</span> <span class="method">moveTo:</span><span class="class">CGPointMake</span>(<span class="number">900</span>, <span class="number">500</span>) <span class="method">duration:</span><span class="number">5</span>];
<span class="class">SKAction</span> *remove = [<span class="class">SKAction</span> removeFromParent];
[playerSprite <span class="method">runAction:</span>[<span class="class">SKAction</span> <span class="method">sequence:</span>@[movement,remove]]];
[<span class="keyword">self</span> <span class="method">addChild:</span>playerSprite];</code></pre>
<p>但是我们定义一个自定义的动画然后用SKAction来激活这个动作。下面的例子说明了贝塞尔运动。</p>
<pre><code><span class="class">SKAction</span> *wait = [<span class="class">SKAction</span> <span class="method">waitForDuration:</span><span class="number">1</span>];
<span class="class">SKAction</span> *callEnemies = [<span class="class">SKAction</span> <span class="method">runBlock:</span>^{
    [<span class="keyword">self</span> sendNewSKSpriteNode];
}];
<span class="class">SKAction</span> *updateSKSpriteNodeOnScreen = [<span class="class">SKAction</span> <span class="method">sequence:</span>@[wait,callEnemies]];
[<span class="keyword">self</span> <span class="method">runAction:</span>[<span class="class">SKAction</span> <span class="method">repeatActionForever:</span>updateSKSpriteNodeOnScreen]]; </code></pre>
<p>下面的sendNewSKSpriteNode将处理自定义对象的运动。</p>
<pre><code>-(<span class="keyword">void</span>) sendNewSKSpriteNode{
    <span class="built_in">CGRect</span> screenRect = [[UIScreen mainScreen] bounds];
    <span class="comment">// Custom SKAction</span>
    SKSpriteNode* enemy = [SKSpriteNode spriteNodeWithImageNamed:@<span class="string">"frankenstein.png"</span>];
    enemy<span class="variable">.scale</span> = <span class="number">0.6</span>;
    CGMutablePathRef cgpath = CGPathCreateMutable();
    <span class="comment">//random values</span>
    <span class="keyword">float</span> xStart = [<span class="keyword">self</span> getRandomNumberBetween:<span class="number">0</span>+enemy<span class="variable">.size</span><span class="variable">.width</span> to:screenRect<span class="variable">.size</span><span class="variable">.width</span>-enemy<span class="variable">.size</span><span class="variable">.width</span> ];
    <span class="keyword">float</span> xEnd = [<span class="keyword">self</span> getRandomNumberBetween:<span class="number">0</span>+enemy<span class="variable">.size</span><span class="variable">.width</span> to:screenRect<span class="variable">.size</span><span class="variable">.width</span>-enemy<span class="variable">.size</span><span class="variable">.width</span> ];
    <span class="comment">//ControlPoint1</span>
    <span class="keyword">float</span> cp1X = [<span class="keyword">self</span> getRandomNumberBetween:<span class="number">0</span>+enemy<span class="variable">.size</span><span class="variable">.width</span> to:screenRect<span class="variable">.size</span><span class="variable">.width</span>-enemy<span class="variable">.size</span><span class="variable">.width</span> ];
    <span class="keyword">float</span> cp1Y = [<span class="keyword">self</span> getRandomNumberBetween:<span class="number">0</span>+enemy<span class="variable">.size</span><span class="variable">.width</span> to:screenRect<span class="variable">.size</span><span class="variable">.width</span>-enemy<span class="variable">.size</span><span class="variable">.height</span> ];
    <span class="comment">//ControlPoint2</span>
    <span class="keyword">float</span> cp2X = [<span class="keyword">self</span> getRandomNumberBetween:<span class="number">0</span>+enemy<span class="variable">.size</span><span class="variable">.width</span> to:screenRect<span class="variable">.size</span><span class="variable">.width</span>-enemy<span class="variable">.size</span><span class="variable">.width</span> ];
    <span class="keyword">float</span> cp2Y = [<span class="keyword">self</span> getRandomNumberBetween:<span class="number">0</span> to:cp1Y];
    <span class="built_in">CGPoint</span> s = CGPointMake(xStart, <span class="number">1024.0</span>);
    <span class="built_in">CGPoint</span> e = CGPointMake(xEnd, -<span class="number">100.0</span>);
    <span class="built_in">CGPoint</span> cp1 = CGPointMake(cp1X, cp1Y);
    <span class="built_in">CGPoint</span> cp2 = CGPointMake(cp2X, cp2Y);
    CGPathMoveToPoint(cgpath,<span class="literal">NULL</span>, s<span class="variable">.x</span>, s<span class="variable">.y</span>);
    CGPathAddCurveToPoint(cgpath, <span class="literal">NULL</span>, cp1<span class="variable">.x</span>, cp1<span class="variable">.y</span>, cp2<span class="variable">.x</span>, cp2<span class="variable">.y</span>, e<span class="variable">.x</span>, e<span class="variable">.y</span>);
    SKAction *planeDestroy = [SKAction followPath:cgpath asOffset:<span class="literal">NO</span> orientToPath:<span class="literal">YES</span> duration:<span class="number">5</span>];
    [<span class="keyword">self</span> addChild:enemy];
    SKAction *remove2 = [SKAction removeFromParent];
    [enemy runAction:[SKAction sequence:@[planeDestroy,remove2]]];
    CGPathRelease(cgpath);
}</code></pre>
<h3>CCParticleExplosion vs. Emitter</h3>
<p>Cocos2D中并没例子编辑器。必须使用外部应用程序创建例子 然后用特定的 CCParticleExplosion来改变其属性行为。在xcode中 你可以这样子来使用了:</p>
<pre><code>CCParticleExplosion* _particleExplosion<span class="comment">;</span>
particleExplosion = [[CCParticleExplosion alloc] initWithTotalParticles:<span class="number">800</span>]<span class="comment">;</span>
particleExplosion<span class="preprocessor">.texture</span> = [[CCTextureCache sharedTextureCache] addImage:@<span class="string">"texture.png"</span>]<span class="comment">;</span>
particleExplosion<span class="preprocessor">.life</span> = <span class="number">0.0</span>f<span class="comment">;</span>
particleExplosion<span class="preprocessor">.lifeVar</span> = <span class="number">0.708</span>f<span class="comment">;</span>
particleExplosion<span class="preprocessor">.startSize</span> = <span class="number">40</span><span class="comment">;</span>
particleExplosion<span class="preprocessor">.startSizeVar</span> = <span class="number">38</span><span class="comment">;</span>
particleExplosion<span class="preprocessor">.endSize</span> = <span class="number">14</span><span class="comment">;</span>
particleExplosion<span class="preprocessor">.endSizeVar</span> = <span class="number">0</span><span class="comment">;</span>
particleExplosion<span class="preprocessor">.angle</span> = <span class="number">360</span><span class="comment">;</span>
particleExplosion<span class="preprocessor">.angleVar</span> = <span class="number">360</span><span class="comment">;</span>
particleExplosion<span class="preprocessor">.speed</span> = <span class="number">243</span><span class="comment">;</span>
particleExplosion<span class="preprocessor">.speedVar</span> = <span class="number">1</span><span class="comment">;</span>
CGPoint g = CGPointMake(<span class="number">1.15</span>, <span class="number">1.58</span>)<span class="comment">;</span>
particleExplosion<span class="preprocessor">.gravity</span> = g<span class="comment">;</span>
ccColor4F startC =  {<span class="number">0.89</span>f, <span class="number">0.56</span>f, <span class="number">0.36</span>f, <span class="number">1.0</span>f}<span class="comment">;</span>
particleExplosion<span class="preprocessor">.startColor</span> = startC<span class="comment">;</span>
ccColor4F endC = {<span class="number">1.0</span>f,<span class="number">0.0</span>f,<span class="number">0.0</span>f,<span class="number">1.0</span>f}<span class="comment">;</span>
particleExplosion<span class="preprocessor">.endColor</span> = endC<span class="comment">;</span>
[self addChild:_particleExplosion]<span class="comment">;</span>
particleExplosion<span class="preprocessor">.position</span> = ccp(_size<span class="preprocessor">.width</span>/<span class="number">5</span>, _size<span class="preprocessor">.height</span>/<span class="number">5</span>)<span class="comment">;</span>
[particleExplosion resetSystem]<span class="comment">;</span></code></pre>
<p>发射器使用Sprite Kite粒子套件产生。 为了使用他们 你需要在项目中添加粒子。New -&gt; File -&gt; Resource -&gt; Sprite Kit Particle File 命名并且选择粒子类型（火 烟 雪 等等）。<br>如下图</p>
<img src="http://ww3.sinaimg.cn/mw690/a43af4ffjw1e8vnfhjmlgj20en07a3yz.jpg" width="400" height="500">

<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e8vnflpm16j206o05ft8q.jpg" width="300" height="500">


<p> 现在你会看到有两个新文件在xcode 中：</p>
<img src="http://ww4.sinaimg.cn/mw690/a43af4ffjw1e8vnls9m7bj203q018a9v.jpg" class="200 300">



<pre><code>SKEmitterNode* smokeTrail;
NSString *smokePath = <span class="string">[[NSBundle mainBundle] pathForResource:@"MyParticle" ofType:@"sks"];
smokeTrail = [NSKeyedUnarchiver unarchiveObjectWithFile:smokePath];
smokeTrail.position = CGPointMake(CGRectGetMidX(self.frame)+40,CGRectGetMidY(self.frame)-100);
[self addChild:smokeTrail];</code></pre>
<h3>SimpleAudioEngine vs. Sprite Kit Sound</h3>
<p>任何游戏应该都离不开多媒体吧，在cocos2d 我们要实现 需要两部<br>1：</p>
<pre><code>#<span class="import"><span class="keyword">import</span> "SimpleAudioEngine.h"</span></code></pre>
<p>2：</p>
<pre><code><span class="string">[[SimpleAudioEngine sharedEngine] playBackgroundMusic:@"sound.caf" loop:YES];
[[SimpleAudioEngine sharedEngine] setEffectsVolume:0.4f];</code></pre>
<p><strong>有时，Xcode中并没有自动包括“Copy Bundle Resources”中的音乐文件。如果发生这种情况，你应该手动添加。</strong></p>
<p>在Sprite Kit中 你能够很简单的添加声音</p>
<pre><code><span class="class">SKAction</span>* soundAction = [<span class="class">SKAction</span> <span class="method">playSoundFileNamed:</span>@<span class="comment">"preview.mp3"</span> <span class="method">waitForCompletion:</span><span class="class">NO</span>];
[<span class="keyword">self</span> <span class="method">runAction:</span>soundAction];</code></pre>
<p>下面是实现的一个火焰效果图</p>
<img src="http://ww4.sinaimg.cn/mw690/a43af4ffjw1e8vnfvcmmdj20d80k8jro.jpg" width="200" height="400">


<h2>结束语</h2>
<p>通过上面的分析 你会发现cocos2d 和Sprite kit 有很多相似之处。在易用性上 笔者觉得Spring kit 对ios开发者来说更加具有诱惑性。</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ios开发之MPNowPlayingInfoCenter 锁屏显示正在播放的音乐]]></title>
    <link href="http://hufeng825.github.com/2013/09/18/ios28/"/>
    <id>http://hufeng825.github.com/2013/09/18/ios28/</id>
    <published>2013-09-18T15:43:50.000Z</published>
    <updated>2013-09-18T17:33:56.000Z</updated>
    <content type="html"><![CDATA[<p>今天在床上玩唱吧,听着歌锁屏了,当点亮屏幕的时候,锁屏页面出现了我正在听得歌曲 壁纸也换成了唱吧里面的歌手图片.做ios好几年了,从没有做过这个需求 于是好奇就翻看ios的<a href="https://developer.apple.com/library/ios/documentation/mediaplayer/reference/MPNowPlayingInfoCenter_Class/Reference/Reference.html" target="_blank">API文档</a>找到了这个类.<br><a id="more"></a><br>如下图</p>
<img src="http://ww3.sinaimg.cn/mw690/a43af4ffjw1e8r3az0tbaj20g50litai.jpg" width="300" height="600">


<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e8r3b00x7aj20gj05wq3e.jpg" width="300" height="200">



<h2>MPNowPlayingInfoCenter 解释</h2>
<blockquote>
<p>即时播放中心能够用于播放APP中正在播放的媒体信息.<br>播放的信息会显示在锁屏页面和多任务管理页面.如果用户是用airplay播放的话 会自动投射到相应的设备上.</p>
</blockquote>
<p><a href="https://github.com/hufeng825/LockScreenInfo.git" target="_blank">下载源码</a></p>
<h2>开始动手</h2>
<h3>让App支持后台运行</h3>
<p>先创建工程,因为是audio 类型的app 需要支持后台播放 所以得要在plist 中声明属性.<br>添加如下属性</p>
<p>Required background modes -&gt; App plays audio<br>如下图</p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e8r45ojlcuj20l80a2q4l.jpg" class="left" width="300" height="400">


<h3>添加播放的Frame</h3>
<ol>
<li>AVFoundation.framework</li>
<li>MediaPlayer.framework</li>
</ol>
<img src="http://ww3.sinaimg.cn/mw690/a43af4ffjw1e8r4757worj208c03vq2z.jpg" class="left" width="300" height="400">



<h3>开始代码吧</h3>
<p>首先创建一个ViewController 和一个用于播放的按钮 playButton</p>
<pre><code>@<span class="class"><span class="keyword">interface</span> <span class="id">ViewController</span> : <span class="id">UIViewController</span> {</span>

<span class="keyword">IBOutlet</span> <span class="built_in">UIButton</span> *playButton;

}

@<span class="keyword">property</span> (<span class="keyword">nonatomic</span>, retain) <span class="keyword">IBOutlet</span> <span class="built_in">UIButton</span> *playButton;

-(<span class="keyword">IBAction</span>)playButtonPress:(<span class="keyword">id</span>)sender;</code></pre>
<p>加入播放用的控件audioPlayer 和其相应的头文件</p>
<pre><code><span class="preprocessor">#import <span class="title">&lt;MediaPlayer/MPNowPlayingInfoCenter.h&gt;</span></span>
<span class="preprocessor">#import <span class="title">&lt;MediaPlayer/MPMediaItem.h&gt;</span></span>
<span class="preprocessor">#import <span class="title">&lt;AVFoundation/AVFoundation.h&gt;</span></span>
<span class="built_in">MPMoviePlayerController</span> *audioPlayer;

@<span class="keyword">property</span> (<span class="keyword">nonatomic</span>, retain) <span class="built_in">MPMoviePlayerController</span> *audioPlayer;

@<span class="keyword">synthesize</span> playButton, audioPlayer;</code></pre>
<p>在viewDidLoad 中 我们要把AudioPlayer 进行初始化 此处加载网络上的一首音频</p>
<pre><code>[[AVAudioSession sharedInstance] setDelegate: <span class="keyword">self</span>];

<span class="built_in">NSError</span> *myErr;

<span class="comment">// Initialize the AVAudioSession here.</span>
<span class="keyword">if</span> (![[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:&amp;myErr]) {
    <span class="comment">// Handle the error here.</span>
    <span class="built_in">NSLog</span>(@<span class="string">"Audio Session error %@, %@"</span>, myErr, [myErr userInfo]);
}
<span class="keyword">else</span>{
    <span class="comment">// Since there were no errors initializing the session, we'll allow begin receiving remote control events</span>
    [[<span class="built_in">UIApplication</span> sharedApplication] beginReceivingRemoteControlEvents];
}

    <span class="comment">//initialize our audio player</span>
    audioPlayer = [[<span class="built_in">MPMoviePlayerController</span> alloc] initWithContentURL:[<span class="built_in">NSURL</span> URLWithString:@<span class="string">"http://www.cocoanetics.com/files/Cocoanetics_031.mp3"</span>]];

    [audioPlayer setShouldAutoplay:<span class="literal">NO</span>];
    [audioPlayer setControlStyle: MPMovieControlStyleEmbedded];
    audioPlayer<span class="variable">.view</span><span class="variable">.hidden</span> = <span class="literal">YES</span>;

    [audioPlayer prepareToPlay];</code></pre>
<p>点击按钮开始播放,注意因为MPNowPlayingInfoCenter只支持5.0+ 所以为了防止低版本使用 巧妙的应用了NSClassFromString进行了判断</p>
<pre><code>- (<span class="class">IBAction</span>)<span class="method">playButtonPress:</span>(id)sender {

    [audioPlayer play];

    <span class="class">Class</span> playingInfoCenter = <span class="class">NSClassFromString</span>(@<span class="comment">"MPNowPlayingInfoCenter"</span>);

    if (playingInfoCenter) {


        <span class="class">NSMutableDictionary</span> *songInfo = [ [<span class="class">NSMutableDictionary</span> alloc] init];


        <span class="class">MPMediaItemArtwork</span> *albumArt = [ [<span class="class">MPMediaItemArtwork</span> alloc] <span class="method">initWithImage:</span> [<span class="class">UIImage</span> <span class="method">imagedNamed:</span>@<span class="comment">"AlbumArt"</span>] ];

        [ songInfo <span class="method">setObject:</span> @<span class="comment">"Audio Title"</span> <span class="method">forKey:</span><span class="class">MPMediaItemPropertyTitle</span> ];
        [ songInfo <span class="method">setObject:</span> @<span class="comment">"Audio Author"</span> <span class="method">forKey:</span><span class="class">MPMediaItemPropertyArtist</span> ];
        [ songInfo <span class="method">setObject:</span> @<span class="comment">"Audio Album"</span> <span class="method">forKey:</span><span class="class">MPMediaItemPropertyAlbumTitle</span> ];
        [ songInfo <span class="method">setObject:</span> albumArt <span class="method">forKey:</span><span class="class">MPMediaItemPropertyArtwork</span> ];
        [ [<span class="class">MPNowPlayingInfoCenter</span> defaultCenter] <span class="method">setNowPlayingInfo:</span>songInfo ];
    }
}</code></pre>
<hr>
<p><a href="http://jaysonlane.net/tech-blog/2012/04/lock-screen-now-playing-with-mpnowplayinginfocenter/" target="_blank">参考 <a href="http://jaysonlane.net/tech-blog/2012/04/lock-screen-now-playing-with-mpnowplayinginfocenter/">http://jaysonlane.net/tech-blog/2012/04/lock-screen-now-playing-with-mpnowplayinginfocenter/</a></a></p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[阿里IOS面试题之多线程选用NSOperation or GCD]]></title>
    <link href="http://hufeng825.github.com/2013/09/18/ios26/"/>
    <id>http://hufeng825.github.com/2013/09/18/ios26/</id>
    <published>2013-09-18T05:31:04.000Z</published>
    <updated>2013-09-18T06:32:31.000Z</updated>
    <content type="html"><![CDATA[<p>今天早上接到了阿里从杭州打过来的电话面试.虽然近期面试了一些大中型的互联网企业,但是跟素有“IT界的黄浦军校”的阿里面试官接触还是不免紧张.<br><a id="more"></a><br>面试持续了三四十分钟吧,期间我手机信号不好挂断了一次,大部分问题都是更加简历上的项目经验而来的,个人感觉问的不算太难但是却很深入,很明显不是能够背几道面试题能够搞定的.而且每个题基本上都跟优化设计和性能相关.</p>
<p>其中有一道是关于是问“你平时上国外的一些网站吗?上那些网站呢?”</p>
<p>我平时大部分时间就是上stackoverflow.和cocoscontrol github 还有apple 的dev论坛.</p>
<p>“你们项目中为什么多线程用GCD 而不用NSOperation呢? 你有没有发现国外的大牛他们多线程都是用NSOperation? 你能告诉我他们这样做的理由吗?”</p>
<p>一下子把我问懵了.我之所以用GCD 是因为GCD用起来比较简单.代码不用分散 比较集中维护度比较高.而且代码的执行效率也要比NSOperation快些. 但是至于国外的大牛们为什么那样做 我还真的不清楚. 后来挂完电话 正好搜狐的家明哥打电话过来 我问了下他.家明哥跟我说他包括他之前在新浪做项目时也是能用GCD的地方就用GCD 尽量减少NSOperation的使用,因为GCD在多核CPU上线程切换的时间比较短 效率相对高些,至于阿里为什么那样,可能每个公司对某个技术有着不同的理解吧.</p>
<p>跟明哥挂了电话 我给对方回过去,到底为什么? 对方笑着问我:“你用GCD在ASI上封装的那层网络请求 为什么后来有创建了自���的一个队列对维护这些请求?NSOperation是建立在GCD之上的 虽然使用起来比较复杂 但是在线程并发管理 优先级 上有着GCD 无法比拟的优势.”</p>
<p>但是对我来说 我还是倾向于用GCD,正如家明说的 每个公司对相同的技术有着不同的理解吧.</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[再谈涉及模式]]></title>
    <link href="http://hufeng825.github.com/2013/09/17/ios25/"/>
    <id>http://hufeng825.github.com/2013/09/17/ios25/</id>
    <published>2013-09-17T15:09:18.000Z</published>
    <updated>2013-09-17T17:06:45.000Z</updated>
    <content type="html"><![CDATA[<p>某某曰:设计模式这东西,没有好坏之分，只有合适于不合适<br><a id="more"></a></p>
<p>今天去面试很有意思,技术考官指着最后一道二选一的编程题说,这是昨天晚上专门为你新加的.当时我听后倍感惭愧. 虽然当时在纸上把大概思路和设计说了下.为了感谢主考官的重视程度.我现在也亲自在电脑上把这个设计实现出来.<br>题目大概是这个意思: 一个咖啡店卖好几种咖啡:摩卡,布列夫,拿铁等等  咖啡有很多搭配:方糖,鲜牛奶,奶油,盐等. 试设计计算出咖啡(+搭配)的单价模型.</p>
<p>下面来谈谈我的想法</p>
<h2>一:虚基类 Coffee</h2>
<p>首先 我抽象出了一个虚基类 Coffee, 什么摩卡 布列夫 拿铁都继承这个类</p>
<p>这个类包含什么呢<br>{<br>. 咖啡的单价(不含 方糖 奶等 调味料) —&gt;price<br>. 一个存放调味料的容器 —&gt;ecoratorRelishChain<br>. 一个可以得到总价的方法 —&gt; getTotalPrices<br>}</p>
<p>下面是代码</p>
<p>基类咖啡.h</p>
<pre><code> <span class="comment">//abstract 咖啡基类</span>
 @<span class="class"><span class="keyword">class</span> <span class="title">DecoratorChain</span>;

 @<span class="title">interface</span>  <span class="title">Coffee</span>: <span class="title">NSObject</span>
 @<span class="title">property</span> ( <span class="title">nonatomic</span>,<span class="title">strong</span> ) <span class="title">DecoratorChain</span> *<span class="title">ecoratorRelishChain</span>;//用来存储 奶 方糖 等等的调料 可以把它想象成一个调味盒 
 @<span class="title">property</span> ( <span class="title">nonatomic</span>,<span class="title">strong</span> ) <span class="title">NSDecimalNumber</span> *<span class="title">price</span>;//单价 不含配料

 -(<span class="title">NSDecimalNumber</span> *) <span class="title">getTotalPrices</span>;//得到总价

 @<span class="title">end</span></code></pre>
<p>基类咖啡.m</p>
<pre><code>@<span class="class"><span class="keyword">interface</span> <span class="id">Coffee</span>()</span>
@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> * _coffeeName;
@<span class="keyword">end</span>

@<span class="class"><span class="keyword">implementation</span> <span class="id">Coffee</span></span>

@<span class="keyword">synthesize</span> _coffeeName,price,ecoratorRelishChain;
- (<span class="keyword">id</span>)init
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        _coffeeName=@<span class="string">"咖啡名称"</span>;
        price = [[NSDecimalNumber alloc] initWithString:@<span class="string">"20"</span>];
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}

-(NSDecimalNumber *)getTotalPrices
{

    <span class="keyword">return</span> [<span class="keyword">self</span><span class="variable">.price</span> decimalNumberByAdding: [ecoratorRelishChain getCountPrice]];
}

@<span class="keyword">end</span></code></pre>
<hr>
<h2>二: 虚基类 EcoratorRelish</h2>
<p>EcoratorRelish 是 方糖 奶油  牛奶 盐 等等的抽象类 这个继承在button  点击的时候 可以自动将自己加入到chain (调料盘中)</p>
<p>这个类包含什么呢<br>{<br>. 自身的单价 —&gt;price<br>. 可以修改价钱的策略 —&gt; configPrivilege<br>}</p>
<p>方糖 等抽象出来的基类EcoratorRelish.h</p>
<pre><code>@<span class="class"><span class="keyword">interface</span>  <span class="title">EcoratorRelish</span>: <span class="title">UIButton</span>
@<span class="title">property</span>(<span class="title">nonatomic</span>,<span class="title">strong</span>)  <span class="title">NSDecimalNumber</span> *<span class="title">price</span>;//单价 
//<span class="title">Overload</span>
-(<span class="title">void</span>)<span class="title">configPrivilege</span>;//可以配置优惠策略
-(<span class="title">DecoratorChain</span> *)<span class="title">getComponentCoffee</span>;
@<span class="title">end</span></code></pre>
<p>EcoratorRelish.m</p>
<pre><code>@<span class="class"><span class="keyword">implementation</span>  <span class="id">EcoratorRelish</span></span>
@<span class="keyword">synthesize</span>  price;

- (<span class="keyword">id</span>)init
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        [<span class="keyword">self</span> addTarget:<span class="keyword">self</span> action:@<span class="keyword">selector</span>(addDecoratorChain) forControlEvents:UIControlEventTouchUpInside];
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
<span class="comment">//Overload</span>
-(<span class="keyword">void</span>)configPrivilege
{
    <span class="comment">//可以配置优惠策略 </span>
}

<span class="comment">//获取当前的辅料坐在的ViewController</span>
- (<span class="built_in">UIViewController</span> *)getViewController {
    Class vcc = [<span class="built_in">UIViewController</span> <span class="built_in">class</span>];
    UIResponder *responder = <span class="keyword">self</span>;
    <span class="keyword">while</span> ((responder = [responder nextResponder]))
        <span class="keyword">if</span> ([responder isKindOfClass: vcc])
            <span class="keyword">return</span> (<span class="built_in">UIViewController</span> *)responder;
    <span class="keyword">return</span> <span class="literal">nil</span>;
}

<span class="comment">//获取要装饰的咖啡的调味盒(chain)</span>
-(DecoratorChain *)getEcoratorRelishChain
{
   <span class="keyword">return</span>  [<span class="keyword">self</span> getViewController]<span class="variable">.coffee</span><span class="variable">.ecoratorRelishChain</span>;
}

<span class="comment">//将自己加到咖啡的调味盒(chain)</span>
-(<span class="keyword">void</span>)addDecoratorChain
{
    [[<span class="keyword">self</span> getEcoratorRelishChain] addDecoratorRelish:<span class="keyword">self</span>];
}

@<span class="keyword">end</span></code></pre>
<hr>
<h2>三: 调料盒 DecoratorChain</h2>
<p>DecoratorChain.h</p>
<pre><code><span class="comment">//用于保存配料的chain</span>
@<span class="class"><span class="keyword">interface</span>  <span class="title">DecoratorChain</span>: <span class="title">NSMutableArray</span>
-(<span class="title">void</span>)<span class="title">addDecoratorRelish</span>:(<span class="title">EcoratorRelish</span>*)<span class="title">ecoratorRelish</span>;
@<span class="title">end</span></code></pre>
<p>DecoratorChain.m</p>
<pre><code>@<span class="class"><span class="keyword">interface</span> <span class="id">DecoratorChain</span>()</span>
@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) NSDecimalNumber * _countPrice;
@<span class="keyword">end</span>

@<span class="class"><span class="keyword">implementation</span> <span class="id">DecoratorChain</span></span>
@<span class="keyword">synthesize</span> _countPrice;

- (<span class="keyword">id</span>)init
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        _countPrice = [[NSDecimalNumber alloc]init];
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}

-(<span class="keyword">void</span>)addDecoratorRelish:(EcoratorRelish*)ecoratorRelish
{
    [<span class="keyword">self</span> addObject:ecoratorRelish];
}

<span class="comment">//得到当前所有chain 里面的总价</span>
-(NSDecimalNumber*)getCountPrice
{
    <span class="keyword">for</span> (EcoratorRelish *tmp  in <span class="keyword">self</span> ) {
        [_countPrice decimalNumberByAdding:tmp<span class="variable">.price</span>];
    }
    <span class="keyword">return</span> _countPrice;
}

@<span class="keyword">end</span></code></pre>
<p>下面的实现代码大家应该都会写了吧. 其实回头看下 中间应用到的设计模式 最明显的是 装饰 和 组合 策略</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[What is the difference between Category and Class Extension?]]></title>
    <link href="http://hufeng825.github.com/2013/09/15/ios24/"/>
    <id>http://hufeng825.github.com/2013/09/15/ios24/</id>
    <published>2013-09-15T05:39:07.000Z</published>
    <updated>2013-09-15T06:21:06.000Z</updated>
    <content type="html"><![CDATA[<p>细心的人会发现当我们new 一个文件的时候会发现下图的部分.</p>
<img src="http://ww4.sinaimg.cn/mw690/a43af4ffjw1e8n5s8yocrj20km0e1766.jpg" width="400" height="300">

<p>但是这个问题来了Category 和 Extension 就近又什么区别呢?<br><a id="more"></a></p>
<h2>1:什么是Category?</h2>
<p>实现这样一种场景,当我们用我们用NSArray的时候经常会遇到要去重的操作,可是自带的NSArray并没有这个方法,想要用你第一印象是自己写个类继承他,OC 给我们提供了一个方法可以直接在原有的基础上进行扩展.这就Category.分类能够做到的事情主要是：即使在你不知道一个类的源码情况下，向这个类添加扩展的方法。一个类可以有n+个分类,这些分类的实现可以在不同的文件中.</p>
<p>下面是我写的一个分类</p>
<p>NSArray+Unique.h</p>
<pre><code>@<span class="class"><span class="keyword">interface</span> <span class="title">NSArray</span> (<span class="title">Unique</span>)
- (<span class="title">NSArray</span> *) <span class="title">uniqueMembers</span>;
- (<span class="title">NSArray</span> *) <span class="title">unionWithArray</span>: (<span class="title">NSArray</span> *) <span class="title">array</span>;
@<span class="title">end</span></code></pre>
<p>NSArray+Unique.m</p>
<pre><code>@<span class="class"><span class="keyword">implementation</span> <span class="id">NSArray</span> (<span class="id">Unique</span>)</span>
- (<span class="built_in">NSArray</span> *) uniqueMembers
{
    <span class="built_in">NSMutableArray</span> *copy = [<span class="keyword">self</span> mutableCopy];
    <span class="keyword">for</span> (<span class="keyword">id</span> object in <span class="keyword">self</span>)
    {
        [copy removeObjectIdenticalTo:object];
        [copy addObject:object];
    }
    <span class="keyword">return</span> [copy autorelease];
}

- (<span class="built_in">NSArray</span> *) unionWithArray: (<span class="built_in">NSArray</span> *) anArray
{
    <span class="keyword">if</span> (!anArray) <span class="keyword">return</span> <span class="keyword">self</span>;
    <span class="keyword">return</span> [[<span class="keyword">self</span> arrayByAddingObjectsFromArray:anArray] uniqueMembers];
}

@<span class="keyword">end</span></code></pre>
<p>是不是很简单.但是应用Category还有如下</p>
<h3>需要注意的问题：</h3>
<ol>
<li><p>Category可以访问原始类的实例变量，但不能添加实例变量，如果想添加变量，那就通过继承创建子类来实现。  </p>
</li>
<li><p>Category的优先级要高,当类中的方法跟原使类中的方法重名的时候是会重载原始类的方法. </p>
</li>
<li><p>和普通接口有所区别的是，在Category的实现文件中的实例方法只要你不去调用它你可以不用实现所有声明的所有方法。</p>
</li>
<li><p>不要在Category 调用 Super方法</p>
</li>
</ol>
<h2>2:什么是 Extension</h2>
<p> 扩展(Extension)人们往往以为就是匿名分类,因为他的语法看起来很像</p>
<p>下面是一个Extension</p>
<pre><code>@<span class="class"><span class="keyword">interface</span> <span class="id">ExtensionClass</span> : <span class="id">NSObject</span>  </span>
@<span class="keyword">property</span> (retain, <span class="keyword">readonly</span>) <span class="keyword">float</span> value;
@<span class="keyword">end</span>  


@<span class="class"><span class="keyword">interface</span> <span class="id">ExtensionClass</span> () {</span> <span class="comment">//注意此处：扩展  </span>

}  
@<span class="keyword">property</span> (retain, readwrite) <span class="keyword">float</span> value; 
- (<span class="keyword">void</span>)setValue:(<span class="keyword">float</span>)newValue;  
@<span class="keyword">end</span>  

@<span class="class"><span class="keyword">implementation</span> <span class="id">ExtensionClass</span>  </span>

- (<span class="keyword">float</span>)value {  
    <span class="keyword">return</span> value;  
}  

- (<span class="keyword">void</span>)setValue:(<span class="keyword">float</span>)newValue {  
    value = newValue;  
}  

@<span class="keyword">end</span> </code></pre>
<p><strong>虽然它们的语法的确很相似。虽然都可以用来为一个现有的类添加方法和属性，但它们的目的和行为却是不同的。</strong></p>
<h2>Class extensions注意事项:</h2>
<ol>
<li><p>可以定义属性(实例变量)</p>
</li>
<li><p>在公共接口(类的声明中)中,开发者可以声明一个属性(实例变量)是只读的,随后在类扩展中声明为可写。这样，对外部代码而言,该属性(实例变量)将是只读的,而内部代码却可以使用它setter方法。</p>
</li>
<li><p>分类必须在第一个@interface中声明方法，并且在@implementation中提供实现，不然运行时出错。而类扩展的声明可以不在第一个@interface中去声明</p>
</li>
</ol>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ios笔记-- 多线程应该知道的那几件事 GCD NSThread NSOperation]]></title>
    <link href="http://hufeng825.github.com/2013/09/14/ios23/"/>
    <id>http://hufeng825.github.com/2013/09/14/ios23/</id>
    <published>2013-09-14T05:58:20.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>iphone5s 出来了，CPU 升级到了64位 可以应用到更大的内存了，同时对多线程的处理吞吐能力也教之前提升了十几倍。下面着中总结下ios 下多线程的知识点<br><a id="more"></a></p>
</blockquote>
<img src="http://image.techweb.com.cn/edit/2013/0911/37841378870639.jpg" class="left" width="400" height="200">



<h2>1：现有的几种多线程</h2>
<table>
<thead>
<tr>
<th>概念</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td> NSThread</td>
<td>苹果公司的Cocoa框架共支持三种多线程机制，分别为NSThread、GCD（Grand Central Dispatch）、Cocoa NSOperatio。NSThree是官方推荐的线程处理方式，它在处理机制上，需要开发者负责手动管理Thread的生命周期，包括子线程与主线程之间的同步等。线程共享同一应用程序的部分内存空间，它们拥有对数据相同的访问权限。你得协调多个线程 对同一数据的访问，一般做法是在访问之前加锁，这会导致一定的性能开销。在 iOS 中我们可以使用多种形式的 thread。 比其他两个轻量级 需要自己管理线程的生命周期，线程同步。 线程同步对数据的加锁会有一定的系统开销</td>
</tr>
<tr>
<td> NSOperation</td>
<td>如果需要让线程同时并行运行多个，可以将线程加入队列（Queue）中，NSOperationQueue类就是一个线程队列管理类，他提供了线程并行、队列的管理。可以认为NSOperationQueue就是一个线程管理器，通过addOperations方法，我们可以一次性把多个（数组形式）线程添加到队列中。同时，NSOperationQueue允许通过setMaxConcurrentOperationCount方法设置队列的并行（同一时间）运行数量  </td>
</tr>
<tr>
<td> GCD</td>
<td>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。该方法在Mac OS X 10.6雪豹中首次推出，并随后被引入到了iOS4.0中。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术，它看起来象就其它语言的闭包(Closure)一样，但苹果把它叫做blocks。</td>
</tr>
</tbody>
</table>
<p>一般移动平台上系统都会有一个专门的检查机制，看程序有没有很长时间被阻塞住，没有回来检查主消息队列。发现这种情况一般都是把程 序作为“无响应”干掉。iOS一般情况下是10秒为上限。10秒内程序没有回到主消息循环就被干掉。在前台后台切换时更严格，大概是5秒左右。<a href="http://www.cnblogs.com/linyawen/archive/2012/07/24/2606709.html" target="_blank">注释1</a></p>
<h2>2:简单的Demo</h2>
<p>因为GCD 是应用最广的 而且也是苹果现在极力鼓动开发者应用的 所以NSThread NSOperation 只做简单应用</p>
<h3>1:NSThread</h3>
<h3>1.1 NSThread 有两种直接创建方式：</h3>
<p>第一个是实例方法—直接创建线程并且开始运行线程</p>
<ul>
<li>(id)initWithTarget:(id)target selector:(SEL)selector object:(id)</li>
</ul>
<p>第二个是类方法—先创建线程对象，然后再运行线程操作，在运行线程操作前可以设置线程的优先级等线程信息</p>
<ul>
<li>(void)detachNewThreadSelector:(SEL)aSelector toTarget:(id)aTarget withObject:(id)anArgument</li>
</ul>
<p><em>selector</em> :线程执行的方法，这个selector只能有一个参数，而且不能有返回值。<br><em>target</em>  :selector消息发送的对象<br><em>argument</em> :传输给target的唯一参数，也可以是nil    </p>
<h3>1.2线程间通信</h3>
<p>a 在应用程序主线程中做事情： </p>
<figure class="highlight"><pre><span class="method">performSelectorOnMainThread:</span><span class="method">withObject:</span><span class="method">waitUntilDone:</span> <span class="method">performSelectorOnMainThread:</span><span class="method">withObject:</span><span class="method">waitUntilDone:</span><span class="method">modes:</span>
</pre></figure>

<p>b 在指定线程中做事情：</p>
<figure class="highlight"><pre><span class="method">performSelector:</span><span class="method">onThread:</span><span class="method">withObject:</span><span class="method">waitUntilDone:</span> <span class="method">performSelector:</span><span class="method">onThread:</span><span class="method">withObject:</span><span class="method">waitUntilDone:</span><span class="method">modes:</span>
</pre></figure>

<p>c 在当前线程中做事情：</p>
<figure class="highlight"><pre><span class="method">performSelector:</span><span class="method">withObject:</span><span class="method">afterDelay:</span>
<span class="method">performSelector:</span><span class="method">withObject:</span><span class="method">afterDelay:</span><span class="method">inModes:</span>
</pre></figure>

<p>d 取消发送给当前线程的某个消息</p>
<figure class="highlight"><pre><span class="method">cancelPreviousPerformRequestsWithTarget:</span> 
<span class="method">cancelPreviousPerformRequestsWithTarget:</span><span class="method">selector:</span><span class="method">object:</span>
</pre></figure>

<h3>2:NSOperation</h3>
<p>首先是建立NSOperationQueue和NSOperations。NSOperationQueue会建立一个线程管理器，每个加入到线程operation会有序的执行。  </p>
<figure class="highlight"><pre>
NSOperationQueue *queue = [NSOperationQueue new];
NSInvocationOperation *operation = <span class="string">[[NSInvocationOperation alloc] initWithTarget:self selector:@selector(doWork:) object:someObject]; 
[queue addObject:operation]; 
[operation release];
</pre></figure>

<p>使用NSOperationQueue的过程：<br>    1.  建立一个NSOperationQueue的对象<br>    2.  建立一个NSOperation的对象<br>    3.  将operation加入到NSOperationQueue中<br>    4.  release掉operation  </p>
<p>NSInvocationOperation，NSInvocationOperation是NSOperation的子类，允许运行在operation中的targer和selector</p>
<h3>3：多线程互斥同步问题</h3>
<p><a href="http://www.cnblogs.com/Quains/archive/2013/07/10/3182823.html" target="_blank">注释2</a></p>
<p>在iOS中有几种方法来解决多线程访问同一个内存地址的互斥同步问题：</p>
<ul>
<li>方法一，@synchronized(id anObject),(最简单的方法)<br>会自动对参数对象加锁，保证临界区内的代码线程安全</li>
</ul>
<figure class="highlight"><pre>@<span class="keyword">synchronized</span>(<span class="keyword">self</span>) {
        <span class="comment">// 这段代码对其他 @synchronized(self) 都是互斥的</span>
        <span class="comment">// self 指向同一个对象</span>
}
</pre></figure>

<ul>
<li>方法二，NSLock</li>
</ul>
<p>NSLock对象实现了NSLocking protocol，包含几个方法：<br>lock，加锁<br>unlock，解锁<br>tryLock，尝试加锁，如果失败了，并不会阻塞线程，只是立即返回NO<br>lockBeforeDate:，在指定的date之前暂时阻塞线程（如果没有获取锁的话），如果到期还没有获取锁，则线程被唤醒，函数立即返回NO<br>比如<br>：<br>    NSLock *theLock = [[NSLock alloc] init]; </p>
<pre><code>if ([the<span class="operator"><span class="keyword">Lock</span> <span class="keyword">lock</span>]) {

//<span class="keyword">do</span> something here

[theLock unlock];</span> 

} </code></pre>
<ul>
<li>方法三，NSRecursiveLock，递归锁</li>
</ul>
<p>NSRecursiveLock，多次调用不会阻塞已获取该锁的线程。</p>
<pre><code>NSRecursiveLock *theLock = <span class="string">[[NSRecursiveLock alloc] init]; 
void MyRecursiveFunction(int value) { 
    [theLock lock]; 
    if (value != 0) { 
        –value; 
        MyRecursiveFunction(value); 
    }
    [theLock unlock]; 
} 
MyRecursiveFunction(5);</code></pre>
<ul>
<li>方法四，NSConditionLock，条件锁</li>
</ul>
<p>NSConditionLock，条件锁，可以设置条件</p>
<pre><code>//公共部分
id condLock = <span class="string">[[NSConditionLock alloc] initWithCondition:NO_DATA]; 

//线程一，生产者
while(true) { 

[condLock lockWhenCondition:NO_DATA]; 

//生产数据
[condLock unlockWithCondition:HAS_DATA];

}

//线程二，消费者
while (true) { 

[condLock lockWhenCondition:HAS_DATA

//消费
[condLock unlockWithCondition:NO_DATA]; 
}</code></pre>
<ul>
<li>方法五，NSDistributedLock，分布锁</li>
</ul>
<p>NSDistributedLock，分布锁，文件方式实现，可以跨进程<br>用tryLock方法获取锁。<br>用unlock方法释放锁。<br>如果一个获取锁的进程在释放锁之前挂了，那么锁就一直得不到释放了，此时可以通过breakLock强行获取锁。</p>
<p><strong>本章节(多线程互斥同步问题)参考自:<a href="http://blog.sina.com.cn/s/blog_72819b170101590n.html" target="_blank">http://blog.sina.com.cn/s/blog_72819b170101590n.html</a></strong></p>
<h2>3:GCD多线程互斥同步问题(阻塞线程的方式去实现同步)</h2>
<p><a href="http://blog.devtang.com/blog/2012/02/22/use-gcd/" target="_blank">注释3</a></p>
<h3>1.串行队列</h3>
<p>(1)GCD下的dispatch_queue队列都是FIFO队列,都会按照提交到队列的顺序执行.<br>只是根据队列的性质,分为  </p>
<p><1>串行队列:用户队列、主线程队列 </p>
<p><2>并行队列. </p>
<p>(2)同步(dispatch_sync)、异步方式(dispatch_async). 配合串行队列和并行队列使用.<br>同步队列直接提交两个任务就可以.<br>// 串形队列<br>    dispatch_queue_t serilQueue = dispatch_queue_create(“com.quains.myQueue”, 0);</p>
<pre><code><span class="comment">//开始时间</span>
<span class="built_in">NSDate</span> *startTime = [<span class="built_in">NSDate</span> date];


__block <span class="built_in">UIImage</span> *image = <span class="literal">nil</span>;

<span class="comment">//1.先去网上下载图片</span>
<span class="built_in">dispatch_async</span>(serilQueue, ^{
   <span class="comment">//下载图片</span>
});

<span class="comment">//2.在主线程展示到界面里</span>
<span class="built_in">dispatch_async</span>(serilQueue, ^{

    <span class="built_in">NSLog</span>(@<span class="string">"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);

    <span class="comment">// 在主线程展示</span>
    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
      <span class="comment">//显示图片</span>
});

<span class="comment">//3.清理</span>
dispatch_release(serilQueue);
[image release];</code></pre>
<p><strong>注意:</strong></p>
<p>(1) __block变量分配在栈,retain下,防止被回收. </p>
<p>(2)dispatch要手动create和release. </p>
<p>(3)提交到主线程队列的时候,慎用同步dispatch_sync方法,有可能造成死锁.  因为主线程队列是串行队列,要等队列里的任务一个一个执行.所以提交一个任务到队列,如果用同步方法就会阻塞住主线程,而主线程又要等主线程队列里的任务都执行完才能执行那个刚提交的,所以主线程队列里还有其他的任务的话,但他已经被阻塞住了,没法先完成队列里的其他任务,即,最后一个任务也没机会执行到,于是造成死锁.</p>
<p>(4)提交到串行队列可以用同步方式,也可以用异步方式. </p>
<h3>2.并行队列</h3>
<p>采用并行队列的时候,可以采用同步的方式把任务提交到队列里去,即可以实现同步的方式</p>
<p>//新建一个队列<br>    dispatch_queue_t concurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>
<pre><code><span class="comment">//记时</span>
<span class="built_in">NSDate</span> *startTime = [<span class="built_in">NSDate</span> date];

<span class="comment">//加入队列</span>
<span class="built_in">dispatch_async</span>(concurrentQueue, ^{
    __block <span class="built_in">UIImage</span> *image = <span class="literal">nil</span>;

    <span class="comment">//1.先去网上下载图片</span>
    <span class="built_in">dispatch_sync</span>(concurrentQueue, ^{
        <span class="comment">//下载图片</span>
    });

    <span class="comment">//2.在主线程展示到界面里</span>
    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^{
        <span class="comment">//显示图片</span>
    });
});</code></pre>
<p>两个同步的任务用一个异步的包起来,提交到并行队列里去,即可实现同步的方式.</p>
<h3>3.使用分组方式</h3>
<p>group本身是将几个有关联的任务组合起来,然后提供给开发者一个知道这个group结束的点.<br>虽然这个只有一个任务,但是可以利用group的结束点,去阻塞线程,从而来实现同步方式.</p>
<p>例如让后台2个线程并行执行，然后等2个线程都结束后，再汇总执行结果。这个可以用dispatch_group, dispatch_group_async 和 dispatch_group_notify来实现，示例如下：</p>
<figure class="highlight"><pre> dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();
 dispatch_group_async(<span class="keyword">group</span>, dispatch_get_global_queue(<span class="number">0</span>,<span class="number">0</span>), ^{
      <span class="comment">// 并行执行的线程一</span>
 });
 dispatch_group_async(<span class="keyword">group</span>, dispatch_get_global_queue(<span class="number">0</span>,<span class="number">0</span>), ^{
      <span class="comment">// 并行执行的线程二</span>
 });
 dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_global_queue(<span class="number">0</span>,<span class="number">0</span>), ^{
      <span class="comment">// 汇总结果</span>
 });
</pre></figure>

<pre><code>dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();

dispatch_queue_t queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);

NSDate <span class="variable">*startTime</span> = [NSDate <span class="keyword">date</span>];

__block UIImage <span class="variable">*image</span> = nil;

dispatch_group_async(<span class="keyword">group</span>, queue, ^{
    <span class="comment">//1.先去网上下载图片</span>
    });

<span class="comment">// 2.等下载好了再在刷新主线程</span>
dispatch_group_notify(<span class="keyword">group</span>, queue, ^{

    <span class="comment">//在主线程展示到界面里</span>
    dispatch_async(dispatch_get_main_queue(), ^{
     <span class="comment">//显示图片</span>
    });

});

<span class="comment">// 释放掉</span>
dispatch_release(<span class="keyword">group</span>);</code></pre>
<p>dispatch_group 也要手动创建和释放.<br>dispatch_notify()提供了一个知道group什么时候结束的点. 当然也可以使用dispatch_wait()去阻塞</p>
<h3>4.信号量</h3>
<p>信号量 和 琐 的作用差不多,可以用来实现同步的方式.<br>但是信号量通常用在 允许几个线程同时访问一个资源,通过信号量来控制访问的线程个数.</p>
<p>// 信号量初始化为1<br>    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</p>
<pre><code><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);

<span class="built_in">NSDate</span> *startTime = [<span class="built_in">NSDate</span> date];

__block <span class="built_in">UIImage</span> *image = <span class="literal">nil</span>;


<span class="comment">//1.先去网上下载图片</span>
<span class="built_in">dispatch_async</span>(queue, ^{

    <span class="comment">// wait操作-1</span>
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    <span class="comment">// 开始下载</span>
    <span class="comment">// signal操作+1</span>
    dispatch_semaphore_signal(semaphore);
});


<span class="comment">// 2.等下载好了再在刷新主线程</span>
<span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{

    <span class="comment">// wait操作-1</span>
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    <span class="comment">//显示图片</span>
    <span class="comment">// signal操作+1</span>
    dispatch_semaphore_signal(semaphore);
});</code></pre>
<p>dispatch_wait会阻塞线程并且检测信号量的值,直到信号量值大于0才会开始往下执行,同时对信号量执行-1操作.<br>dispatch_signal则是+1操作.</p>
<h3>3.后台运行</h3>
<p>GCD的另一个用处是可以让程序在后台较长久的运行。在没有使用GCD时，当app被按home键退出后，app仅有最多5秒钟的时候做一些保存或清理资源的工作。但是在使用GCD后，app最多有10分钟的时间在后台长久运行。这个时间可以用来做清理本地缓存，发送统计数据等工作。</p>
<p>让程序在后台长久运行的示例代码如下：</p>
<figure class="highlight"><pre><span class="comment">// AppDelegate.h文件</span>
@<span class="keyword">property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) UIBackgroundTaskIdentifier backgroundUpdateTask;

<span class="comment">// AppDelegate.m文件</span>
- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application
{
    [<span class="keyword">self</span> beingBackgroundUpdateTask];
    <span class="comment">// 在这里加上你需要长久运行的代码</span>
    [<span class="keyword">self</span> endBackgroundUpdateTask];
}

- (<span class="keyword">void</span>)beingBackgroundUpdateTask
{
    <span class="keyword">self</span><span class="variable">.backgroundUpdateTask</span> = [[<span class="built_in">UIApplication</span> sharedApplication] beginBackgroundTaskWithExpirationHandler:^{
        [<span class="keyword">self</span> endBackgroundUpdateTask];
    }];
}

- (<span class="keyword">void</span>)endBackgroundUpdateTask
{
    [[<span class="built_in">UIApplication</span> sharedApplication] endBackgroundTask: <span class="keyword">self</span><span class="variable">.backgroundUpdateTask</span>];
    <span class="keyword">self</span><span class="variable">.backgroundUpdateTask</span> = UIBackgroundTaskInvalid;
}
</pre></figure>

<hr>
<p>[1] <a href="http://www.cnblogs.com/linyawen/archive/2012/07/24/2606709.html" target="_blank">http://www.cnblogs.com/linyawen/archive/2012/07/24/2606709.html</a></p>
<p>[2] <a href="http://www.cnblogs.com/Quains/archive/2013/07/10/3182823.html" target="_blank">http://www.cnblogs.com/Quains/archive/2013/07/10/3182823.html</a></p>
<p>[3] <a href="http://blog.devtang.com/blog/2012/02/22/use-gcd/" target="_blank">http://blog.devtang.com/blog/2012/02/22/use-gcd/</a></p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ios笔记--block应该知道的那几件事]]></title>
    <link href="http://hufeng825.github.com/2013/09/11/ios22/"/>
    <id>http://hufeng825.github.com/2013/09/11/ios22/</id>
    <published>2013-09-11T15:32:18.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<p>block 现在已经基本上已经使用非常普遍了,在引用中也又很多坑,下面把block开发中应该知道的那几件事总结下.<br><a id="more"></a></p>
<h2>:内联(inline)Block</h2>
<blockquote>
<p>内联block 说白了就是block被嵌入到一个函数中<br>例如:</p>
</blockquote>
<p><strong>typedef void (^HelloBlock)(void);</strong></p>
<figure class="highlight"><pre><span class="pp">- <span class="params">(void)</span> BlockTest{
HelloBlock myBlock= ^<span class="params">(void)</span>{
NSLog<span class="params">(@<span class="string">"Hello Block"</span>)</span>;
};
myBlock<span class="params">()</span>;
}
</pre></figure>

<h2>注意事项</h2>
<h3>1.内联的block中内部定义的变量 自己本身有读写权限</h3>
<h3>2.block内部要修改外部变量 需要将外部变量声明__block</h3>
<h3>3.Block retain是无效的，要想保留block生命周期，可以通过copy来实现，记得release</h3>
<h3>4.被block的应用的对象，retainCount会自动加一，为了打破这种 retain circle，可以在对象前加__block，这样block块就不会维护这个对象了</h3>
<p> 下面的写法如果不加上_block a无法dealloc</p>
<figure class="highlight"><pre>
__block A  a =[ <span class="string">[[A alloc] init] withBlock:^{

 [a action];

 [ a release];

}]; //这样A的dealloc方法就会调用
</pre></figure>

<figure class="highlight"><pre>
@<span class="class"><span class="keyword">interface</span> <span class="id">ViewController</span> ： <span class="id">UIViewViewController</span> </span>
 {
        <span class="built_in">NSString</span> *_string;
 }

 __block ViewController *controller = <span class="keyword">self</span>;   
    _block = ^{
         <span class="built_in">NSLog</span>(@<span class="string">"string %@"</span>,controller-&gt;_string);
    };
</pre></figure>

<h3>5.在独立的block中不能引用self，如果需要访问可以使用参数传递的方法(可以把其考虑成c+中参数传入函数指针对应copy)**</h3>
<h3>6.不要随便用.语法</h3>
<figure class="highlight"><pre><span class="preprocessor">#import &lt;UIKit/UIKit.h&gt;   </span>
@<span class="class"><span class="keyword">interface</span> <span class="title">AppDelegate</span> : <span class="title">NSObject</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;
@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">strong</span>) <span class="title">NSString</span> *<span class="title">stringProperty</span>;  
@<span class="title">end</span>
</pre></figure>

<figure class="highlight"><pre><span class="preprocessor">#import <span class="title">"GCDAppDelegate.h"</span> </span>
@<span class="class"><span class="keyword">implementation</span> <span class="id">AppDelegate</span> </span>
@<span class="keyword">synthesize</span> stringProperty;  
- (<span class="keyword">void</span>) BlockTestError{
HelloBlock myBlock= ^(<span class="keyword">void</span>){
	<span class="keyword">self</span><span class="variable">.stringProperty</span> = @<span class="string">"Block Objects"</span>; 
	<span class="built_in">NSLog</span>(@<span class="string">"String property = %@"</span>, <span class="keyword">self</span><span class="variable">.stringProperty</span>);<span class="comment">//运行错误</span>
};
myBlock();
}}  

- (<span class="keyword">void</span>) BlockTestCorrect{
	HelloBlock myBlock= ^(<span class="keyword">void</span>){
		[<span class="keyword">self</span> setStringProperty:@<span class="string">"Block Objects"</span>];
	    <span class="built_in">NSLog</span>(@<span class="string">"self.stringProperty = %@"</span>, [<span class="keyword">self</span> stringProperty]); <span class="comment">//运行ok</span>
	};
myBlock();
}}  
@<span class="keyword">end</span>
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[读 林锐博士的项目管理 笔记1]]></title>
    <link href="http://hufeng825.github.com/2013/09/09/project0/"/>
    <id>http://hufeng825.github.com/2013/09/09/project0/</id>
    <published>2013-09-09T08:07:57.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<h2>软件挣钱难的问题</h2>
<p><a id="more"></a></p>
<h3>一、承接合同项目，为甲方开发软件系统。</h3>
<ol>
<li><p>市场上能够承接到的合同项目，利润很小。而高利润的项目则被有权势的人或机构掌控。 </p>
</li>
<li><p>项目需求和验收受制于客户。开发过程中，客户会不断变更需求，导致开发方不断修改软件，项目验收被不断地延后，开发方成本（包括机会成本）越来越高。</p>
</li>
<li><p>缺乏规模复制效益。由于合同项目都是针对特定客户（甲方）的特定需求而签订的，即使做成功了一个合同项目，也很难“复制这个项目”直接卖给下一个客户。</p>
</li>
</ol>
<h3>二、开发并销售通用软件产品</h3>
<ol>
<li><p>凡是面向个人的通用软件产品，由于盗版原因，几乎无法靠卖软件来挣钱。</p>
</li>
<li><p>只有企业级软件产品不容易被大量盗版，可以走“通用软件产品盈利模式”，难度非常高。开发方必须把自己打造成为“企业级应用的领导者”，否则客户不信任你的方法和产品，产品就无法通用。于是客户提出的个性化需求越来越多，回到了“合同项目盈利模式”。 </p>
</li>
</ol>
<h3>三、运营模式</h3>
<ol>
<li><p>互联网公司的业务太容易被模仿，同质化竞争严重。每个领域都死掉了成千上万的相同业务的互联网公司，最终只有少数几家可以活下来，极大地浪费社会财富。</p>
</li>
<li><p>互联网公司的另一个大缺点是太浮躁，过分追求快而导致根基不扎实，国内绝大多数互联网公司的软件研发管理，要比传统软件公司混乱得多。</p>
</li>
</ol>
<hr>
<blockquote>
<p>软件企业要想多挣钱，靠“开源节流”。“开源”主要靠优化盈利模式，使得现有的技术和资源产生更高的效益。“节流”主要靠改进管理，使企业的所有经营环节更加合理，减少不必要的成本，省下来的钱也就成了利润</p>
</blockquote>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/项目管理/" term="项目管理"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[mac 下更新DNS 缓存]]></title>
    <link href="http://hufeng825.github.com/2013/09/03/mac4/"/>
    <id>http://hufeng825.github.com/2013/09/03/mac4/</id>
    <published>2013-09-03T09:14:30.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<p>开始的时候难免遇到修改host的时候，但是host后没有即刻生效，可使用终端命令手动清除DNS缓存：</p>
<figure class="highlight"><pre><span class="title">dscacheutil</span> -flushcache
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
    <category scheme="http://hufeng825.github.com/categories/ios/mac/" term="mac"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[判断地图坐标是否在区域内]]></title>
    <link href="http://hufeng825.github.com/2013/09/03/23/"/>
    <id>http://hufeng825.github.com/2013/09/03/23/</id>
    <published>2013-09-03T08:51:48.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>此方法与前一篇文章中的得到UIView某点的色值达到的效果一直，通常为了保持精度 两个方法一起使用。</p>
</blockquote>
<p><a id="more"></a></p>
<figure class="highlight"><pre>-(<span class="keyword">IBAction</span>)foundTap:(UITapGestureRecognizer *)recognizer
{
    <span class="built_in">CGPoint</span> point = [recognizer locationInView:<span class="keyword">self</span><span class="variable">.mapView</span>];

    CLLocationCoordinate2D tapPoint = [<span class="keyword">self</span><span class="variable">.mapView</span> convertPoint:point toCoordinateFromView:<span class="keyword">self</span><span class="variable">.view</span>];

    [<span class="keyword">self</span> pointInsideOverlay:tapPoint];

    <span class="keyword">if</span> (isInside) 
     {
       ....
     }
}
</pre></figure>

<p>Here is a method to call from the previous to check if the point is inside the overlay:</p>
<figure class="highlight"><pre>-(<span class="keyword">void</span>)pointInsideOverlay:(CLLocationCoordinate2D )tapPoint 
{
    isInside = <span class="literal">FALSE</span>; 

    MKPolygonView *polygonView = (MKPolygonView *)[mapView viewForOverlay:polygonOverlay];

    MKMapPoint mapPoint = MKMapPointForCoordinate(tapPoint);

    <span class="built_in">CGPoint</span> polygonViewPoint = [polygonView pointForMapPoint:mapPoint];

    <span class="built_in">BOOL</span> mapCoordinateIsInPolygon = CGPathContainsPoint(polygonView<span class="variable">.path</span>, <span class="literal">NULL</span>, polygonViewPoint, <span class="literal">NO</span>);

        <span class="keyword">if</span> ( !mapCoordinateIsInPolygon )

            <span class="comment">//we are finding points that are inside the overlay</span>
        {
            isInside = <span class="literal">TRUE</span>;
        }
}
</pre></figure>

<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e89eyhiwqbj20hs0qo769.jpg" class="center" width="300" height="600">
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[How to get the color of a pixel in an UIView?]]></title>
    <link href="http://hufeng825.github.com/2013/09/03/22/"/>
    <id>http://hufeng825.github.com/2013/09/03/22/</id>
    <published>2013-09-03T08:33:35.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<p>记得一年前做招行掌上生活M+的时候 其中有个需求是画一画功能，就是在地图上用手指画个圈 然后得到这个圈里面所有指定商户。<br>当时为了精度 除了利用 </p>
<figure class="highlight"><pre><span class="built_in">BOOL</span> mapCoordinateIsInPolygon = CGPathContainsPoint(polygonView<span class="variable">.path</span>, <span class="literal">NULL</span>, polygonViewPoint, <span class="literal">NO</span>);
</pre></figure>

<p>来验证此点是否在画的区域内 同时为了精度 还用到了点位的颜色色值进行校验。</p>
<p>无法把全部代码给出 下面把 如何得到uiview 某点的函数给出</p>
<p> UIView+ColorOfPoint.h</p>
<figure class="highlight"><pre>@<span class="class"><span class="keyword">interface</span> <span class="title">UIView</span> (<span class="title">ColorOfPoint</span>)
- (<span class="title">UIColor</span> *) <span class="title">colorOfPoint</span>:(<span class="title">CGPoint</span>)<span class="title">point</span>;
@<span class="title">end</span>
</pre></figure>

<p> UIView+ColorOfPoint.m</p>
<figure class="highlight"><pre><span class="preprocessor">#import <span class="title">"UIView+ColorOfPoint.h"</span></span>
<span class="preprocessor">#import <span class="title">&lt;QuartzCore/QuartzCore.h&gt;</span></span>

@<span class="class"><span class="keyword">implementation</span> <span class="id">UIView</span> (<span class="id">ColorOfPoint</span>)</span>

- (<span class="built_in">UIColor</span> *) colorOfPoint:(<span class="built_in">CGPoint</span>)point
{
    <span class="keyword">unsigned</span> <span class="keyword">char</span> pixel[<span class="number">4</span>] = {<span class="number">0</span>};
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(pixel, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, colorSpace, kCGImageAlphaPremultipliedLast);

    CGContextTranslateCTM(context, -point<span class="variable">.x</span>, -point<span class="variable">.y</span>);

    [<span class="keyword">self</span><span class="variable">.layer</span> renderInContext:context];

    CGContextRelease(context);
    CGColorSpaceRelease(colorSpace);

    <span class="comment">//NSLog(@"pixel: %d %d %d %d", pixel[0], pixel[1], pixel[2], pixel[3]);</span>

    <span class="built_in">UIColor</span> *color = [<span class="built_in">UIColor</span> colorWithRed:pixel[<span class="number">0</span>]/<span class="number">255.0</span> green:pixel[<span class="number">1</span>]/<span class="number">255.0</span> blue:pixel[<span class="number">2</span>]/<span class="number">255.0</span> alpha:pixel[<span class="number">3</span>]/<span class="number">255.0</span>];

    <span class="keyword">return</span> color;
}
</pre></figure>

<p>@end</p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e89eyhiwqbj20hs0qo769.jpg" class="center" width="300" height="600" title="模拟器">
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[svn命令总结]]></title>
    <link href="http://hufeng825.github.com/2013/09/03/svn9/"/>
    <id>http://hufeng825.github.com/2013/09/03/svn9/</id>
    <published>2013-09-03T06:08:30.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<h2>1. 创建分支</h2>
<p>svn cp <a href="http://svn.trunk/" target="_blank">http://svn.trunk/</a> <a href="http://svn.branches/" target="_blank">http://svn.branches/</a>  –m “create a branch”<br><a id="more"></a></p>
<h2>2. 合并分支</h2>
<h3>1、在某个branch里合并trunk上的修改，</h3>
<p>进入分支目录，然后执行：</p>
<figure class="highlight"><pre><span class="title">svn</span> merge <span class="url">http://svn/repo/trunk
</pre></figure>

<h3>2、在trunk上合并branch的修改。</h3>
<p>进入trunk目录，然后执行</p>
<figure class="highlight"><pre><span class="title">svn</span> merge --reintegrate <span class="url">http://svn/repo/branches/branch1
</pre></figure>

<h2>3. 将文件checkout到本地目录</h2>
<p>svn checkout path（path是服务器上的目录）</p>
<figure class="highlight"><pre>例如：svn checkout svn:<span class="regexp">//</span><span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span><span class="regexp">/pro/</span>domain
简写：svn co
</pre></figure>

<h2>4. 往版本库中添加新的文件</h2>
<p>svn add file</p>
<figure class="highlight"><pre>例如：svn addtest<span class="preprocessor">.php</span>(添加test<span class="preprocessor">.php</span>)
svn <span class="keyword">add</span> *<span class="preprocessor">.php</span>(添加当前目录下所有的php文件)
</pre></figure>

<h2>5. 将改动的文件提交到版本库</h2>
<p>svn commit -m “LogMessage“ [-N] [—no-unlock] PATH(如果选择了保持锁，就使用–no-unlock开关)</p>
<figure class="highlight"><pre>例如：svn <span class="operator"><span class="keyword">commit</span> -m “<span class="keyword">add</span> test file <span class="keyword">for</span> my test“ test.php
简写：svn ci
</pre></figure>

<h2>6. 加锁/解锁</h2>
<p>svn lock -m “LockMessage“ [—force] PATH</p>
<figure class="highlight"><pre>例如：svn <span class="operator"><span class="keyword">lock</span> -m “<span class="keyword">lock</span> test file“ test.php
svn unlock PATH
</pre></figure>

<h2>7. 更新到某个版本</h2>
<p>svn update -r m path</p>
<p>例如：</p>
<figure class="highlight"><pre>svn <span class="operator"><span class="keyword">update</span>如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。
svn <span class="keyword">update</span> -r <span class="number">200</span> test.php(将版本库中的文件test.php还原到版本<span class="number">200</span>)
svn <span class="keyword">update</span> test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先<span class="keyword">update</span>，修改文件，然后清除svn resolved，最后再提交<span class="keyword">commit</span>)
</pre></figure>

<p>简写：svn up</p>
<h2>8.查看文件或者目录状态</h2>
<ol>
<li>svn status path（目录下的文件和子目录的状态，正常状态不显示）</li>
</ol>
<p>【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】</p>
<ol>
<li>svn status -v path(显示文件和子目录状态)<br>第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。<br><strong>注：</strong> svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。<br>简写：svn st</li>
</ol>
<h2>9.删除文件</h2>
<p>svn delete path -m “delete test fle“</p>
<p>例如：</p>
<figure class="highlight"><pre>svn <span class="operator"><span class="keyword">delete</span> svn://<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>/pro/<span class="keyword">domain</span>/test.php -m “<span class="keyword">delete</span> test file”
或者直接svn <span class="keyword">delete</span> test.php 然后再svn ci -m ‘<span class="keyword">delete</span> test file‘，
</pre></figure>

<p>推荐使用这种简写：svn (del, remove, rm)</p>
<h2>10.查看日志</h2>
<p>svn log path<br>例如：</p>
<figure class="highlight"><pre><span class="title">svn</span> log test.php 显示这个文件的所有修改记录，及其版本号的变化
</pre></figure>

<h2>11.查看文件详细信息</h2>
<p>svn info path</p>
<p>例如：</p>
<figure class="highlight"><pre><span class="title">svn</span> <span class="built_in">info</span> test.php
</pre></figure>

<h2>12.比较差异</h2>
<p>svn diff path(将修改的文件与基础版本比较)</p>
<p>例如：</p>
<figure class="highlight"><pre><span class="title">svn</span> diff test.php
</pre></figure>

<p>svn diff -r m:n path(对版本m和版本n比较差异)</p>
<p>例如：</p>
<figure class="highlight"><pre><span class="title">svn</span> diff -r <span class="number">200</span>:<span class="number">201</span> test.php
</pre></figure>

<p>简写：svn di</p>
<h2>13.将两个版本之间的差异合并到当前文件</h2>
<p>svn merge -r m:n path<br>例如：</p>
<figure class="highlight"><pre><span class="title">svn</span> merge -r <span class="number">200</span>:<span class="number">205</span> test.php（将版本<span class="number">200</span>与<span class="number">205</span>之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下）
</pre></figure>

<h2>14.SVN 帮助</h2>
<p>svn help<br>svn help ci  </p>
<h2>15.版本库下的文件和目录列表</h2>
<p>svn list path<br>显示path目录下的所有属于版本库的文件和目录<br>简写：svn ls</p>
<h2>16.创建纳入版本控制下的新目录</h2>
<p>svn mkdir: 创建纳入版本控制下的新目录。</p>
<p>用法: </p>
<ol>
<li>mkdir PATH…</li>
<li>mkdir URL…</li>
</ol>
<p>创建版本控制的目录。</p>
<ol>
<li>每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增调度，以待下一次的提交。</li>
<li>每个以URL指定的目录，都会透过立即提交于仓库中创建。在这两个情况下，所有的中间目录都必须事先存在。</li>
</ol>
<h2>17.恢复本地修改</h2>
<p>svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert:<br>用法: revert PATH…<br>注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录</p>
<h2>18.代码库URL变更</h2>
<p>svn switch (sw): 更新工作副本至不同的URL。</p>
<p>用法: </p>
<ol>
<li>switch URL [PATH]</li>
<li><p>switch –relocate FROM TO [PATH…]</p>
<ul>
<li><p>更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的方法。</p>
</li>
<li><p>改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动(比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用这个命令更新工作副本与仓库的对应关系。</p>
</li>
</ul>
</li>
</ol>
<h2>19.解决冲突</h2>
<p>svn resolved: 移除工作副本的目录或文件的“冲突”状态。 </p>
<p>用法: resolved PATH…</p>
<p><strong>注意:</strong> 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的<br>相关文件，然后让 PATH 可以再次提交。</p>
<h2>20.输出指定文件或URL的内容。</h2>
<p>svn cat 目标[@版本]…如果指定了版本，将从指定的版本开始查找。  </p>
<p>svn cat -r PREV filename &gt; filename (PREV 是上一版本,也可以写具体版本号,这样输出结果是可以提交的)</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/svn/" term="svn"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[svn错误local add incoming add upon merge]]></title>
    <link href="http://hufeng825.github.com/2013/09/03/svn8/"/>
    <id>http://hufeng825.github.com/2013/09/03/svn8/</id>
    <published>2013-09-03T06:06:15.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<p>在svn命令行merge之后文件经常会出现local add, incoming add upon merge问题，导致无法提交，可以通过以下命令解决冲突<br>Summarizing to resolve the tree conflict committing your working dir with svn client 1.6.x you can use:<br><a id="more"></a></p>
<figure class="highlight"><pre><span class="comment">svn</span> <span class="comment">resolve</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">accept</span> <span class="comment">working</span> <span class="literal">-</span><span class="comment">R</span> <span class="string">.</span>
</pre></figure>

<p>where . is the directory in conflict.</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/svn/" term="svn"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[svn 打 tag]]></title>
    <link href="http://hufeng825.github.com/2013/09/03/svn7/"/>
    <id>http://hufeng825.github.com/2013/09/03/svn7/</id>
    <published>2013-09-03T06:04:29.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight"><pre>svn cp . <span class="symbol">http:</span>/<span class="regexp">/svnserver/svn</span><span class="regexp">/pingan/client</span><span class="regexp">/iPhone2/tags</span><span class="regexp">/appstore_v1.010_rc01  -m "1.010"
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/svn/" term="svn"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[svn 回退版本]]></title>
    <link href="http://hufeng825.github.com/2013/09/03/svn6/"/>
    <id>http://hufeng825.github.com/2013/09/03/svn6/</id>
    <published>2013-09-03T06:02:35.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight"><pre>svn merge -r <span class="symbol">rHEAD:</span><span class="number">4367</span> <span class="symbol">http:</span>/<span class="regexp">/svnserver/svn</span><span class="regexp">/pingan/client</span><span class="regexp">/iPhone2/trunk</span><span class="regexp">/
</pre></figure>

<p>本地回退</p>
<figure class="highlight"><pre><span class="title">svn</span> ci -m <span class="string">"提交"</span>
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/svn/" term="svn"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[svn  临时 切换用户 命令]]></title>
    <link href="http://hufeng825.github.com/2013/09/03/svn5/"/>
    <id>http://hufeng825.github.com/2013/09/03/svn5/</id>
    <published>2013-09-03T05:56:11.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<p>作为team leader  有时候需要帮别人解决技术问题，尝尝再别人的电脑上改了某些代码，提交的时候遇到了问题，就是怎样临时用自己的账户提交，提交完后 用不影响同事的电脑原有的svn账号<br><a id="more"></a></p>
<p>下面的可以解决这个问题</p>
<p>在所有命令下强制加上—username 和—password选项。 </p>
<p>例如：</p>
<p>l<figure class="highlight"><pre><span class="comment">svn</span> <span class="comment">ci</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">username</span> <span class="comment">hufeng</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">password</span> <span class="comment">####
</pre></figure></p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/svn/" term="svn"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[svn 版本恢复命令行操作（转）]]></title>
    <link href="http://hufeng825.github.com/2013/09/03/svn4/"/>
    <id>http://hufeng825.github.com/2013/09/03/svn4/</id>
    <published>2013-09-03T05:51:18.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<p>svn没有恢复旧版本的直接功能，不过可以使用svn merge命令恢复。<br>比如说当前HEAD为14，而我要恢复成10版本，怎么做？用svn merge：<br><a id="more"></a></p>
<figure class="highlight"><pre><span class="title">svn</span> update
<span class="title">svn</span> merge <span class="comment">--revision 14:10</span>
<span class="title">svn</span> commit -m <span class="string">"restore to revision 10"</span>
</pre></figure>

<p>可能会很奇怪，因为不理解为什么合并能恢复旧版本。</p>
<p>这里要理解一个关键点，就是svn merge的原理。merge是比较指定版本的差异，然后把这些差异应用到本地工作副本，而-r后的14:10，是指相对于版本14来说版本10的变化（注意，这个版本的次序很重要。），也就是相对版本14，我版本10添加了哪些文件或目录，以及哪些文件添加了哪些行删除了哪些行。</p>
<p>由于在客户端提交应用程序时的误操作，导致修改了基线版本，此处利用两个命令来进行恢复：</p>
<ol>
<li>将客户端恢复合并到指定版本：</li>
</ol>
<figure class="highlight"><pre><span class="title">svn</span> merge -r <span class="number">112</span>:<span class="number">111</span> <span class="url">svn://192.168.0.119/UBoot/trunk/u-boot-1.3.3
</pre></figure>

<p>此步骤将下位机由112恢复到111版本：</p>
<ol>
<li>重新修订基线版本</li>
</ol>
<figure class="highlight"><pre>svn <span class="operator"><span class="keyword">commit</span> -m <span class="string">"Undoing change committed in r111."</span>
</pre></figure>

<p>此步骤将恢复后的111版本提交，但是此时的版本号为113</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/svn/" term="svn"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[svn错误：SVN remains in conflict?]]></title>
    <link href="http://hufeng825.github.com/2013/09/03/svn3/"/>
    <id>http://hufeng825.github.com/2013/09/03/svn3/</id>
    <published>2013-09-03T05:49:56.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<p>解决如下:</p>
<figure class="highlight"><pre><span class="comment">svn</span> <span class="comment">remove</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">force</span> <span class="comment">yourfilename</span>
<span class="comment">svn</span> <span class="comment">resolve</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">accept=working</span>  <span class="comment">yourfilename</span>
<span class="comment">svn</span> <span class="comment">commit</span> <span class="literal">-</span><span class="comment">m</span> <span class="comment">""
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/svn/" term="svn"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[mac 开发 git svn 应该添加那些忽略列表]]></title>
    <link href="http://hufeng825.github.com/2013/09/03/git13/"/>
    <id>http://hufeng825.github.com/2013/09/03/git13/</id>
    <published>2013-09-03T05:45:11.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>如题，git svn 应该添加那些忽略列表?<br><a id="more"></a></p>
</blockquote>
<ol>
<li>.DS_Store</li>
<li>build</li>
<li>*~.nib</li>
<li>*.so</li>
<li>*.pbxuser</li>
<li>*.mode</li>
<li><em>.perspective</em></li>
</ol>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/git/" term="git"/>
    <category scheme="http://hufeng825.github.com/categories/git/svn/" term="svn"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[git错误 git rebase master First, rewinding head to replay your work on top of it... error: The following unt]]></title>
    <link href="http://hufeng825.github.com/2013/09/03/git12/"/>
    <id>http://hufeng825.github.com/2013/09/03/git12/</id>
    <published>2013-09-03T05:39:50.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<p>git rebase master<br>First, rewinding head to replay your work on top of it…<br>error: The following untracked working tree files would be overwritten by checkout:<br><a id="more"></a><br>HFFrame.xcodeproj/project.xcworkspace/xcuserdata/apple.xcuserdatad/UserInterfaceState.xcuserstate<br>Please move or remove them before you can switch branches.<br>Aborting<br>could not detach HEAD</p>
<p>执行</p>
<figure class="highlight"><pre><span class="comment">~/Desktop/HFFrame(example)</span> <span class="comment">$</span> <span class="comment">git</span> <span class="comment">clean</span> <span class="literal">-</span><span class="comment">d</span> <span class="literal">-</span><span class="comment">fx</span> <span class="comment">""
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/git/" term="git"/>
  </entry>
</feed>
