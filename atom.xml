<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[阿峰的技术窝窝]]></title>
  <subtitle><![CDATA[专注于移动互联网]]></subtitle>
  <link href="http://hufeng825.github.com/atom.xml" rel="self"/>
  <link href="http://hufeng825.github.com"/>
  <updated>2014-01-14T05:35:19.830Z</updated>
  <id>http://hufeng825.github.com/</id>
  <author>
    <name><![CDATA[Jason Hu]]></name>
    <email><![CDATA[hufeng@hufengvip.cn]]></email>
  </author>
  <generator uri="http://zespia.tw/hexo">Hexo</generator>
  <entry>
    <title type="html"><![CDATA[ios系列教程之用instruments来检验你的app]]></title>
    <link href="http://hufeng825.github.com/2014/01/13/ios35/"/>
    <id>http://hufeng825.github.com/2014/01/13/ios35/</id>
    <published>2014-01-13T13:44:58.000Z</published>
    <updated>2014-01-14T05:35:10.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>比较了好多关于instruments 还是发现老外写的比较牛逼.于是果断翻译过来.有能力的的可以去看英文原版,鼓励大家看原版资料远离二手教程
<a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode" target="_blank">http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode</a></p>
</blockquote>
<h2 id="-">入门</h2>
<p>为了节省大家的时间,提供一个演示的Demo给大家.<a href="http://cdn4.raywenderlich.com/downloads/InstrumentsTutorial.zip" target="_blank">代码传送门</a>.
下载后解压然后用xcode打开.
编译运行APP后 然后在搜索框内输入任意词汇,点击结果你会看到下面的结果   </p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1eci9qbiaq7j208v0da3zj.jpg" class="center">


<p><a id="more"></a>
正如你所见的,这个app很简单.程序其实调用的是Flickr的API,通过app顶部的搜索框执行搜索后在下面的tableview显示你搜索的搜索词,搜索词后面的括号内有搜索结果的个数,点击此行进入一个略所图的结果列表页面 如上图. 点击其中一行 进入图像的大图模式,在这个页面你可以根据需要旋转图像.
到目前为止页面看起来差不多了,你也许会想应该可以直接提交appstore了吧.接下来这篇文章将会教你instruments工具来提高你app性能和稳定性.</p>
<h2 id="-">&quot;时间探测器&quot;</h2>
<p>天下武功，唯快不破。很多公司都信奉这个教条.恨不得把app压法周期压缩到最低,这就导致了开发中隐藏了很多问题,有点经验的工程师草率的优化下,更糟的情况那些没有经验的工程师甚至不会对app进行任何优化.</p>
<p>某种程度上来说,你开发过程中是可以忽略性能优化的. 十年前,移动设备的硬件资源是非常有限的.甚至连浮点数都是被禁止的.因为浮点数能导致代码变大计算的速度变慢.
科技发展如此迅速的今天,硬件很大程度上可以弥补软件的短板.现在的移动设备3D硬件处理的效率甚至媲美于PC机了,但是你不能总依赖于硬件和处理器速度来掩饰你APP做的多垃圾吧.(如果安卓系统跑在Iphone上还能够像IOS一样顺滑吗?,其实是一个道理的)</p>
<p>性能这个概念很抽象,所以我们必须借助数据化图形化的输出方式.你可能花一周的时间去优化一个有趣的算法,但是这算法只占总执行时间的0.5%,不管你花多少精力去优化它,没人会注意到.相反一个for循环花费了90%的时间,你稍微修改下就能提高10%的效率,就是这个简单的修改可以得到大家很大的好感.因为.他们运行app时的第一感受就是比之前快了很多.没人会care你修改的是一个多牛逼的算法,还是一个简单的for循环.
这个说明了什么.
与其花费时间在优化小细节上不如多点时间找到你改优化的地方.</p>
<p>下面引出第一个工具 &quot;时间事件查看器&quot;(自己杜撰的名字英文--Time Profiler),------他可以测量时间的间隔,中断程序执行,跟踪每个线程的堆栈.你可以想象下是xcode调试时按下暂停时的画面  </p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1ecibl3evcoj207c0g7wfl.jpg" class="center">


<p>比如,100个样本都在做1毫秒的间隔,然后在某个方法堆栈顶部同时压入了10样本,你可以推算出大概的时间有10%个10毫秒花费在此方法中,这是一个近似值.</p>
<p>废话少说,时间是个检测到的.
从xcode的菜单选择Product-Profile,或者选择⌘I,<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1ecic1kiax3j205v02nq2x.jpg">
程序会启动Instruments,这时候你会看到一个选择窗口  </p>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1ecic3fuaoqj20n10jl0v1.jpg" class="center">


<p> 这是instruments所有测试仪器的面板,选择 &quot;timer profilter&quot; 点击&quot;profile&quot;回启东模拟器和app,此时会要求你输入一次密码,以便instruments能有权限去截获监听此进程.  </p>
 <img src="http://ww4.sinaimg.cn/small/a43af4ffjw1ecicaqnba9j20fh09tgm4.jpg" class="center">


<p> 在工具窗口中，可以看到时间计数，并留下了一个小箭头移动到右侧的图形在屏幕的中央上方。这表明该应用程序正在运行。</p>
<p> 现在开始运行app,搜索一些图片,这时候你发现查找一个结果太慢了,而且搜索结果列表页面滚动起来也是让人无法忍受的,
 首先，确保工具栏中的视图选择有选择的所有三个选项，如下所示：  </p>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1ecici64zqwj202y01ijr6.jpg" class="center">


<p>￼这将确保所有的面板都打开。现在，研究下面的截图和它下面的每个部分的解释：   </p>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1ecicvvuvpqj20c208wq3v.jpg" class="center">


<figure class="highlight"><pre>
<span class="bullet">1. </span>录控按钮。中间的红色按钮将停止与启动它被点击时，应用程序目前正在分析。注意这实际上是停止和启动应用程序,而不是暂停它。  

<span class="bullet">2. </span>运行定时器和运行导航,定时器显示APP已经运行了多长时间,箭头之间是可以移动的。如果停止，然后使用录制按钮重新启动应用程序，这将开始一个新的运行。显示屏便会显示“run2 of 2”，你可以回到第一次运行的数据，首先你停止当前运行，然后按下左箭头回去。  

<span class="bullet">3. </span>运行轨道.   

<span class="bullet">4. </span>扩展面板,在时间探查仪器的情况下，它是用来跟踪显示堆栈  

<span class="bullet">5. </span>详细地面板。它显示了你正在使用的仪器的主要信息,这是使用频率最高的部门,可以从它这里看到cpu运行的时间   

<span class="bullet">6. </span>选项面板 稍后介绍
</pre></figure>

<p>重头戏来了.</p>
<h2 id="-">深究</h2>
<p>执行图像搜索，并深究结果。我个人比较喜欢寻找“狗”，当然你也可以选择任意你想要的内容.比如猫啊美女啊什么的.</p>
<p>现在上下滚动记下列表,让时间探测器测量下数据,然后注意看下屏幕的变化和数值.这些数值反应了CPU周期.</p>
<p>但是你也许会发现下面的数值太多,看你的眼花缭乱. 下面打开左边的调用树 然后按着如下的配置</p>
<img src="http://ww3.sinaimg.cn/mw690/a43af4ffjw1ecidfkvchwj205508wwem.jpg" class="center">


<p>以下介绍下配置选项：</p>
<figure class="highlight"><pre>

<span class="mathematica">Separate by <span class="keyword">Thread</span>: 每个线程应该分开考虑。只有这样你才能揪出那些大量占用CPU的<span class="string">"重"</span>线程  

Invert Call Tree: 从上倒下跟踪堆栈,这意味着你看到的表中的方法,将已从第<span class="number">0</span>帧开始取样,这通常你是想要的,只有这样你才能看到CPU中话费时间最深的方法.也就是说FuncA<span class="list">{FunB{FunC}</span>} 勾选此项后堆栈以<span class="keyword">C</span>-&gt;B-A 把调用层级最深的<span class="keyword">C</span>显示在最外面 

Hide <span class="keyword">Missing</span> Symbols: 如果dSYM无法找到你的app或者系统框架的话,那么表中看不到方法名只能看到十六进制的数值,如果勾线此项可以隐藏这些符号,便于简化数据

Hide System Libraries: 勾选此项你会显示你app的代码,这是非常有用的. 因为通常你只关心cpu花在自己代码上的时间不是系统上的

<span class="keyword">Show</span> Obj-<span class="keyword">C</span> Only: 只显示oc代码 ,如果你的程序是像OpenGl这样的程序,不要勾选侧向因为他有可能是<span class="keyword">C</span>++的  

<span class="keyword">Flatten</span> Recursion: 递归函数, 每个堆栈跟踪一个条目

<span class="keyword">Top</span> Functions: 一个函数花费的时间直接在该函数中的总和，以及在函数调用该函数所花费的时间的总时间。因此，如果函数A调用B，那么A的时间报告在A花费的时间加上B.花费的时间,这非常真有用，因为它可以让你每次下到调用堆栈时挑最大的时间数字，归零在你最耗时的方法。</span>
</pre></figure>

<p>如果您已启用上述选项,虽然有些值可能会略有不同，下面的结果的顺序应该是类似下表： </p>
<img src="http://ww3.sinaimg.cn/mw690/a43af4ffjw1eciea0qldhj20cu08w75b.jpg" class="center">


<p>通过上面你能看到大部分时间都花在更新表格照片了.</p>
<p>双击此行,然后将会看到如下  </p>
<img src="http://ww4.sinaimg.cn/mw690/a43af4ffjw1ecieegah2wj20cv08w0tj.jpg" class="center">


<p>那么这很有趣，不是吗！几乎四分之三的时间花费在setPhoto：方法都花在创造照片的图像数据！
现在可以看到的是什么问题,NSData’s dataWithContentsOfURL 方法并不会立即返回,因为要从网上去数据,每次调用都需要长达几秒的时间返回,而此方法运行在主线程,可想而知会有什么结果了.
其实为了解决这个问题,类提供了一个ImageCache 的后台异步下载的方法.</p>
<p>现在，您可以切换到Xcode和手动找到该文件，但仪器有一个方便的“打开Xcode中”按钮，就在你的眼前。找到它的面板只是上面的代码并单击它：  </p>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1ecieiognodj20c4044dfv.jpg" class="center">


<p>想如下修改</p>
<figure class="highlight"><pre>- (void)setPhoto:(FlickrPhoto *)photo {
    _photo = photo<span class="comment">;</span>
 
    self<span class="preprocessor">.textLabel</span><span class="preprocessor">.text</span> = photo<span class="preprocessor">.title</span><span class="comment">;f</span>
 
//    NSData *imageData = [NSData dataWithContentsOfURL:_photo<span class="preprocessor">.thumbnailUrl</span>]<span class="comment">; </span>
//    self<span class="preprocessor">.imageView</span><span class="preprocessor">.image</span> = [UIImage imageWithData:imageData]<span class="comment">;</span>
 
    [[ImageCache sharedInstance] downloadImageAtURL:_photo<span class="preprocessor">.thumbnailUrl</span>
                                  completionHandler:^(UIImage *image) {
                                      self<span class="preprocessor">.imageView</span><span class="preprocessor">.image</span> = image<span class="comment">;</span>
                                      [self setNeedsLayout]<span class="comment">;</span>
                                  }]<span class="comment">;</span>
}
</pre></figure>

<p>修改好厚,在仪器重新运行该应用程序Product--Profile（或⌘I-记住，这些快捷键真的会为您节省一些时间）。
请注意，这个时候会再问一次你是否使用一起。这是因为你还有一个窗口中打开这个程序，及仪器假定您要使用相同的选项再次运行。
执行一些更多的搜索，并注意此时用户界面不是那么卡顿了！这些图像现在异步加载，并缓存在后台，所以一旦他们已经被下载一次，他们不必再次下载。
看上去很不错！是时候发布了吗? 当然还不够</p>
<h2 id="-">分配，分配，分配</h2>
<p>接下来的仪器是分配工具。它能给出你所有创建和存储它们的内存的详细信息，它也显示你保留了每个对象的计数。</p>
<p>关闭仪器，回到Xcode和选择Product-&gt;Profile。然后，从选择器分配并单击配置文件。如下图:</p>
<img src="http://ww4.sinaimg.cn/mw690/a43af4ffjw1eciet83x01j20xc0oqaeh.jpg" class="center">


<p>程序再次打开 然后你会看到  </p>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1ecif0bcb3vj20c208w3zd.jpg" class="center">


<p>这个时候你会发现两个曲目。一个叫(分配)Allocations，以及一个被称为VM Tracker(虚拟机跟踪)。该分配轨道将详细在本教程中讨论;虚拟机跟踪也是非常有用的，但更复杂一点。
所以你的错误会追踪下？
有隐藏的项目，你可能不知道有东西在那儿。你可能已经听说了内存泄漏。但你可能不知道的是，其实有两种泄漏。
第一个是真正的内存泄漏，一个对象尚未被释放，但是不再被引用的了。因此，存储器不能被重新使用。
第二类泄漏是比较麻烦一些。这就是所谓的“无界内存增长”。这发生在内存继续分配，并永远不会有机会被释放。
如果永远这样下去你的程序占用的内存会无限大,当超过一定内存的话 会被系统的看门狗给kill掉.</p>
<p>建立一个场景，你可以检测出无限的内存增长。首先，在应用程序使10个不同的搜索（不要用已经存在的搜索）。确保搜索的一些结果！现在让程序等待几秒钟。</p>
<p>你应该已经注意到，在分配的轨道图不断上升。这是告诉你的,内存被分配了。它的这一特征，将引导你找到无限的内存增长。
你将要执行的是&quot;heap shot analysis&quot;。为此，按这个按钮叫“Mark Heap”。你会发现的详细面板左侧的按钮  </p>
<img src="http://ww1.sinaimg.cn/small/a43af4ffjw1ecifcxzy9uj207e03q0sv.jpg" class="center">


<p>按下它，你会看到一个红色的标志出现在轨道上，像这样：</p>
<img src="http://ww3.sinaimg.cn/mw690/a43af4ffjw1ecifgqlk64j201304ft8h.jpg" class="center">



<p>heap shot分析的目的是执行一个动作多次，看看如果内存是否无限增长。搜索一个内容，稍等几秒加载图像，然后返回主页。然后再标记堆。反复这样做不同的搜索。
演戏几个搜索后，仪器会看起来像这样：</p>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1ecifkhamr4j20c208wdgf.jpg" class="center">


<p>这时你应该会疑问。图中的蓝色是怎么回事了，你继续这样操作10次这样的搜索 蓝色还不断变高：
那肯定是不好的。别急，有什么关于内存的警告？你知道这些，对不对？内存警告是告诉一个应用程序，内存警告是ios处理app最好的方式尤其是在内存越来越吃紧的时候,你需要清除一些内存。
内存一直增长其实也不一定是你的代码除了问题,也有可能是UIKit 系统框架本身导致的.</p>
<p>通过选择HardwareSimulate内存警告在iOS模拟器的菜单栏模拟内存警告。你会发现，记忆体使用量出现小幅回落，但绝对不会回到它应该的。所以还是有无限的内存增长发生的地方。
究其原因，堆出手做钻进搜索的每次迭代后，你可以看到内存的分配每个镜头之间。一起来看看在详细信息面板，你会看到一堆一堆的镜头。</p>
<p>在iOS模拟器的菜单栏中选择hardwaresimulate内存警告模拟内存警告。你会发现内存使用会出现小幅回落，但肯定不会回到它应该在的地方。
每一次的搜索后做你可以看到内存已拍摄之间的分配。在详细信息面板看一看，你会看到一好多堆镜头。</p>
<h2 id="-">稳准狠</h2>
<p>第一个堆镜头作为参照,然后随便打开一个堆镜头,你会看到如下:  </p>
<img src="http://ww4.sinaimg.cn/mw690/a43af4ffjw1ecifzbusd2j20dc07caat.jpg" class="center">


<p>靠，这是一个很大的对象！从哪里开始看呢？
最好的方式是通过列表，你在你的应用程序直接使用的类。在这种情况下，HTTPHeaderDict，CGRegion，CGPath，CFNumber，等等都是可以忽略了。
但是，一个突出的是UIImage,这肯定是在你程序使用的。点击上的UIImage左侧的箭头显示的完整列表。选择一个，在扩展详细信息面板：</p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1ecig2kckgtj203208w0sq.jpg" class="center">


<p>图中灰色的是系统库,黑色部分是你应用的代码,要获得此跟踪更多的上下文,双击唯一的黑框ImageCache方法,这时候将掉转到如下方法</p>
<figure class="highlight"><pre>- (<span class="keyword">void</span>)downloadImageAtURL:(<span class="built_in">NSURL</span>*)url completionHandler:(ImageCacheDownloadCompletionHandler)completion {
    <span class="built_in">UIImage</span> *cachedImage = [<span class="keyword">self</span> imageForKey:[url absoluteString]];
    <span class="keyword">if</span> (cachedImage) {
        completion(cachedImage);
    } <span class="keyword">else</span> {
        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^{
            NSData *data = [NSData dataWithContentsOfURL:url];
            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];
            [<span class="keyword">self</span> setImage:image forKey:[url absoluteString]];
            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
                completion(image);
            });
        });
    }
}
</pre></figure>

<p>工具是非常有用的,你现在要努力通过自己的代码思考发生了什么.看看通过上面的方法，你会看到它调用一个名为setImage方法：forKey：。这种方法在缓存以防它再次使用以后的应用程序的图像。啊！那么这肯定听起来像它可能是一个问题!
一起来看看该方法的实现：</p>
<figure class="highlight"><pre>- (void)<span class="keyword">set</span>Image:(UIImage*)image <span class="keyword">for</span>Key:(NSString*)key {
    [_cache <span class="keyword">set</span>Object:image <span class="keyword">for</span>Key:key];
}
</pre></figure>

<p>从网络上下载一个图片添加字典中,你会注意到这些图片从来没有从字典清楚过
,这就是内存为什么会一直增长,因为应用程序并不会从缓存里删除东西.它只会一直增加他们.
要解决此问题,你需要的是ImageCache收到UIApplication内存吃紧的警告时.清理缓存.</p>
<p>为了使ImageCache能接收通知，修改ini​​t方法如下：</p>
<figure class="highlight"><pre>- (<span class="keyword">id</span>)init {
    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) {
        _cache = [<span class="built_in">NSMutableDictionary</span> new];
        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(memoryWarning:) name:UIApplicationDidReceiveMemoryWarningNotification object:<span class="literal">nil</span>];
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
</pre></figure>

<p>注册UIApplicationDidReceiveMemoryWarningNotification执行memoryWarning：方法。</p>
<figure class="highlight"><pre><span class="pp">- <span class="params">(void)</span>memoryWarning:<span class="params">(<span class="variable">NSNotification</span>*)</span>note {
    [_cache removeAllObjects];
}</span>
</pre></figure>

<p>memoryWarning删除缓存中的所有对象。这将确保没有持图像。
为了测试此修复程序，再次启动仪器（从Xcode中有⌘I）和重复的步骤。不要忘了在模拟结束内存警告！</p>
<p><strong>注意：请确保您从Xcode中退出，重新构建，而不是仅仅点击仪器仪表上的红色按钮，以确保您使用的是最新的代码。</strong></p>
<p>这一次分析应该是这样的：</p>
<img src="http://ww4.sinaimg.cn/mw690/a43af4ffjw1ecign06n2yj20c208w0tb.jpg" class="center">


<p>这个时候，内存受到内存警告后急剧下降。但还是有一些内存整体增长，但远不及像以前那样。
究其原因还是有一定的增长确实是由于系统库，并没有太多可以做的。看来，系统库不释放所有的内存，这可能是由设计或可能是一个错误。你可以在你的应用程序做的是释放尽可能多的内存越好，你已经做到这一点！
干得好！还有一个问题，修补了, - 仍然有泄漏，你还没有解决的第一种类型的问题。</p>
<h2 id="-">内存泄露</h2>
<p>内存泄漏的仪器。这是用来找到第一类泄漏前面提到的 - 当一个对象不再被引用时出现的那种
检测泄漏是可以理解的一个很复杂的事情，但泄漏的工具记得，已分配的所有对象，并定期通过扫描每个对象以确定是否有任何不能从任何其他对象访问的。
关闭仪器，回到Xcode和选择Product-&gt;Profile  </p>
<img src="http://ww4.sinaimg.cn/mw690/a43af4ffjw1eciguvy9x5j20xc0p8dke.jpg" class="center">


<p>回到你的应用程序！执行搜索，得到结果。然后点选结果的预览行打开全屏浏览器。按下旋转按钮在左上角，然后再按一次。
回到仪器，等待片刻。如果你已经正确地完成上述步骤后，你会发现泄漏已经出现了！你的工具窗口将看起来像这样：  </p>
<img src="http://ww4.sinaimg.cn/mw690/a43af4ffjw1ecigwp5ymtj20c208wmxq.jpg" class="center">


<p>返回到模拟器，并按下旋转几次。然后返回到仪器和等会,得到如下结果：</p>
<img src="http://ww4.sinaimg.cn/mw690/a43af4ffjw1ecigy7zu2hj20c208w0tb.jpg" class="center">


<p>哪来的泄漏从哪里来？扩展详细信息面板   </p>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1ecici64zqwj202y01ijr6.jpg" class="center">

<p>在扩展的详细信息面板打开CGContext上名单。在列表中选择CGContext上的元素之一，这表明导致要创建的对象，如下面的堆栈跟踪： </p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1ecih21lep0j203208wdfz.jpg" class="center">


<p>再次，涉及到你的代码中的帧显示为黑色。由于只有一个，双击它，看看代码的方法。
有问题的方法是rotateTapped： ，这是被调用时被窃听旋转按钮的处理程序。这种方法旋转原始图像，并创建一个新的图像，如下：</p>
<figure class="highlight"><pre>- (void)rotateTapped:(id)sender {
    UIImage *currentImage = _imageView<span class="preprocessor">.image</span><span class="comment">;</span>
    CGImageRef currentCGImage = currentImage<span class="preprocessor">.CGImage</span><span class="comment">;</span>
 
    CGSize originalSize = currentImage<span class="preprocessor">.size</span><span class="comment">;</span>
    CGSize rotatedSize = CGSizeMake(originalSize<span class="preprocessor">.height</span>, originalSize<span class="preprocessor">.width</span>)<span class="comment">;</span>
 
    CGContextRef context = CGBitmapContextCreate(NULL,
                                                 rotatedSize<span class="preprocessor">.width</span>,
                                                 rotatedSize<span class="preprocessor">.height</span>,
                                                 CGImageGetBitsPerComponent(currentCGImage),
                                                 CGImageGetBitsPerPixel(currentCGImage) * rotatedSize<span class="preprocessor">.width</span>,
                                                 CGImageGetColorSpace(currentCGImage),
                                                 CGImageGetBitmapInfo(currentCGImage))<span class="comment">;</span>
 
    CGContextTranslateCTM(context, rotatedSize<span class="preprocessor">.width</span>, <span class="number">0.0</span>f)<span class="comment">;</span>
    CGContextRotateCTM(context, M_PI_2)<span class="comment">;</span>
    CGContextDrawImage(context, (CGRect){<span class="preprocessor">.origin</span>=CGPointZero, <span class="preprocessor">.size</span>=originalSize}, currentCGImage)<span class="comment">;</span>
 
    CGImageRef newCGImage = CGBitmapContextCreateImage(context)<span class="comment">;</span>
    UIImage *newImage = [UIImage imageWithCGImage:newCGImage]<span class="comment">;</span>
 
    self<span class="preprocessor">.imageView</span><span class="preprocessor">.image</span> = newImage<span class="comment">;</span>
}
</pre></figure>

<p>再次，仪器只能在这里给你一个提示，问题出在哪里，它不能告诉你确切位置的泄漏。这是唯一能够证明你在创建对象泄露的地方.你可能认为ARC并有不可能是造成代码中内存泄漏...对不对？
回想一下，ARC只涉及Objective-C的对象。它不管理保留和的CoreFoundation对象而不是Objective-C的对象的释放。
啊，现在它开始变得明显的问题是什么 
-CGContextRef和CGImageRef对象永远不会被释放！为了解决这个问题，在rotateTapped方法的末尾添加以下两行代码：</p>
<figure class="highlight"><pre><span class="function">CGImageRelease(newCGImage)</span>;
<span class="function">CGContextRelease(context)</span>;
</pre></figure>

<p>这两种调用都需要来维护这两个对象的保留计数。这个说明，你还需要了解引用计数 - 即使你在你的项目中使用的ARC！
从在Xcode中，使用⌘I工具构建和运行应用程序。
在使用泄漏仪器仪器再看看应用程序，看看是否泄漏的被固定。如果你正确地遵循上述步骤，泄漏应消失！</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ARC下block,weak,unsafe_unretained]]></title>
    <link href="http://hufeng825.github.com/2013/11/30/ios34/"/>
    <id>http://hufeng825.github.com/2013/11/30/ios34/</id>
    <published>2013-11-30T12:44:06.000Z</published>
    <updated>2014-01-14T03:23:37.000Z</updated>
    <content type="html"><![CDATA[<p>最近把项目转到ARC 下了,之前__block 之前总结过一篇关于 <a href="http://blog.csdn.net/hufengvip/article/details/11585537" target="_blank">block</a> 的文章,有兴趣的童鞋可以去看下.</p>
<a id="more"></a>


<figure class="highlight"><pre><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ： <span class="title">UIViewViewController</span> </span>
 {
        <span class="built_in">NSString</span> *_string;
 }

 __block ViewController *controller = <span class="keyword">self</span>;   
    _block = ^{
         <span class="built_in">NSLog</span>(@<span class="string">"string %@"</span>,controller-&gt;_string);
    };
</pre></figure>

<p>ARC 下 <strong>block 依然可用 但是实现发现 </strong>block 在AF 执行异步多线程下 会调用返回后 才会调用dealloc将当前VC 销毁, 如果改为__weak 后
当前的VC 会马上调用dealloc销毁. 而网络请求会以错误error.code  -999 异步取消返回.</p>
<p>__weak UIViewController *vc = self; // OK for iOS 5 only</p>
<p>__unsafe_unretained UIViewController *vc = self; // OK for iOS 4.x and up</p>
<p>__block UIViewController *vc = self; // OK if you aren&#39;t using ARC</p>
<p>以上是三个比较接近容易搞混的关键字.</p>
<p>__weak 在释放指针后能够同时将指针置为nil</p>
<p>__unsafe_unretained 只留下一个无效的也指针</p>
<p>__block 打破循环 copy副本 内部修改</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[mac 下 node-qrcode的二维码库]]></title>
    <link href="http://hufeng825.github.com/2013/11/27/nodejs1/"/>
    <id>http://hufeng825.github.com/2013/11/27/nodejs1/</id>
    <published>2013-11-27T13:51:25.000Z</published>
    <updated>2014-01-14T03:23:37.000Z</updated>
    <content type="html"><![CDATA[<p>这两天在mac下折腾node.js 的二维码库 ,遇到了n多大坑. 按着其官方文档的说明只有下面简简单单几句</p>
<figure class="highlight"><pre>Dependencies

These should be taken care <span class="operator">of</span> <span class="keyword">for</span> you <span class="keyword">by</span> npm but you should...

npm install canvas
If cairo gives you trouble <span class="operator">and</span> you cannot install canvas, checkout <span class="operator">the</span> canvas site. I know @tjholowaychuk has setup <span class="operator">a</span> way <span class="built_in">to</span> download <span class="operator">and</span> install <span class="operator">a</span> <span class="built_in">version</span> <span class="operator">of</span> cairo/pixman <span class="keyword">for</span> testing.

The <span class="built_in">word</span> <span class="string">"QR Code"</span> is registered trademark <span class="operator">of</span>:

DENSO WAVE INCORPORATED
</pre></figure>

<p>如果你的系统是mac的话 你只按着上面的安装方法 保准你折腾的头破血流, 我就是血淋淋的例子啊.</p>
<p>因为mac 下其要安装的库太多了 .下面一次列出来</p>
<figure class="highlight"><pre>
<span class="bullet">1. </span>brew install  pkgconfig  如果没有安装homebrew 的话 恭喜你 安装去吧.

<span class="bullet">2. </span>install XQuartz [<span class="link_label">下载地址</span>](<span class="link_url">https://xquartz.macosforge.org</span>)

<span class="bullet">3. </span>brew install Cairo

<span class="bullet">4. </span>coyped all /opt/X11/lib/pkgconfig/*.pc to /usr/local/lib/pkgconfig on your mac

<span class="bullet">5. </span>sudo npm install -g qrcode
</pre></figure>

<p>以上的安装步骤 我可是折腾了足足一个晚上.</p>
<p>写个demo 进行测试下 qrcode.js</p>
<figure class="highlight lang-`"><pre>var http = require("http");
var QRCode = require('qrcode');
function onRequest(request, response) {
  console.log("Request received.");
  response.writeHead(200, {"Content-Type": "text/html"});
  QRCode.toDataURL("胡峰",function(err,url){
    if(err) console.log('error: '+err);
    //console.log(url);
    response.end("<span class="doctype">&lt;!DOCTYPE html/&gt;</span><span class="tag">&lt;<span class="title">html</span>&gt;</span><span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;<span class="title">title</span>&gt;</span>二维码<span class="tag">&lt;/<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span><span class="tag">&lt;<span class="title">body</span>&gt;</span><span class="tag">&lt;<span class="title">p</span> &gt;</span>请扫描二维码<span class="tag">&lt;/<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">'"+url+"'</span>/&gt;</span><span class="tag">&lt;/<span class="title">body</span>&gt;</span><span class="tag">&lt;/<span class="title">html</span>&gt;</span>");
  });
}

http.createServer(onRequest).listen(8888);
</pre></figure>

<p> node qrcode.js  打开浏览器 ok了</p>
 <img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1eazxou2xo0j207o075aac.jpg" class="center">




]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/mac/" term="mac"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ios UIKit Dynamics 系列教程之Gravity+Collision]]></title>
    <link href="http://hufeng825.github.com/2013/11/06/iosdynamics0/"/>
    <id>http://hufeng825.github.com/2013/11/06/iosdynamics0/</id>
    <published>2013-11-06T06:16:04.000Z</published>
    <updated>2013-11-08T06:59:12.000Z</updated>
    <content type="html"><![CDATA[<p>ios7推出好久了,但是最近忙着工作的时间现在才抽时间自己看了WWDC2013,很是惭愧.最客户端其实最有趣的莫过于动画.ios7给我最大的惊喜就是UIKit Dynamics的到来,想想两年前写招行掌上生活首页的时候,那时候没有现成的物理引擎,写的动画非常生硬,套用现在流行的话就是&quot;既视感&quot;不强.
<a id="more"></a></p>
<p>理论性的东西不太擅长.引用<a href="http://onevcat.com/2013/06/uikit-dynamics-started/" target="_blank">onevcat</a>老师的博客.</p>
<h2 id="uikituikit-">UIKitUIKit动力架构：</h2>
<h3 id="1-uidynamicitem-">1 UIDynamicItem；</h3>
<p>Dynamic的协议对象</p>
<h3 id="2-uidynamicbehavior-">2 UIDynamicBehavior：</h3>
<p>动力行为的描述，用来指定UIDynamicItem应该如何运动，即定义适用的物理规则；</p>
<p>其下面又有几种行为</p>
<ol>
<li><p>吸附行为（UIAttachmentBehavior）： 有一个对象UIAttachmentBehavior，该对象用来指定两个动力项（项或点）之间的连接，当一个项或者点移动时，吸附的项也随之移动。当然，这个连接并不是完全是静态的（static），吸附的项有两个属性damping(阻尼)和oscillation(震荡)，这两个属性决定了吸附项的行为是如何随时间而变化的。</p>
</li>
<li><p>碰撞行为（UICollisionBehavior）： 通过对象UICollisionBehavior指定一个边界，并且让各个动力项，在该边界内参与碰撞。UICollisionBehavior对象还可以指定这些动力项适当的回应碰撞。</p>
</li>
<li><p>重力行为（UIGravityBehavior）： 通过对象UIGravityBehavior给动力项指定一个重力矢量，具有重力矢量的动力项，会在重力矢量的方向上一直加速，直到与别的动力项产生了冲突或者，遇到了边界。</p>
</li>
<li><p>推动行为（UIPushBehavior）： 通过对象UIPushBehavior给动力项指定一个持续的或者瞬时的力（force vector）。</p>
</li>
<li><p>捕捉行为（UISnapBehavior）： 通过对象UISnapBehavior给动力项指定一个捕捉点。动力项会根据配置的效果，来抓住这一捕捉点。</p>
</li>
</ol>
<p>当动力行为被添加到animator（UIDynamicAnimator类的实例对象）时，动力行为就被激活。animator为动力行为的执行提供了上下文。动力项可以以组合形式出现,只要添加到同一个animator中即可。</p>
<h3 id="3-uidynamicanimator-">3 UIDynamicAnimator；</h3>
<p>动画的播放者，动力行为（UIDynamicBehavior）的容器，添加到容器内的行为将发挥作用；</p>
<h3 id="4-referenceview-">4 ReferenceView：</h3>
<p>等同于力学参考系，</p>
<p>只有当想要添加力学的UIView是ReferenceView的子view时，动力UI才发生作用。</p>
<hr>
<p>下面开始动手来做
比如我们要实现下面的功能</p>
<img src="http://ww3.sinaimg.cn/mw690/a43af4ffjw1eadmdoeir3g208z0d8x4h.gif" class="center">



<ol>
<li>首先创建 我们的animatior</li>
</ol>
<figure class="highlight"><pre><span class="attribute">UIDynamicAnimator *animator </span>=<span class="string"> [[UIDynamicAnimator alloc] initWithReferenceView:self.view];</span>
</pre></figure>

<ol>
<li>对你想要进行动画的 item 添加上想要的物理行为 下面 我对square1 分别添加了 重力和碰撞还有吸附引擎.</li>
</ol>
<figure class="highlight"><pre>UIGravityBehavior *gravityBeahvior = <span class="string">[[UIGravityBehavior alloc] initWithItems:@[self.square1]]</span>;
UICollisionBehavior *collisionBehavior = <span class="string">[[UICollisionBehavior alloc] initWithItems:@[self.square1]]</span>;

CGPoint anchorPoint = CGPointMake(self.square1.center.x, self.square1.center.y - <span class="number">110.0</span>);
UIAttachmentBehavior *attachmentBehavior = <span class="string">[[UIAttachmentBehavior alloc] initWithItem:self.square1 attachedToAnchor:anchorPoint];

//anchorPoint 为描点 及Beahvior相对应的作力点</span>
</pre></figure>

<ol>
<li>激活碰撞引擎的边界属性</li>
</ol>
<figure class="highlight"><pre><span class="attribute">collisionBehavior.translatesReferenceBoundsIntoBoundary </span>=<span class="string"> YES;</span>
</pre></figure>

<p>他的边界是针对于你设置的animator中的referenceView而定的,即self.view  当然我们也可以自定义某一个区域作为碰撞边界</p>
<figure class="highlight"><pre><span class="title">[collisionBehavior setTranslatesReferenceBoundsIntoBoundaryWithInsets:UIEdgeInsetsMake(0, 0, 100.0, 100.0)]</span><span class="comment">;</span>
</pre></figure>

<p>这样子还不能满足你的需求 cocoa 还提供了添加UIBezierPath的方法 addBoundaryWithIdentifier:forPath:和添加一条线段为边界的 addBoundaryWithIdentifier:fromPoint:toPoint 方法</p>
<p>4: 为了方便显示 我们给square1添加一个imageView, 然后设置图片的渲染属性 这样子我们可以很方便的改变图片的颜色用以</p>
<p>self.square1ImageView.image = [self.square1ImageView.image imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];</p>
<p>5:设置震荡频率和阻尼</p>
<figure class="highlight"><pre>// These parameters <span class="operator"><span class="keyword">set</span> the attachment <span class="keyword">in</span> spring mode, instead <span class="keyword">of</span> a rigid
// <span class="keyword">connection</span>.
[attachmentBehavior setFrequency:<span class="number">.5</span>];</span>
[attachmentBehavior setDamping:0.2];
</pre></figure>

<p>6: 为了更清楚的显示描点 和 item 显示的作用力 我们用绳子来展示</p>
<p>实现机制很简单 就是用绳子图片进行拼接 然后KVO 描点和item的运动轨迹 动态刷新 </p>
<figure class="highlight"><pre>- (<span class="keyword">void</span>)trackAndDrawAttachmentFromView:(<span class="built_in">UIView</span>*)attachmentPointView toView:(<span class="built_in">UIView</span>*)attachedView withAttachmentOffset:(<span class="built_in">CGPoint</span>)attachmentOffset
{
    <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.attachmentDecorationLayers</span>)
        <span class="comment">// First time initialization.</span>
    {
        <span class="keyword">self</span><span class="variable">.attachmentDecorationLayers</span> = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">4</span>];
        <span class="keyword">for</span> (NSUInteger i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)
        {
            <span class="built_in">UIImage</span> *dashImage = [<span class="built_in">UIImage</span> imageNamed:[<span class="built_in">NSString</span> stringWithFormat:@<span class="string">"DashStyle%i"</span>, (i % <span class="number">3</span>) + <span class="number">1</span>]];
            
            CALayer *dashLayer = [CALayer layer];
            dashLayer<span class="variable">.contents</span> = (__bridge <span class="keyword">id</span>)(dashImage<span class="variable">.CGImage</span>);
            dashLayer<span class="variable">.bounds</span> = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, dashImage<span class="variable">.size</span><span class="variable">.width</span>, dashImage<span class="variable">.size</span><span class="variable">.height</span>);
            dashLayer<span class="variable">.anchorPoint</span> = CGPointMake(<span class="number">0.5</span>, <span class="number">0</span>);
            
            [<span class="keyword">self</span><span class="variable">.layer</span> insertSublayer:dashLayer atIndex:<span class="number">0</span>];
            [<span class="keyword">self</span><span class="variable">.attachmentDecorationLayers</span> addObject:dashLayer];
        }
    }
    
    <span class="comment">// A word about performance.</span>
    <span class="comment">// Tracking changes to the properties of any id&lt;UIDynamicItem&gt; involved in</span>
    <span class="comment">// a simulation incurs a performance cost.  You will receive a callback</span>
    <span class="comment">// during each step in the simulation in which the tracked item is not at</span>
    <span class="comment">// rest.  You should therefore strive to make your callback code as</span>
    <span class="comment">// efficient as possible.</span>
    
    [<span class="keyword">self</span><span class="variable">.attachmentPointView</span> removeObserver:<span class="keyword">self</span> forKeyPath:@<span class="string">"center"</span>];
    [<span class="keyword">self</span><span class="variable">.attachedView</span> removeObserver:<span class="keyword">self</span> forKeyPath:@<span class="string">"center"</span>];
    
    <span class="keyword">self</span><span class="variable">.attachmentPointView</span> = attachmentPointView;
    <span class="keyword">self</span><span class="variable">.attachedView</span> = attachedView;
    <span class="keyword">self</span><span class="variable">.attachmentOffset</span> = attachmentOffset;
    
    <span class="comment">// Observe the 'center' property of both views to know when they move.</span>
    [<span class="keyword">self</span><span class="variable">.attachmentPointView</span> addObserver:<span class="keyword">self</span> forKeyPath:@<span class="string">"center"</span> options:<span class="number">0</span> context:<span class="literal">NULL</span>];
    [<span class="keyword">self</span><span class="variable">.attachedView</span> addObserver:<span class="keyword">self</span> forKeyPath:@<span class="string">"center"</span> options:<span class="number">0</span> context:<span class="literal">NULL</span>];
    
    [<span class="keyword">self</span> setNeedsLayout];
}

<span class="comment">//| ----------------------------------------------------------------------------</span>
- (<span class="keyword">void</span>)layoutSubviews
{
    [<span class="keyword">super</span> layoutSubviews];
    
    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.attachmentDecorationLayers</span>)
    {
        <span class="comment">// Here we adjust the line dash pattern visualizing the attachement</span>
        <span class="comment">// between attachmentPointView and attachedView to account for a change</span>
        <span class="comment">// in the position of either.</span>
        
        <span class="keyword">const</span> NSUInteger MaxDashes = <span class="keyword">self</span><span class="variable">.attachmentDecorationLayers</span><span class="variable">.count</span>;
        
        <span class="built_in">CGPoint</span> attachmentPointViewCenter = CGPointMake(<span class="keyword">self</span><span class="variable">.attachmentPointView</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>/<span class="number">2</span>, <span class="keyword">self</span><span class="variable">.attachmentPointView</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>/<span class="number">2</span>);
        attachmentPointViewCenter = [<span class="keyword">self</span><span class="variable">.attachmentPointView</span> convertPoint:attachmentPointViewCenter toView:<span class="keyword">self</span>];
        <span class="built_in">CGPoint</span> attachedViewAttachmentPoint = CGPointMake(<span class="keyword">self</span><span class="variable">.attachedView</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>/<span class="number">2</span> + <span class="keyword">self</span><span class="variable">.attachmentOffset</span><span class="variable">.x</span>, <span class="keyword">self</span><span class="variable">.attachedView</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>/<span class="number">2</span> + <span class="keyword">self</span><span class="variable">.attachmentOffset</span><span class="variable">.y</span>);
        attachedViewAttachmentPoint =  [<span class="keyword">self</span><span class="variable">.attachedView</span> convertPoint:attachedViewAttachmentPoint toView:<span class="keyword">self</span>];
        
        <span class="built_in">CGFloat</span> distance = sqrtf( powf(attachedViewAttachmentPoint<span class="variable">.x</span>-attachmentPointViewCenter<span class="variable">.x</span>, <span class="number">2.0</span>) +
                                 powf(attachedViewAttachmentPoint<span class="variable">.y</span>-attachmentPointViewCenter<span class="variable">.y</span>, <span class="number">2.0</span>) );
        <span class="built_in">CGFloat</span> angle = atan2( attachedViewAttachmentPoint<span class="variable">.y</span>-attachmentPointViewCenter<span class="variable">.y</span>,
                              attachedViewAttachmentPoint<span class="variable">.x</span>-attachmentPointViewCenter<span class="variable">.x</span> );
        
        NSUInteger requiredDashes = <span class="number">0</span>;
        <span class="built_in">CGFloat</span> d = <span class="number">0.0</span>f;
        
        <span class="comment">// Depending on the distance between the two views, a smaller number of</span>
        <span class="comment">// dashes may be needed to adequately visualize the attachment.  Starting</span>
        <span class="comment">// with a distance of 0, we add the length of each dash until we exceed</span>
        <span class="comment">// 'distance' computed previously or we use the maximum number of allowed</span>
        <span class="comment">// dashes, 'MaxDashes'.</span>
        <span class="keyword">while</span> (requiredDashes &lt; MaxDashes)
        {
            CALayer *dashLayer = <span class="keyword">self</span><span class="variable">.attachmentDecorationLayers</span>[requiredDashes];
            
            <span class="keyword">if</span> (d + dashLayer<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span> &lt; distance) {
                d += dashLayer<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>;
                dashLayer<span class="variable">.hidden</span> = <span class="literal">NO</span>;
                requiredDashes++;
            } <span class="keyword">else</span>
                <span class="keyword">break</span>;
        }
        
        <span class="comment">// Based on the total length of the dashes we previously determined were</span>
        <span class="comment">// necessary to visualize the attachment, determine the spacing between</span>
        <span class="comment">// each dash.</span>
        <span class="built_in">CGFloat</span> dashSpacing = (distance - d) / (requiredDashes + <span class="number">1</span>);
        
        <span class="comment">// Hide the excess dashes.</span>
        <span class="keyword">for</span> (; requiredDashes &lt; MaxDashes; requiredDashes++)
            [<span class="keyword">self</span><span class="variable">.attachmentDecorationLayers</span>[requiredDashes] setHidden:<span class="literal">YES</span>];
        
        <span class="comment">// Disable any animations.  The changes must take full effect immediately.</span>
        [CATransaction begin];
        [CATransaction setAnimationDuration:<span class="number">0</span>];
        
        <span class="comment">// Each dash layer is positioned by altering its affineTransform.  We</span>
        <span class="comment">// combine the position of rotation into an affine transformation matrix</span>
        <span class="comment">// that is assigned to each dash.</span>
        CGAffineTransform transform = CGAffineTransformMakeTranslation(attachmentPointViewCenter<span class="variable">.x</span>, attachmentPointViewCenter<span class="variable">.y</span>);
        transform = CGAffineTransformRotate(transform, angle - M_PI/<span class="number">2</span>);
        
        <span class="keyword">for</span> (NSUInteger drawnDashes = <span class="number">0</span>; drawnDashes &lt; requiredDashes; drawnDashes++)
        {
            CALayer *dashLayer = <span class="keyword">self</span><span class="variable">.attachmentDecorationLayers</span>[drawnDashes];
            
            transform = CGAffineTransformTranslate(transform, <span class="number">0</span>, dashSpacing);
            
            [dashLayer setAffineTransform:transform];
            
            transform = CGAffineTransformTranslate(transform, <span class="number">0</span>, dashLayer<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>);
        }
        
        [CATransaction commit];
    }
}


<span class="comment">//| ----------------------------------------------------------------------------</span>
- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context
{
    <span class="keyword">if</span> (object == <span class="keyword">self</span><span class="variable">.attachmentPointView</span> || object == <span class="keyword">self</span><span class="variable">.attachedView</span>)
        [<span class="keyword">self</span> setNeedsLayout];
    <span class="keyword">else</span>
        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];
}
</pre></figure>

<p>6: 为了让程序更有意思点 我们可以用UICollisionBehaviorDelegate来处理碰撞回掉 比如碰到边界 我们改变下颜色</p>
<figure class="highlight"><pre>
- (<span class="keyword">void</span>)collisionBehavior:(UICollisionBehavior*)behavior beganContactForItem:(<span class="keyword">id</span>&lt;UIDynamicItem&gt;)item withBoundaryIdentifier:(<span class="keyword">id</span>&lt;NSCopying&gt;)identifier atPoint:(<span class="built_in">CGPoint</span>)p
{
    <span class="comment">// Lighten the tint color when the view is in contact with a boundary.</span>
    [(<span class="built_in">UIView</span>*)item setTintColor:[<span class="built_in">UIColor</span> redColor]];

}

<span class="comment">//| ----------------------------------------------------------------------------</span>
<span class="comment">//  This method is called when square1 stops contacting a collision boundary.</span>
<span class="comment">//  In this demo, the only collision boundary is the bounds of the reference</span>
<span class="comment">//  view (self.view).</span>
<span class="comment">//</span>
- (<span class="keyword">void</span>)collisionBehavior:(UICollisionBehavior*)behavior endedContactForItem:(<span class="keyword">id</span>&lt;UIDynamicItem&gt;)item withBoundaryIdentifier:(<span class="keyword">id</span>&lt;NSCopying&gt;)identifier
{
    <span class="comment">// Restore the default color when ending a contcact.</span>
    [(<span class="built_in">UIView</span>*)item setTintColor:[<span class="built_in">UIColor</span> greenColor]];

}
</pre></figure>

<p>7: 添加手势 这样子才能够让方框指哪打哪</p>
<ul>
<li>(IBAction)handleSpringAttachmentGesture:(UIGestureRecognizer*)gesture
{
 [self.attachmentBehavior setAnchorPoint:[gesture locationInView:self.view]];
 self.attachmentView.center = self.attachmentBehavior.anchorPoint;</li>
</ul>
<p>}</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[mac下如何看凤凰卫视直播]]></title>
    <link href="http://hufeng825.github.com/2013/10/16/mac5/"/>
    <id>http://hufeng825.github.com/2013/10/16/mac5/</id>
    <published>2013-10-16T14:23:30.000Z</published>
    <updated>2013-10-16T15:54:17.000Z</updated>
    <content type="html"><![CDATA[<p>本人算是凤凰卫视的直播控吧,之前通过<a href="http://360kan.pptv.com/live/ahws/?site=pptv" target="_blank">360电视直播</a>看凤凰卫视,但是因为版权现在360直播现在把凤凰给下线了.
<a id="more"></a></p>
<h2 id="-">攻城狮的方法</h2>
<p>于是跟在凤凰的兄弟要了他们的直播源,然后充分发挥自己攻城狮的优势动手编写了一个mac上的应用.
程序没什么技术含量,对我来说够用就行.
<a href="http://download.csdn.net/detail/hufeng825/6410419" target="_blank">代码上传到csdn上了</a>有需要的朋友可以去看看.</p>
<p>运行效果如图:</p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e9ngc18tzyj20ev0cxgn0.jpg">


<h2 id="mac-">mac小白可以用的方法</h2>
<p>其实可以不用像我这样麻烦可以直接用ALC这个播放器
具体步骤如下图
1:commadn + N 在打开的界面把直播的源地址添加进去</p>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1e9nghxpcbcj20j40ect9w.jpg">


<p>2:打开属性 可以修改频道名称如图</p>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1e9ngc3ppxej20ky0i40uo.jpg">


<p>3:ok 可以播放了</p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e9ngc8k2juj20ky0i4q4a.jpg">







]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/mac/" term="mac"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[如何建立基于CocoaPods的ReactiveCocoa工程]]></title>
    <link href="http://hufeng825.github.com/2013/10/13/ios31/"/>
    <id>http://hufeng825.github.com/2013/10/13/ios31/</id>
    <published>2013-10-13T14:23:32.000Z</published>
    <updated>2013-10-13T18:05:46.000Z</updated>
    <content type="html"><![CDATA[<p>ReactiveCocoa 和  CocoaPods 一样也是目前很流行的 能方便和提高效率的框架.
<a id="more"></a></p>
<p>其实不光ios 学习任何一门语音最快最直接的方法就是上手. 如果单单是看看文档只能是走马观花得到一个感性认识罢了.前两天之前一个公司的测试人员跟我联系说如何学习JAVA,我问他是怎么学的,他说从网上下了好多视频教程,一直在看视频教程,也买了一些书. 我问他敲了多少代码,他说很少. 其实跟他一样的人不少. 我觉得任何事情都不简单,因为看起来简单的事情自己没有实际做过的话 往往会遇到各种各样的问题. 这也是为什么在工作中制定项目进度计划的时候 我尽量给自己和团队中的人多争取时间的最主要的一个因素.  </p>
<p>好了,自己一些啰嗦和感悟. 下面开始正式.</p>
<hr>
<h2 id="what-is-reactive-cocoa-">What is Reactive Cocoa?</h2>
<p> RAV is an Object-C framework for Functional Reavtive Programming;
 两个关键点:
 1:framework 既然是framework 那就跟你用的其他framework没什么区别 无非就是加到工程中引用罢了.不做多余解释
 2:Functional Reavtive Programming 实时响应式编程</p>
<p>虾米引用被阿里收购后现在先上的mac版本的虾米音乐就是用Reactive Cocoa开发的.用阿里人自己的话来说就是</p>
<blockquote>
<p>好东西啊，以前我们用 KVO 或 Notification 来自动绑定数据，改用 ReactiveCocoa 写以后，代码结构更佳简单清晰，同时代码行数直接减少 60% 以上</p>
</blockquote>
<p>来点直观的对比吧,比如我们想要实现一个需求:当变量中的字符串改变后即时做出相应的反馈 我们用KVO 需要如下这样做</p>
<figure class="highlight"><pre><span class="comment">// In your viewDidLoad/awakeFromNib/init</span>
[<span class="keyword">self</span> addObserver:<span class="keyword">self</span> 
       forKeyPath:@<span class="string">"someString"</span> 
          options:NSKeyValueObservingOptionNew 
          context:&someStringChangeContext];

<span class="comment">// In dealloc</span>
[<span class="keyword">self</span> removeObserver:<span class="keyword">self</span> 
          forKeyPath:@<span class="string">"someString"</span> 
             context:&someStringChangeContext];

<span class="comment">// Elsewhere in your class</span>
- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath 
                      ofObject:(<span class="keyword">id</span>)object 
                        change:(<span class="built_in">NSDictionary</span> *)change 
                       context:(<span class="keyword">void</span> *)context
{
    <span class="keyword">if</span> (context == &someStringChangeContext) {
        <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"someString"</span>]) {        
            <span class="comment">// Do a bunch of stuff here</span>
        }
    }
}
</pre></figure>

<p>上面一坨代码 在应用Reactive Cocoa后 只有短短一行</p>
<figure class="highlight"><pre>[RACObserve(self, someString) distinctUntilChanged] subscribeNext:^(NSString *string) {
    // <span class="operator"><span class="keyword">Do</span> a bunch <span class="keyword">of</span> things here, just <span class="keyword">like</span> you would <span class="keyword">with</span> KVO
}];</span>
</pre></figure>

<h2 id="-">开始动手</h2>
<p>因为我之前安装了<a href="http://hufeng825.github.io/2013/10/11/ios30/" target="_blank">CocoaPods</a>,所以我这次写的ReactiveCocoaDemo 是基于CocoaPods的.如果没有安装的可以童鞋,可以直接从github上下载<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank">ReactiveCocoa</a></p>
<h3 id="-">前期工作:</h3>
<p>1.打开xcode 创建一个工程,我命名的工程名为ReactiveCocoaDemo,</p>
<p>2.终端到工程路径下</p>
<pre><code>cd ReactiveCocoaDemo/
pod search ReactiveCocoa
</code></pre><p>3.配置依赖文件</p>
<pre><code>vi Podfile
    platform :ios,&#39;5.0&#39;
    pod &#39;ReactiveCocoa&#39;
wq
</code></pre><p>4.下载文件  </p>
<pre><code> pod install /update
</code></pre><p>5:打开&quot;Build Phases&quot; 选中相应的target, 添加 RAC 到 &quot;Link Binary With Libraries&quot;.加上libReactiveCocoa-iOS.a</p>
<p>如下图</p>
<p>6:在Header Search Paths 中添加$(BUILD_ROOT)/../IntermediateBuildFilesPath/UninstalledProducts/include&quot; </p>
<p>7:在  &quot;Other Linker Flags&quot; 添加 -ObjC </p>
<p>8:在ReactiveCocoaDemo-Prefix.pch 将RAC的头文件加进去 </p>
<pre><code>#import &quot;ReactiveCocoa.h&quot;
</code></pre><h3 id="-">现在要实现如下功能</h3>
<p>两个输入框 一个提示的Lable 一个按钮,
1.当两个输入框的内容相同时 提示文字显示&quot;成功&quot; 按钮可以点击
2.当任意一个输入框没有输入内容时 提示文字显示&quot;请输入&quot;  按钮不可点击
3.当输入框非空且两个输入内容不同时 提示&quot;请重新输入&quot;  按钮不可点击</p>
<p>下面是部分实现代码:</p>
<figure class="highlight"><pre>@weakify(<span class="keyword">self</span>);
[[RACObserve(<span class="keyword">self</span>, warningText)
  filter:^(<span class="built_in">NSString</span> *newString) {
      <span class="keyword">self</span><span class="variable">.resultLabel</span><span class="variable">.text</span> = newString;
      <span class="keyword">return</span> <span class="literal">YES</span>;
<span class="comment">//          return [newString hasPrefix:@"Success"];</span>
  }]
 subscribeNext:^(<span class="built_in">NSString</span> *newString) {
     @strongify(<span class="keyword">self</span>);
     <span class="keyword">self</span><span class="variable">.bt</span><span class="variable">.enabled</span> = [newString hasPrefix:@<span class="string">"Success"</span>];
 }];


RAC(<span class="keyword">self</span>,<span class="keyword">self</span><span class="variable">.warningText</span>) = [RACSignal combineLatest:@[
RACObserve(<span class="keyword">self</span>,<span class="keyword">self</span><span class="variable">.input</span><span class="variable">.text</span>),RACObserve(<span class="keyword">self</span>, <span class="keyword">self</span><span class="variable">.verifyInput</span><span class="variable">.text</span>)]
reduce:^(<span class="built_in">NSString</span> *password, <span class="built_in">NSString</span> *passwordConfirm)
{
    <span class="keyword">if</span> ([passwordConfirm isEqualToString:password])
    {
        <span class="keyword">return</span> @<span class="string">"Success"</span>;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>([password length] == <span class="number">0</span> || [passwordConfirm length] ==<span class="number">0</span> )
    {
        <span class="keyword">return</span> @<span class="string">"Please Input"</span>;
    }
    <span class="keyword">else</span>
    <span class="keyword">return</span> @<span class="string">"Input Error"</span>;
}
  ];
</pre></figure>

<p>对应关系如下图所示</p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e9k2n3lrisj20kf0960ty.jpg">


<p>学过C++ 的应该觉得这个很类似于Qt中的信号槽机制</p>
<p><strong>需要说明的是</strong> 因为RAC很大程度上是依赖于Block的.所以在RAC前面我们加上@weakify(my_variable) 避免循环引用,然后在每一个
RAC块中为了防止提前释放我们需要用@strongify(my_variable)来对对象进行持有.<a href="https://github.com/jspahrsummers/libextobjc/blob/master/extobjc/EXTScope.h" target="_blank">详情点击</a></p>
<p>运行效果图如下</p>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1e9k2zoesjqj208e069t8m.jpg">




<hr>
<h2 id="-">文档附录</h2>
<h3 id="subscription">Subscription</h3>
<p>The [-subscribe…][RACSignal] methods give you access to the current and future values in a signal:</p>
<figure class="highlight lang-objc"><pre>RACSignal *letters = [@<span class="string">"A B C D E F G H I"</span> componentsSeparatedByString:@<span class="string">" "</span>]<span class="variable">.rac_sequence</span><span class="variable">.signal</span>;

<span class="comment">// Outputs: A B C D</span>
[letters subscribeNext:^(<span class="built_in">NSString</span> *x) {
    <span class="built_in">NSLog</span>(@<span class="string">"%@"</span>, x);
}];
</pre></figure>

<p>For a cold signal, side effects will be performed once <em>per subscription</em>:</p>
<figure class="highlight lang-objc"><pre>__block <span class="keyword">unsigned</span> subscriptions = <span class="number">0</span>;

RACSignal *loggingSignal = [RACSignal createSignal:^ RACDisposable * (<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) {
    subscriptions++;
    [subscriber sendCompleted];
    <span class="keyword">return</span> <span class="literal">nil</span>;
}];

<span class="comment">// Outputs:</span>
<span class="comment">// subscription 1</span>
[loggingSignal subscribeCompleted:^{
    <span class="built_in">NSLog</span>(@<span class="string">"subscription %u"</span>, subscriptions);
}];

<span class="comment">// Outputs:</span>
<span class="comment">// subscription 2</span>
[loggingSignal subscribeCompleted:^{
    <span class="built_in">NSLog</span>(@<span class="string">"subscription %u"</span>, subscriptions);
}];
</pre></figure>

<p>This behavior can be changed using a [connection][Connections].</p>
<h3 id="injecting-effects">Injecting effects</h3>
<p>The [-do…][RACSignal+Operations] methods add side effects to a signal without actually
subscribing to it:</p>
<figure class="highlight lang-objc"><pre>__block <span class="keyword">unsigned</span> subscriptions = <span class="number">0</span>;

RACSignal *loggingSignal = [RACSignal createSignal:^ RACDisposable * (<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) {
    subscriptions++;
    [subscriber sendCompleted];
    <span class="keyword">return</span> <span class="literal">nil</span>;
}];

<span class="comment">// Does not output anything yet</span>
loggingSignal = [loggingSignal doCompleted:^{
    <span class="built_in">NSLog</span>(@<span class="string">"about to complete subscription %u"</span>, subscriptions);
}];

<span class="comment">// Outputs:</span>
<span class="comment">// about to complete subscription 1</span>
<span class="comment">// subscription 1</span>
[loggingSignal subscribeCompleted:^{
    <span class="built_in">NSLog</span>(@<span class="string">"subscription %u"</span>, subscriptions);
}];
</pre></figure>

<h2 id="transforming-streams">Transforming streams</h2>
<p>These operators transform a single stream into a new stream.</p>
<h3 id="mapping">Mapping</h3>
<p>The [-map:][RACStream] method is used to transform the values in a stream, and
create a new stream with the results:</p>
<figure class="highlight lang-objc"><pre>RACSequence *letters = [<span class="string">@"A B C D E F G H I"</span> componentsSeparatedByString:<span class="string">@" "</span>].rac_sequence;

<span class="comment">// Contains: AA BB CC DD EE FF GG HH II</span>
RACSequence *mapped = [letters map:^(NSString *<span class="keyword">value</span>) {
    <span class="keyword">return</span> [<span class="keyword">value</span> stringByAppendingString:<span class="keyword">value</span>];
}];
</pre></figure>

<h3 id="filtering">Filtering</h3>
<p>The [-filter:][RACStream] method uses a block to test each value, including it
into the resulting stream only if the test passes:</p>
<figure class="highlight lang-objc"><pre>RACSequence *numbers = [<span class="string">@"1 2 3 4 5 6 7 8 9"</span> componentsSeparatedByString:<span class="string">@" "</span>].rac_sequence;

<span class="comment">// Contains: 2 4 6 8</span>
RACSequence *filtered = [numbers filter:^ BOOL (NSString *<span class="keyword">value</span>) {
    <span class="keyword">return</span> (<span class="keyword">value</span>.intValue % <span class="number">2</span>) == <span class="number">0</span>;
}];
</pre></figure>

<h2 id="combining-streams">Combining streams</h2>
<p>These operators combine multiple streams into a single new stream.</p>
<h3 id="concatenating">Concatenating</h3>
<p>The [-concat:][RACStream] method appends one stream&#39;s values to another:</p>
<figure class="highlight lang-objc"><pre>RACSequence *letters = [@<span class="string">"A B C D E F G H I"</span> componentsSeparatedByString:@<span class="string">" "</span>].rac_sequence;
RACSequence *numbers = [@<span class="string">"1 2 3 4 5 6 7 8 9"</span> componentsSeparatedByString:@<span class="string">" "</span>].rac_sequence;

// Contains: A B <span class="keyword">C</span> <span class="keyword">D</span> <span class="keyword">E</span> F G H <span class="keyword">I</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>
RACSequence *concatenated = [letters concat:numbers];
</pre></figure>

<h3 id="flattening">Flattening</h3>
<p>The [-flatten][RACStream] operator is applied to a stream-of-streams, and
combines their values into a single new stream.</p>
<p>Sequences are <a href="#concatenating">concatenated</a>:</p>
<figure class="highlight lang-objc"><pre>RACSequence *letters = [@<span class="string">"A B C D E F G H I"</span> componentsSeparatedByString:@<span class="string">" "</span>].rac_sequence;
RACSequence *numbers = [@<span class="string">"1 2 3 4 5 6 7 8 9"</span> componentsSeparatedByString:@<span class="string">" "</span>].rac_sequence;
RACSequence *sequenceOfSequences = @[ letters, numbers ].rac_sequence;

// Contains: A B <span class="keyword">C</span> <span class="keyword">D</span> <span class="keyword">E</span> F G H <span class="keyword">I</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>
RACSequence *flattened = [sequenceOfSequences flatten];
</pre></figure>

<p>Signals are <a href="#merging">merged</a>:</p>
<figure class="highlight lang-objc"><pre>RACSubject *letters = [RACSubject subject];
RACSubject *numbers = [RACSubject subject];
RACSignal *signalOfSignals = [RACSignal createSignal:^ RACDisposable * (<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:letters];
    [subscriber sendNext:numbers];
    [subscriber sendCompleted];
    <span class="keyword">return</span> <span class="literal">nil</span>;
}];

RACSignal *flattened = [signalOfSignals flatten];

<span class="comment">// Outputs: A 1 B C 2</span>
[flattened subscribeNext:^(<span class="built_in">NSString</span> *x) {
    <span class="built_in">NSLog</span>(@<span class="string">"%@"</span>, x);
}];

[letters sendNext:@<span class="string">"A"</span>];
[numbers sendNext:@<span class="string">"1"</span>];
[letters sendNext:@<span class="string">"B"</span>];
[letters sendNext:@<span class="string">"C"</span>];
[numbers sendNext:@<span class="string">"2"</span>];
</pre></figure>

<h3 id="mapping-and-flattening">Mapping and flattening</h3>
<p><a href="#flattening">Flattening</a> isn&#39;t that interesting on its own, but understanding
how it works is important for [-flattenMap:][RACStream].</p>
<p><code>-flattenMap:</code> is used to transform each of a stream&#39;s values into <em>a new
stream</em>. Then, all of the streams returned will be flattened down into a single
stream. In other words, it&#39;s <a href="#mapping">-map:</a> followed by <a href="#flattening">-flatten</a>.</p>
<p>This can be used to extend or edit sequences:</p>
<figure class="highlight lang-objc"><pre>RACSequence *numbers = [@<span class="string">"1 2 3 4 5 6 7 8 9"</span> componentsSeparatedByString:@<span class="string">" "</span>]<span class="variable">.rac_sequence</span>;

<span class="comment">// Contains: 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9</span>
RACSequence *extended = [numbers flattenMap:^(<span class="built_in">NSString</span> *num) {
    <span class="keyword">return</span> @[ num, num ]<span class="variable">.rac_sequence</span>;
}];

<span class="comment">// Contains: 1_ 3_ 5_ 7_ 9_</span>
RACSequence *edited = [numbers flattenMap:^(<span class="built_in">NSString</span> *num) {
    <span class="keyword">if</span> (num<span class="variable">.intValue</span> % <span class="number">2</span> == <span class="number">0</span>) {
        <span class="keyword">return</span> [RACSequence empty];
    } <span class="keyword">else</span> {
        <span class="built_in">NSString</span> *newNum = [num stringByAppendingString:@<span class="string">"_"</span>];
        <span class="keyword">return</span> [RACSequence <span class="keyword">return</span>:newNum]; 
    }
}];
</pre></figure>

<p>Or create multiple signals of work which are automatically recombined:</p>
<figure class="highlight lang-objc"><pre>RACSignal *letters = [@<span class="string">"A B C D E F G H I"</span> componentsSeparatedByString:@<span class="string">" "</span>]<span class="variable">.rac_sequence</span><span class="variable">.signal</span>;

[[letters
    flattenMap:^(<span class="built_in">NSString</span> *letter) {
        <span class="keyword">return</span> [database saveEntriesForLetter:letter];
    }]
    subscribeCompleted:^{
        <span class="built_in">NSLog</span>(@<span class="string">"All database entries saved successfully."</span>);
    }];
</pre></figure>

<h2 id="combining-signals">Combining signals</h2>
<p>These operators combine multiple signals into a single new [RACSignal][].</p>
<h3 id="sequencing">Sequencing</h3>
<p>[-then:][RACSignal+Operations] starts the original signal,
waits for it to complete, and then only forwards the values from a new signal:</p>
<figure class="highlight lang-objc"><pre>RACSignal *letters = [@<span class="string">"A B C D E F G H I"</span> componentsSeparatedByString:@<span class="string">" "</span>].rac_sequence.<span class="keyword">signal</span>;

<span class="comment">// The new signal only contains: 1 2 3 4 5 6 7 8 9</span>
<span class="comment">//</span>
<span class="comment">// But when subscribed to, it also outputs: A B C D E F G H I</span>
RACSignal *sequenced = [[letters
    doNext:^(NSString *letter) {
        NSLog(@<span class="string">"%@"</span>, letter);
    }]
    then:^{
        <span class="keyword">return</span> [@<span class="string">"1 2 3 4 5 6 7 8 9"</span> componentsSeparatedByString:@<span class="string">" "</span>].rac_sequence.<span class="keyword">signal</span>;
    }];
</pre></figure>

<p>This is most useful for executing all the side effects of one signal, then
starting another, and only returning the second signal&#39;s values.</p>
<h3 id="merging">Merging</h3>
<p>The [+merge:][RACSignal+Operations] method will forward the values from many
signals into a single stream, as soon as those values arrive:</p>
<figure class="highlight lang-objc"><pre>RACSubject *letters = [RACSubject subject];
RACSubject *numbers = [RACSubject subject];
RACSignal *merged = [RACSignal merge:@[ letters, numbers ]];

<span class="comment">// Outputs: A 1 B C 2</span>
[merged subscribeNext:^(<span class="built_in">NSString</span> *x) {
    <span class="built_in">NSLog</span>(@<span class="string">"%@"</span>, x);
}];

[letters sendNext:@<span class="string">"A"</span>];
[numbers sendNext:@<span class="string">"1"</span>];
[letters sendNext:@<span class="string">"B"</span>];
[letters sendNext:@<span class="string">"C"</span>];
[numbers sendNext:@<span class="string">"2"</span>];
</pre></figure>

<h3 id="combining-latest-values">Combining latest values</h3>
<p>The [+combineLatest:][RACSignal+Operations] and <code>+combineLatest:reduce:</code> methods
will watch multiple signals for changes, and then send the latest values from
<em>all</em> of them when a change occurs:</p>
<figure class="highlight lang-objc"><pre>RACSubject *letters = [RACSubject subject];
RACSubject *numbers = [RACSubject subject];
RACSignal *combined = [RACSignal
    combineLatest:@[ letters, numbers ]
    reduce:^(<span class="built_in">NSString</span> *letter, <span class="built_in">NSString</span> *number) {
        <span class="keyword">return</span> [letter stringByAppendingString:number];
    }];

<span class="comment">// Outputs: B1 B2 C2 C3</span>
[combined subscribeNext:^(<span class="keyword">id</span> x) {
    <span class="built_in">NSLog</span>(@<span class="string">"%@"</span>, x);
}];

[letters sendNext:@<span class="string">"A"</span>];
[letters sendNext:@<span class="string">"B"</span>];
[numbers sendNext:@<span class="string">"1"</span>];
[numbers sendNext:@<span class="string">"2"</span>];
[letters sendNext:@<span class="string">"C"</span>];
[numbers sendNext:@<span class="string">"3"</span>];
</pre></figure>

<p>Note that the combined signal will only send its first value when all of the
inputs have sent at least one. In the example above, <code>@&quot;A&quot;</code> was never
forwarded because <code>numbers</code> had not sent a value yet.</p>
<h3 id="switching">Switching</h3>
<p>The [-switchToLatest][RACSignal+Operations] operator is applied to
a signal-of-signals, and always forwards the values from the latest signal:</p>
<figure class="highlight lang-objc"><pre>RACSubject *letters = [RACSubject subject];
RACSubject *numbers = [RACSubject subject];
RACSubject *signalOfSignals = [RACSubject subject];

RACSignal *switched = [signalOfSignals switchToLatest];

<span class="comment">// Outputs: A B 1 D</span>
[switched subscribeNext:^(<span class="built_in">NSString</span> *x) {
    <span class="built_in">NSLog</span>(@<span class="string">"%@"</span>, x);
}];

[signalOfSignals sendNext:letters];
[letters sendNext:@<span class="string">"A"</span>];
[letters sendNext:@<span class="string">"B"</span>];

[signalOfSignals sendNext:numbers];
[letters sendNext:@<span class="string">"C"</span>];
[numbers sendNext:@<span class="string">"1"</span>];

[signalOfSignals sendNext:letters];
[numbers sendNext:@<span class="string">"2"</span>];
[letters sendNext:@<span class="string">"D"</span>];
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[IOS 开发之 CocoaPods讲解]]></title>
    <link href="http://hufeng825.github.com/2013/10/11/ios30/"/>
    <id>http://hufeng825.github.com/2013/10/11/ios30/</id>
    <published>2013-10-10T16:53:01.000Z</published>
    <updated>2013-10-10T17:28:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="-cocoapods-">什么是CocoaPods?</h2>
<p>看看你的项目吧,肯定会用到很多第三方的开源库,比如ASI,SBJson,MBProgressHUD等等.
<a id="more"></a></p>
<p>比如下面这款APP</p>
<img src="http://ww4.sinaimg.cn/mw690/a43af4ffjw1e9gkhrfkupj207g0bgdgc.jpg" width="200" height="300">



<p>用到的库就包含如下这样多 </p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e9gki1ovsqj205p09cgm3.jpg" width="200" height="300">


<p>随着你的工程越来越大,你引入的第三方的开源库可能会越来越多.这些依赖的开源库维护管理越久越来越困难.于是CocoaPods出现了,它可以帮助管理Xcode项目的依赖关系。(说到这做过java的同学应该想到了maven了吧).
你可以定义一个非常简单的文本来管理配置这些依赖 .</p>
<hr>
<h2 id="-">安装步骤</h2>
<h3 id="1-">1.前期工作</h3>
<p> 因为CocoaPods是基于Ruby的 介于天朝的特殊国情,你如果直接gem install 安装的话 肯定会遇到问题的所以首先你需要吧你的源换下. 换成什么呢?还是感谢下阿里吧.阿里给我们搭建了一个RubyGems 镜像.</p>
<blockquote>
<p>由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。所以你会与遇到 gem install rack 或 bundle install 的时候半天没有响应，具体可以用 gem install rails -V 来查看执行过程。
这是一个完整 rubygems.org 镜像，你可以用此代替官方版本，同步频率目前为15分钟一次以保证尽量与官方服务同步。</p>
</blockquote>
<pre><code>$ gem sources --remove https://rubygems.org/
$ gem sources -a http://ruby.taobao.org/
$ gem sources -l
*** CURRENT SOURCES ***

http://ruby.taobao.org
# 请确保只有 ruby.taobao.org
</code></pre><h3 id="2-">2.开始安装</h3>
<pre><code>$ [sudo] gem install cocoapods
$ pod setup    
</code></pre><hr>
<h2 id="-">如何使用</h2>
<h3 id="1-">1.创建配置文件</h3>
<p>首先在你的工程下(我创建的是CocoaPodsTest)创建一个空的Podfile文件,这个文件就是用来配置依赖的</p>
<pre><code>$ vi Podfile
</code></pre><h3 id="2-">2. 保存退出</h3>
<pre><code>$ wq
</code></pre><h3 id="3-pod">3. 安装 pod</h3>
<pre><code>$ pod install
</code></pre><p>如果成功后您会看到如下信息</p>
<img src="http://ww3.sinaimg.cn/mw690/a43af4ffjw1e9gkg71ll2j20dh06cq3y.jpg" width="300" height="200">


<p>并且在你的工程下如多出如下文件</p>
<img src="http://ww4.sinaimg.cn/mw690/a43af4ffjw1e9gkht6s51j205n048mxa.jpg">


<h3 id="4-">4. 查询确认你要引用的库</h3>
<p>比如我要引入SBJson 为了确认CocoaPods能不能导入这个库 我需要执行</p>
<pre><code>$ pod search SBJson
</code></pre><p>结果返回了如下信息 则证明可以引入</p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e9gkftzdavj20i104bq3r.jpg" width="350" height="300">


<h3 id="5-">5. 加入引入的库</h3>
<p>打开Podfile配置文件 加上如下内容保存</p>
<pre><code>platform :ios
pod &#39;SBJson&#39;
</code></pre><p>当然你也可以指定特定的版本 例如 
    pod &#39;SBJson&#39;, &#39;~&gt; 3.2&#39;</p>
<h3 id="6-">6. 保存更新</h3>
<pre><code>$ pod update
</code></pre><p>更新成功后出现如下信息</p>
<pre><code>Analyzing dependencies
Downloading dependencies
Installing SBJson (3.2)
Generating Pods project
Integrating client project 
</code></pre><p>打开CocoaPodsTest.xcworkspace  此刻会发现已经把我们想要的库下载好了
如图</p>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1e9gkhxhn3ej207109mwf0.jpg" width="300" height="400">



<p>6:设置Target头文件索引,第一次使用 需要配置下相应的头文件索引,不然他们虽然在一个工作区下 但是不在同一个项目中也无法直接使用 因此您需要
按着下图,进行相应的配置 </p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e9gkjbu1t8j20pu06qwfm.jpg">


<p>7:ok 大功告成 以后你只要更执行如下命令 就可以更新你引入的所有第三方库了</p>
<pre><code>$ pod update
</code></pre><hr>
<p>更详细的内容可以看下cocoapods的官网哈.
<a href="http://docs.cocoapods.org/guides/getting_started.html" target="_blank">http://docs.cocoapods.org/guides/getting_started.html</a></p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ios开发之你真的了解了KVC吗？]]></title>
    <link href="http://hufeng825.github.com/2013/09/23/ios33/"/>
    <id>http://hufeng825.github.com/2013/09/23/ios33/</id>
    <published>2013-09-23T10:51:01.000Z</published>
    <updated>2014-01-14T03:23:37.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>之前一直以为自己了解KVC 其实只是井底之蛙啦，真正的要把KVC原原本本的说出来还真的不是一件简单的事情。于是今天写下这边文章，告诫自己要知其然还要知其所以然。
<a id="more"></a></p>
</blockquote>
<h2 id="-kvc-">一.KVC的基本概念</h2>
<p>Key-value coding,它是一种使用字符串标识符，间接访问对象属性的机制,而不是直接调用getter 和 setter方法。通常我们使用valueForKey 来替代getter 方法，setValue:forKey来代替setter方法。</p>
<p>下面是使用KVC 和 不使用 KVC的代码对比</p>
<pre><code>Persion *persion =  [ [Persion alloc] init ];

//不使用KVC
persion.name = @&quot;hufeng&quot; ;

//使用KVC的写法
[persion  setValue:@&quot;hufeng&quot; forKey:@&quot;name&quot;];
</code></pre><p>看出区别来了吗？你可能会说 你写的太简单了，我们实际用的时候不可能有这样复杂的类，下面我们写个复杂点的：我们有一个人 这个人有一个手机类 这个手机类 有一个电池类 我们要获取这个电池类 比之前复杂了吧。</p>
<p>没有KVC </p>
<pre><code>Persion *persion =  [ [Persion alloc] init ];

Phone *phone = persion.phone;

Battery *battery = phone.battery;
</code></pre><p>使用KVC</p>
<pre><code>Battery *battery = [persion valueForKeyPath: @&quot;phone.battery&quot; ];
</code></pre><p><strong>注意- valueForKeyPath 里面的值是区分大小写的，你如果写出Phone.Battery 是不行的 </strong></p>
<p>说到这里你可能会问 我能不能对 NSArray 调用KVC吗？ 答案是否定的，因为array 没有keys啊，但是你可以对array里面的item 使用KVC。</p>
<p>KVC 最常用的还是在序列化和反序列话对象。我们经常需要把json字符串反序列化成我们想要的对象 下面是一个例子 将字典用NSKeyedArchiver 序列化成对象</p>
<pre><code>- (id)initWithDictionary:(NSDictionary *)dictionary {

    self = [self init];

    if (self){

        [self setValuesForKeysWithDictionary:dictionary];

    }

    return self;

}
</code></pre><p><strong>注意 这里有一个坑 当我们setValue 给一个没有定义的字典值（forUndefinedKey）时 会抛出NSUndefinedKeyException异常的 记的处理此种情况</strong></p>
<p>还有一个需要注意的是KVC 并没有类型检验，毕竟Object-C 还是动态的啦。 还是看下面的代码吧</p>
<pre><code>[persion setValue:[NSNumber numberWithInteger:1] forKey:@&quot;name&quot;]; 
// compiles and runs

persion.name = [NSNumber numberWithInteger:1]; 
// won&#39;t compile: Incompatible pointer types assigning to &#39;NSString *&#39; from &#39;NSNumber *&#39;
</code></pre><p>setValue forKey 得到的对象是泛型的id， 只有在使用的时候才能确定类型。你可能会问不至于吧 OC 这样弱啊，当然不是 OC 提供了了一个方法validateValue来解决这个问题 </p>
<pre><code>@property (nonatomic, strong) NSString name;

- (BOOL)validateName:(id*)ioValue error:(NSError**)error {
    // Validation logic goes here

}

Person *p = [Person new];

NSString *name = @&quot;Jason Hu&quot;;

NSError *error = nil;


// This call below actually calls our validateName: error: method

if ([p validateValue:&amp;name forKey:@&quot;name&quot; error:&amp;error]) {

    [p setValue:name forKey:@&quot;name&quot;];
}
</code></pre><p>你可能会问写这样多代码 才只验证了一个属性 那如果我这个类有n+个属性 难道我要写n+个验证方法吗？</p>
<hr>
<h2 id="-kvc-">二.KVC 验证</h2>
<p>到这里我们对KVC已经有了一个初步印象，到这里其实还只是冰山一角。
下面我们要提高更高的要求，如果让key 支持 不区分大小写</p>
<p>下面我们提到一个方法initialize</p>
<p>initialize是在类或者其子类的第一个方法被调用前调用。所以如果类没有被引用进项目或者类文件被引用进来，但是没有使用，那么initialize也不会被调用 ，到这里 知道我们接下来要干嘛了吧</p>
<pre><code>+ (void)initialize {
    [super initialize];

    dispatch_once(&amp;onceToken, ^{
        modelProperties = [NSMutableDictionary dictionary];
        propertyTypesArray = @[/* removed for brevity */];
    });
    NSMutableDictionary *translateNameDict = [NSMutableDictionary dictionary];
    [self hydrateModelProperties:[self class] translateDictionary:translateNameDict];
    [modelProperties setObject:translateNameDict forKey:[self calculateClassName]];
}

+ (void)hydrateModelProperties:(Class)class translateDictionary:(NSMutableDictionary *)translateDictionary {
    if (!class || class == [NSObject class]){
        return;
    }

    unsigned int outCount, i;
    objc_property_t *properties = class_copyPropertyList(class, &amp;outCount);
    for (i = 0; i &lt; outCount; i++){
        objc_property_t p = properties[i];
        const char *name = property_getName(p);
        NSString *nsName = [[NSString alloc] initWithCString:name encoding:NSUTF8StringEncoding];
        NSString *lowerCaseName = [nsName lowercaseString];
        [translateDictionary setObject:nsName forKey:lowerCaseName];
        //注意此处哦
        NSString *propertyType = [self getPropertyType:p];
        [self addValidatorForProperty:nsName type:propertyType];
    }
    free(properties);

    [self hydrateModelProperties:class_getSuperclass(class) translateDictionary:translateDictionary];
}
</code></pre>]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ios7之Sprite Kit vs Cocos2D]]></title>
    <link href="http://hufeng825.github.com/2013/09/22/ios29/"/>
    <id>http://hufeng825.github.com/2013/09/22/ios29/</id>
    <published>2013-09-22T11:50:03.000Z</published>
    <updated>2013-09-22T15:01:50.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Xcode5正式版发布了，全新的ui当然带来了全新的功能。今天阿峰就给大家来介绍下Sprite Kit。</p>
</blockquote>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1e8vnf9f1k4j20jt0d3abu.jpg" class="center 500 400">


<a id="more"></a> 

<h2 id="-sprite-kit">一、什么是Sprite Kit</h2>
<p>打开app store 下载最多的的是2D 游戏。比较有名比如 愤怒的小鸟 割绳子啦。 这些游戏之所以能够如此受欢迎跟他们 出色的粒子特效 物理引擎 炫酷的动画 还有漂亮的界面和声音效果离不开。</p>
<p>在ios7 发布之前 想要做出这样的游戏 只能依靠第三方的游戏引擎库，比较有名的就是Cocos2d 以及衍生的Cocos2d-X。现在ios7发布了 我们可以不借助第三方工具就可以实现了。Sprite Kit 提供了 包括 动画精灵，形状，粒子（火焰，烟雾），动画，物理效果，音频 视频等。Xcode5 还提供支持了纹理包和粒子设计哦。</p>
<p>Sprite Kit 可以在逻辑上分为以下的三个部分</p>
<h3 id="scenes-">Scenes(场景)</h3>
<p>在cocos2d的游戏场景的视觉层。他提供了物体（如树木，汽车，飞机，头像等）的背景。</p>
<h3 id="actions-">Actions(动作)</h3>
<p>流畅的动画是游戏的重要组成部分。苹果设计的Actions非常简洁。他可以让你实现你想要做的任何事情。比如说一些常见的动作:移动 淡入淡出 缩放 旋转 动画纹理 组动画等等。 如果这些你还不满足，你可以自己创建一个代码块来实现自己想要的动作来操控对象。</p>
<h3 id="physics-">Physics(物理引擎)</h3>
<p>你想让你一个游戏具有很强的现实感，那物理引擎你一定用的到。 不然射出的子弹永远不会落地，橡胶球落地不会弹起来哈。</p>
<hr>
<h2 id="-sprite-kit-">二、选择Sprite Kit的理由</h2>
<h3 id="-">性能</h3>
<p>苹果自家推出的东西在自家平台上肯定有着得天独厚的优势（尽管很多游戏开发商需要让他们的游戏在不同的系统上运行）。但是苹果在系统和硬件上累计的经验足够说服开发商选用自家的游戏引擎了。</p>
<h3 id="-">平台集成</h3>
<p>如上所述。Sprite Kit 跟Xcode 5 集成的天衣无缝。Xcode5 为游戏提供了很多开发组件。</p>
<h3 id="-">版本升级</h3>
<p>使用第三方库或者游戏引擎编写游戏肯定会有这方面的担忧。我们永远不知道将来的对系统的兼容性如何。不如说已死的Tree20 等等。 ios 每出一个版本都会有API的变动。虽然会有开源社区对其第三方库进行维护 但是这需要时间哈。用苹果自家的东西 就不用担心这方面了。</p>
<p>随着Sprite Kit的退出。苹果已经提供了一套工具，以确保开发的游戏代码能够在任何苹果版本和机型正常运行。 注意的是Sprite Kit 并不只是ios的框架。 开发人员也可以来开发OS X 上的游戏。</p>
<h3 id="-">友好的开发接口</h3>
<p>cocos2d之所以成功离不开其较低的门槛。相比起OpenGL ES 那些晦涩的接口 恼人的实现来说cocos2d ,简直太方便了。</p>
<p>Sprite Kit遵循了这点。其提供的接口非常简洁方便。另外其文档也非常详细 设计工具也很棒。甚至连cocos2d的首席开发工程师也在”此处和谐 国外被墙聊天工具“上感慨说</p>
<blockquote>
<p>prite Kit is very good. With less features than Cocos2D, but better. I like the physics integration.</p>
</blockquote>
<hr>
<h2 id="-sprite-kit-cocos2d-features">三、Sprite Kit &amp; Cocos2D Features</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>Sprite Kit</th>
<th>Cocos2D</th>
</tr>
</thead>
<tbody>
<tr>
<td>Open Source</td>
<td><code>No</code></td>
<td>Yes</td>
</tr>
<tr>
<td>Objective-C  Native Support</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Graphics Engine</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Animations</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Physics Simulation</td>
<td>Yes (Integrated)</td>
<td><code>No (Requires Box2D or Chipmunk)</code></td>
</tr>
<tr>
<td>Particle Effects</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Xcode Native Integration</td>
<td>Yes</td>
<td><code>No</code></td>
</tr>
<tr>
<td>Automatic Atlas Creation</td>
<td>Yes</td>
<td><code>No</code></td>
</tr>
<tr>
<td>Built-In Particle Editor</td>
<td>Yes</td>
<td><code>No</code></td>
</tr>
<tr>
<td>Shaders</td>
<td><code>No</code></td>
<td>Yes</td>
</tr>
<tr>
<td>Camera</td>
<td><code>No</code></td>
<td>Yes</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-">四、项目对比</h2>
<p>对比 Sprite Kit  和  Cocos2D 区别 还是看代码比较合适
<a href="http://cdn.tutsplus.com/mobile.tutsplus.com/uploads/2013/09/ios7SpriteKit.zip" target="_blank">Sprite Kit 工程</a>
<a href="http://cdn.tutsplus.com/mobile.tutsplus.com/uploads/2013/09/ios7cocos2d.zip" target="_blank">Cocos2D 工程</a></p>
<h2 id="-">五、代码比较</h2>
<p>下面我们将从概念上来比较两者的不同</p>
<h3 id="cclayer-vs-skscene">CClayer vs. SKScene</h3>
<p>CCLayer或SkScene 是最主要的对象用来绘制其他的对象。 你可以把他想象成默认的一个view，这个view 可以接收所有的对象，动画或者touch 事件。</p>
<p>在Cocos2d进行场景切换 需要下面几步：</p>
<pre><code>GameScene* gameScene = [[GameScene alloc] init];
[ [CCDirector sharedDirector] replaceScene:gameScene ];
</code></pre><p>注意GameScene.h 中 必须继承CCLayer 且初始化一个CCScene</p>
<pre><code>@interface GameScene : CCLayer {}
+(CCScene *) scene;
</code></pre><p>在 GameScene.m, 初始化:</p>
<pre><code>+(CCScene *)scene
{
    CCScene *scene = [CCScene node];
    GameScene *layer = [GameScene node];
    [scene addChild: layer];
    return scene;
}
-(id) init{
    if( (self=[super init] )) {
        // Your code here
    }
    return self;
}
</code></pre><p>在 Sprite Kit 中只需要如下</p>
<pre><code>GameScene* gameScene = [ [GameScene alloc] initWithSize:CGSizeMake(1024, 768) ];
[ self.scene.view presentScene:gameScene ];
}
</code></pre><p>GameScene 必须继承 SKScene , 调用如下 -(id)initWithSize:(CGSize)size 初始化:</p>
<pre><code>-(id)initWithSize:(CGSize)size
{
    if (self = [super initWithSize:size])
    {
        // Your code
    }
    return self;
}
</code></pre><h3 id="ccsprite-vs-skspritenode">CCSprite vs. SKSpriteNode</h3>
<p>精灵对象通常用来显示某种图形。他有如下几种属性：旋转 缩放 位移 框架 等等。Cocos2D 实现如下：</p>
<pre><code>CCSprite* aSprite;
aSprite = [CCSprite spriteWithFile:@&quot;player.png&quot;];
aSprite.scale = .5;
aSprite.position = ccp(_size.width/1.30, _size.height/1.25);
[self addChild:aSprite];
</code></pre><p>Sprite Kit 实现如下：</p>
<pre><code>SKSpriteNode* planeShadow = [SKSpriteNode spriteNodeWithImageNamed:@&quot;player.png&quot;];
planeShadow.scale = 0.5;
planeShadow.position = CGPointMake(CGRectGetMidX(self.frame)+100,CGRectGetMidY(self.frame)+200);
[self addChild:planeShadow];
</code></pre><h3 id="cclabelttf-vs-sklabelnode">CCLabelTTF vs. SKLabelNode</h3>
<p>Label对象用于显示文字。它可以有几个属性，包括文字，文字大小，文字颜色，位置等等。Cocos2D和Sprite Kit是相似的。
Cocos2D：</p>
<pre><code>CCLabelTTF *label = [CCLabelTTF labelWithString:@&quot;Hello World&quot; fontName:@&quot;Marker Felt&quot; fontSize:64];
// ask director for the window size
CGSize size = [[CCDirector sharedDirector] winSize];
label.position =  ccp( size.width /2 , size.height/2 );
[self addChild: label];
</code></pre><p>Sprite Kit:</p>
<pre><code>SKLabelNode* gameScene = [SKLabelNode labelNodeWithFontNamed:@&quot;Chalkduster&quot;];
[gameScene setText:@&quot;New Game&quot;];
[gameScene setFontSize:18];
gameScene setPosition:CGPointMake(CGRectGetMidX(self.frame)+5,CGRectGetMidY(self.frame)-40)];
[self addChild:gameScene];
</code></pre><h3 id="ccmenu-and-ccmenuitem-vs-sprite-kit-menu">CCMenu and CCMenuItem vs. Sprite Kit Menu</h3>
<p>Cocos2D中创建菜单需要两个对象：CCMenu 和 CCMenuItem. 下面是创建两个菜单项的例子</p>
<pre><code>CGSize size = [[CCDirector sharedDirector] winSize];
[CCMenuItemFont setFontSize:28];
CCMenuItem *itemNewGame = [CCMenuItemFont itemWithString:@&quot;New Game&quot; block:^(id sender) {
    // Your code
}];
CCMenuItem *itemOptions = [CCMenuItemFont itemWithString:@&quot;Options&quot; block:^(id sender) {
    NSLog(@&quot;Second item&quot;);
}];
CCMenu *menu = [CCMenu menuWithItems:itemNewGame, itemOptions, nil];
[menu alignItemsHorizontallyWithPadding:20];
[menu setPosition:ccp( size.width/2, size.height/2 - 50)];
[self addChild:menu];
</code></pre><p>Spite Kit不包括任何类型的菜单的特定对象。
下面的例子我们用了 SKLabelNode作为 menu item. 首先我们定义 SKLabelNode:</p>
<pre><code>SKLabelNode*  gameScene = [SKLabelNode labelNodeWithFontNamed:@&quot;Chalkduster&quot;];
[gameScene setText:@&quot;New Game&quot;];
[gameScene setFontSize:18];
[gameScene setPosition:CGPointMake(CGRectGetMidX(self.frame)+5,CGRectGetMidY(self.frame)-40)];
[self addChild:gameScene];
</code></pre><p>在 <strong>-(void)touchesBegan:(NSSet <em>)touches withEvent:(UIEvent </em>)event</strong> 方法里面 我们创建截获事件</p>
<pre><code>for (UITouch *touch in touches)
{
    CGPoint location = [touch locationInNode:self];
    if ([gameScene containsPoint:location]) {
        // Scene Transition Animation
        SKTransition* reveal = [SKTransition revealWithDirection:SKTransitionDirectionDown duration:1];
        GameScene* gameScene = [[GameScene alloc] initWithSize:CGSizeMake(1024, 768)];
        [self.scene.view presentScene:gameScene transition:reveal];
        NSLog(@&quot;Touched gameScene!!!!&quot;);
    }
} 
</code></pre><p>上面代码做了下面几件事情</p>
<ol>
<li>激活触摸时间</li>
<li>将敲击的坐标转换成内部坐标</li>
<li>验证敲击的坐标是否在SKLabelNode的动画场景内</li>
<li>创建过渡动画</li>
<li>转换场景</li>
</ol>
<h3 id="action-vs-skaction">Action vs. SKAction</h3>
<p>区别最大的是Action 。SKAction是一个较复杂的对象。Action在Cocos2D 仅仅是一个动作。程序员必须定义 调用 创建。 
但是Sprite Kit中，SKAction 提供了如下的开发比如旋转 缩放 重复, 消失 播放声音 等等。 SKaction是一个抽象类能够处理任何种类的动作。
在cocos2d 我们需要定义一个调节调用的自定义方法
    [self schedule:@selector(addSprite:) interval:1];
然后在自定义的方法中添加我们自定义的动画:</p>
<pre><code>- (void) addSprite:(ccTime)dt
{
    CCSprite* aMovableSprite = [CCSprite spriteWithFile:@&quot;frankenstein.png&quot;];
    aMovableSprite.scale = .8;
    [self addChild:aMovableSprite];
    CGSize winSize = [CCDirector sharedDirector].winSize;
    int minX = aMovableSprite.contentSize.width / 2;
    int maxX = winSize.width - aMovableSprite.contentSize.width/2;
    int rangeX = maxX - minX;
    int actualY = (arc4random() % rangeX) + minX;
    CCCallBlockN * actionMoveDone = [CCCallBlockN actionWithBlock:^(CCNode *node) {
        NSLog(@&quot;Sprite free!&quot;);
    }];
    NSMutableArray *arrayBezier = [[NSMutableArray alloc] init];
    ccBezierConfig bezier;
    id bezierAction1;
    float splitDuration = 6 / 6.0;
    for(int i = 0; i&lt; 6; i++){
        if(i % 2 == 0){
            bezier.controlPoint_1 = ccp(actualY+100,winSize.height-(100+(i*200)));
            bezier.controlPoint_2 = ccp(actualY+100,winSize.height-(100+(i*200)));
            bezier.endPosition = ccp(actualY,winSize.height-(200+(i*200)));
            bezierAction1 = [CCBezierTo actionWithDuration:splitDuration bezier:bezier];
        }
        else{
            bezier.controlPoint_1 = ccp(actualY-100,winSize.height-(100+(i*200)));
            bezier.controlPoint_2 = ccp(actualY-100,winSize.height-(100+(i*200)));
            bezier.endPosition = ccp(actualY,winSize.height-(200+(i*200)));
            bezierAction1 = [CCBezierTo actionWithDuration:splitDuration bezier:bezier];
        }
        [arrayBezier addObject:bezierAction1];
    }
    [arrayBezier addObject:actionMoveDone];
    id seq = [CCSequence actionsWithArray:arrayBezier];
    [aMovableSprite runAction:seq];
}
</code></pre><p>在Sprite Kit中 我们使用SKAction来控制对象开始和结束的运行状况</p>
<pre><code>SKSpriteNode* playerSprite = [SKSpriteNode spriteNodeWithImageNamed:@&quot;player.png&quot;];
[playerSprite setScale:0.4];
SKAction *movement =[SKAction moveTo:CGPointMake(900, 500) duration:5];
SKAction *remove = [SKAction removeFromParent];
[playerSprite runAction:[SKAction sequence:@[movement,remove]]];
[self addChild:playerSprite];
</code></pre><p>但是我们定义一个自定义的动画然后用SKAction来激活这个动作。下面的例子说明了贝塞尔运动。</p>
<pre><code>SKAction *wait = [SKAction waitForDuration:1];
SKAction *callEnemies = [SKAction runBlock:^{
    [self sendNewSKSpriteNode];
}];
SKAction *updateSKSpriteNodeOnScreen = [SKAction sequence:@[wait,callEnemies]];
[self runAction:[SKAction repeatActionForever:updateSKSpriteNodeOnScreen]]; 
</code></pre><p>下面的sendNewSKSpriteNode将处理自定义对象的运动。</p>
<pre><code>-(void) sendNewSKSpriteNode{
    CGRect screenRect = [[UIScreen mainScreen] bounds];
    // Custom SKAction
    SKSpriteNode* enemy = [SKSpriteNode spriteNodeWithImageNamed:@&quot;frankenstein.png&quot;];
    enemy.scale = 0.6;
    CGMutablePathRef cgpath = CGPathCreateMutable();
    //random values
    float xStart = [self getRandomNumberBetween:0+enemy.size.width to:screenRect.size.width-enemy.size.width ];
    float xEnd = [self getRandomNumberBetween:0+enemy.size.width to:screenRect.size.width-enemy.size.width ];
    //ControlPoint1
    float cp1X = [self getRandomNumberBetween:0+enemy.size.width to:screenRect.size.width-enemy.size.width ];
    float cp1Y = [self getRandomNumberBetween:0+enemy.size.width to:screenRect.size.width-enemy.size.height ];
    //ControlPoint2
    float cp2X = [self getRandomNumberBetween:0+enemy.size.width to:screenRect.size.width-enemy.size.width ];
    float cp2Y = [self getRandomNumberBetween:0 to:cp1Y];
    CGPoint s = CGPointMake(xStart, 1024.0);
    CGPoint e = CGPointMake(xEnd, -100.0);
    CGPoint cp1 = CGPointMake(cp1X, cp1Y);
    CGPoint cp2 = CGPointMake(cp2X, cp2Y);
    CGPathMoveToPoint(cgpath,NULL, s.x, s.y);
    CGPathAddCurveToPoint(cgpath, NULL, cp1.x, cp1.y, cp2.x, cp2.y, e.x, e.y);
    SKAction *planeDestroy = [SKAction followPath:cgpath asOffset:NO orientToPath:YES duration:5];
    [self addChild:enemy];
    SKAction *remove2 = [SKAction removeFromParent];
    [enemy runAction:[SKAction sequence:@[planeDestroy,remove2]]];
    CGPathRelease(cgpath);
}
</code></pre><h3 id="ccparticleexplosion-vs-emitter">CCParticleExplosion vs. Emitter</h3>
<p>Cocos2D中并没例子编辑器。必须使用外部应用程序创建例子 然后用特定的 CCParticleExplosion来改变其属性行为。在xcode中 你可以这样子来使用了:</p>
<pre><code>CCParticleExplosion* _particleExplosion;
particleExplosion = [[CCParticleExplosion alloc] initWithTotalParticles:800];
particleExplosion.texture = [[CCTextureCache sharedTextureCache] addImage:@&quot;texture.png&quot;];
particleExplosion.life = 0.0f;
particleExplosion.lifeVar = 0.708f;
particleExplosion.startSize = 40;
particleExplosion.startSizeVar = 38;
particleExplosion.endSize = 14;
particleExplosion.endSizeVar = 0;
particleExplosion.angle = 360;
particleExplosion.angleVar = 360;
particleExplosion.speed = 243;
particleExplosion.speedVar = 1;
CGPoint g = CGPointMake(1.15, 1.58);
particleExplosion.gravity = g;
ccColor4F startC =  {0.89f, 0.56f, 0.36f, 1.0f};
particleExplosion.startColor = startC;
ccColor4F endC = {1.0f,0.0f,0.0f,1.0f};
particleExplosion.endColor = endC;
[self addChild:_particleExplosion];
particleExplosion.position = ccp(_size.width/5, _size.height/5);
[particleExplosion resetSystem];
</code></pre><p>发射器使用Sprite Kite粒子套件产生。 为了使用他们 你需要在项目中添加粒子。New -&gt; File -&gt; Resource -&gt; Sprite Kit Particle File 命名并且选择粒子类型（火 烟 雪 等等）。
如下图</p>
<img src="http://ww3.sinaimg.cn/mw690/a43af4ffjw1e8vnfhjmlgj20en07a3yz.jpg" width="400" height="500">


<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e8vnflpm16j206o05ft8q.jpg" width="300" height="500">


<p> 现在你会看到有两个新文件在xcode 中：</p>
<img src="http://ww4.sinaimg.cn/mw690/a43af4ffjw1e8vnls9m7bj203q018a9v.jpg" class="200 300">



<pre><code>SKEmitterNode* smokeTrail;
NSString *smokePath = [[NSBundle mainBundle] pathForResource:@&quot;MyParticle&quot; ofType:@&quot;sks&quot;];
smokeTrail = [NSKeyedUnarchiver unarchiveObjectWithFile:smokePath];
smokeTrail.position = CGPointMake(CGRectGetMidX(self.frame)+40,CGRectGetMidY(self.frame)-100);
[self addChild:smokeTrail];
</code></pre><h3 id="simpleaudioengine-vs-sprite-kit-sound">SimpleAudioEngine vs. Sprite Kit Sound</h3>
<p>任何游戏应该都离不开多媒体吧，在cocos2d 我们要实现 需要两部
1：</p>
<pre><code>#import &quot;SimpleAudioEngine.h&quot;
</code></pre><p>2：</p>
<pre><code>[[SimpleAudioEngine sharedEngine] playBackgroundMusic:@&quot;sound.caf&quot; loop:YES];
[[SimpleAudioEngine sharedEngine] setEffectsVolume:0.4f];
</code></pre><p><strong>有时，Xcode中并没有自动包括“Copy Bundle Resources”中的音乐文件。如果发生这种情况，你应该手动添加。</strong></p>
<p>在Sprite Kit中 你能够很简单的添加声音</p>
<pre><code>SKAction* soundAction = [SKAction playSoundFileNamed:@&quot;preview.mp3&quot; waitForCompletion:NO];
[self runAction:soundAction];
</code></pre><p>下面是实现的一个火焰效果图</p>
<img src="http://ww4.sinaimg.cn/mw690/a43af4ffjw1e8vnfvcmmdj20d80k8jro.jpg" width="200" height="400">


<h2 id="-">结束语</h2>
<p>通过上面的分析 你会发现cocos2d 和Sprite kit 有很多相似之处。在易用性上 笔者觉得Spring kit 对ios开发者来说更加具有诱惑性。</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ios开发之MPNowPlayingInfoCenter 锁屏显示正在播放的音乐]]></title>
    <link href="http://hufeng825.github.com/2013/09/18/ios28/"/>
    <id>http://hufeng825.github.com/2013/09/18/ios28/</id>
    <published>2013-09-18T15:43:50.000Z</published>
    <updated>2013-09-18T17:33:56.000Z</updated>
    <content type="html"><![CDATA[<p>今天在床上玩唱吧,听着歌锁屏了,当点亮屏幕的时候,锁屏页面出现了我正在听得歌曲 壁纸也换成了唱吧里面的歌手图片.做ios好几年了,从没有做过这个需求 于是好奇就翻看ios的<a href="https://developer.apple.com/library/ios/documentation/mediaplayer/reference/MPNowPlayingInfoCenter_Class/Reference/Reference.html" target="_blank">API文档</a>找到了这个类.
<a id="more"></a>
如下图</p>
<img src="http://ww3.sinaimg.cn/mw690/a43af4ffjw1e8r3az0tbaj20g50litai.jpg" width="300" height="600">


<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e8r3b00x7aj20gj05wq3e.jpg" width="300" height="200">



<h2 id="mpnowplayinginfocenter-">MPNowPlayingInfoCenter 解释</h2>
<blockquote>
<p>即时播放中心能够用于播放APP中正在播放的媒体信息.
播放的信息会显示在锁屏页面和多任务管理页面.如果用户是用airplay播放的话 会自动投射到相应的设备上.</p>
</blockquote>
<p><a href="https://github.com/hufeng825/LockScreenInfo.git" target="_blank">下载源码</a></p>
<h2 id="-">开始动手</h2>
<h3 id="-app-">让App支持后台运行</h3>
<p>先创建工程,因为是audio 类型的app 需要支持后台播放 所以得要在plist 中声明属性.
添加如下属性</p>
<p>Required background modes -&gt; App plays audio
如下图</p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e8r45ojlcuj20l80a2q4l.jpg" class="left" width="300" height="400">


<h3 id="-frame">添加播放的Frame</h3>
<ol>
<li>AVFoundation.framework</li>
<li>MediaPlayer.framework</li>
</ol>
<img src="http://ww3.sinaimg.cn/mw690/a43af4ffjw1e8r4757worj208c03vq2z.jpg" class="left" width="300" height="400">



<h3 id="-">开始代码吧</h3>
<p>首先创建一个ViewController 和一个用于播放的按钮 playButton</p>
<pre><code>@interface ViewController : UIViewController {

IBOutlet UIButton *playButton;

}

@property (nonatomic, retain) IBOutlet UIButton *playButton;

-(IBAction)playButtonPress:(id)sender;
</code></pre><p>加入播放用的控件audioPlayer 和其相应的头文件</p>
<pre><code>#import &lt;MediaPlayer/MPNowPlayingInfoCenter.h&gt;
#import &lt;MediaPlayer/MPMediaItem.h&gt;
#import &lt;AVFoundation/AVFoundation.h&gt;
MPMoviePlayerController *audioPlayer;

@property (nonatomic, retain) MPMoviePlayerController *audioPlayer;

@synthesize playButton, audioPlayer;
</code></pre><p>在viewDidLoad 中 我们要把AudioPlayer 进行初始化 此处加载网络上的一首音频</p>
<pre><code>[[AVAudioSession sharedInstance] setDelegate: self];

NSError *myErr;

// Initialize the AVAudioSession here.
if (![[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:&amp;myErr]) {
    // Handle the error here.
    NSLog(@&quot;Audio Session error %@, %@&quot;, myErr, [myErr userInfo]);
}
else{
    // Since there were no errors initializing the session, we&#39;ll allow begin receiving remote control events
    [[UIApplication sharedApplication] beginReceivingRemoteControlEvents];
}

    //initialize our audio player
    audioPlayer = [[MPMoviePlayerController alloc] initWithContentURL:[NSURL URLWithString:@&quot;http://www.cocoanetics.com/files/Cocoanetics_031.mp3&quot;]];

    [audioPlayer setShouldAutoplay:NO];
    [audioPlayer setControlStyle: MPMovieControlStyleEmbedded];
    audioPlayer.view.hidden = YES;

    [audioPlayer prepareToPlay];
</code></pre><p>点击按钮开始播放,注意因为MPNowPlayingInfoCenter只支持5.0+ 所以为了防止低版本使用 巧妙的应用了NSClassFromString进行了判断</p>
<pre><code>- (IBAction)playButtonPress:(id)sender {

    [audioPlayer play];

    Class playingInfoCenter = NSClassFromString(@&quot;MPNowPlayingInfoCenter&quot;);

    if (playingInfoCenter) {


        NSMutableDictionary *songInfo = [ [NSMutableDictionary alloc] init];


        MPMediaItemArtwork *albumArt = [ [MPMediaItemArtwork alloc] initWithImage: [UIImage imagedNamed:@&quot;AlbumArt&quot;] ];

        [ songInfo setObject: @&quot;Audio Title&quot; forKey:MPMediaItemPropertyTitle ];
        [ songInfo setObject: @&quot;Audio Author&quot; forKey:MPMediaItemPropertyArtist ];
        [ songInfo setObject: @&quot;Audio Album&quot; forKey:MPMediaItemPropertyAlbumTitle ];
        [ songInfo setObject: albumArt forKey:MPMediaItemPropertyArtwork ];
        [ [MPNowPlayingInfoCenter defaultCenter] setNowPlayingInfo:songInfo ];
    }
}
</code></pre><hr>
<p><a href="http://jaysonlane.net/tech-blog/2012/04/lock-screen-now-playing-with-mpnowplayinginfocenter/" target="_blank">参考 <a href="http://jaysonlane.net/tech-blog/2012/04/lock-screen-now-playing-with-mpnowplayinginfocenter/">http://jaysonlane.net/tech-blog/2012/04/lock-screen-now-playing-with-mpnowplayinginfocenter/</a></a></p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[阿里IOS面试题之多线程选用NSOperation or GCD]]></title>
    <link href="http://hufeng825.github.com/2013/09/18/ios26/"/>
    <id>http://hufeng825.github.com/2013/09/18/ios26/</id>
    <published>2013-09-18T05:31:04.000Z</published>
    <updated>2013-09-18T06:32:31.000Z</updated>
    <content type="html"><![CDATA[<p>今天早上接到了阿里从杭州打过来的电话面试.虽然近期面试了一些大中型的互联网企业,但是跟素有&quot;IT界的黄浦军校&quot;的阿里面试官接触还是不免紧张.
<a id="more"></a>
面试持续了三四十分钟吧,期间我手机信号不好挂断了一次,大部分问题都是更加简历上的项目经验而来的,个人感觉问的不算太难但是却很深入,很明显不是能够背几道面试题能够搞定的.而且每个题基本上都跟优化设计和性能相关.</p>
<p>其中有一道是关于是问&quot;你平时上国外的一些网站吗?上那些网站呢?&quot;</p>
<p>我平时大部分时间就是上stackoverflow.和cocoscontrol github 还有apple 的dev论坛.</p>
<p>&quot;你们项目中为什么多线程用GCD 而不用NSOperation呢? 你有没有发现国外的大牛他们多线程都是用NSOperation? 你能告诉我他们这样做的理由吗?&quot;</p>
<p>一下子把我问懵了.我之所以用GCD 是因为GCD用起来比较简单.代码不用分散 比较集中维护度比较高.而且代码的执行效率也要比NSOperation快些. 但是至于国外的大牛们为什么那样做 我还真的不清楚. 后来挂完电话 正好搜狐的家明哥打电话过来 我问了下他.家明哥跟我说他包括他之前在新浪做项目时也是能用GCD的地方就用GCD 尽量减少NSOperation的使用,因为GCD在多核CPU上线程切换的时间比较短 效率相对高些,至于阿里为什么那样,可能每个公司对某个技术有着不同的理解吧.</p>
<p>跟明哥挂了电话 我给对方回过去,到底为什么? 对方笑着问我:&quot;你用GCD在ASI上封装的那层网络请求 为什么后来有创建了自己的一个队列对维护这些请求?NSOperation是建立在GCD之上的 虽然使用起来比较复杂 但是在线程并发管理 优先级 上有着GCD 无法比拟的优势.&quot;</p>
<p>但是对我来说 我还是倾向于用GCD,正如家明说的 每个公司对相同的技术有着不同的理解吧.</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[再谈涉及模式]]></title>
    <link href="http://hufeng825.github.com/2013/09/17/ios25/"/>
    <id>http://hufeng825.github.com/2013/09/17/ios25/</id>
    <published>2013-09-17T15:09:18.000Z</published>
    <updated>2013-09-17T17:06:45.000Z</updated>
    <content type="html"><![CDATA[<p>某某曰:设计模式这东西,没有好坏之分，只有合适于不合适
<a id="more"></a></p>
<p>今天去面试很有意思,技术考官指着最后一道二选一的编程题说,这是昨天晚上专门为你新加的.当时我听后倍感惭愧. 虽然当时在纸上把大概思路和设计说了下.为了感谢主考官的重视程度.我现在也亲自在电脑上把这个设计实现出来.
题目大概是这个意思: 一个咖啡店卖好几种咖啡:摩卡,布列夫,拿铁等等  咖啡有很多搭配:方糖,鲜牛奶,奶油,盐等. 试设计计算出咖啡(+搭配)的单价模型.</p>
<p>下面来谈谈我的想法</p>
<h2 id="-coffee">一:虚基类 Coffee</h2>
<p>首先 我抽象出了一个虚基类 Coffee, 什么摩卡 布列夫 拿铁都继承这个类</p>
<p>这个类包含什么呢
{
. 咖啡的单价(不含 方糖 奶等 调味料) --&gt;price
. 一个存放调味料的容器 --&gt;ecoratorRelishChain
. 一个可以得到总价的方法 --&gt; getTotalPrices
}</p>
<p>下面是代码</p>
<p>基类咖啡.h</p>
<pre><code> //abstract 咖啡基类
 @class DecoratorChain;

 @interface  Coffee: NSObject
 @property ( nonatomic,strong ) DecoratorChain *ecoratorRelishChain;//用来存储 奶 方糖 等等的调料 可以把它想象成一个调味盒 
 @property ( nonatomic,strong ) NSDecimalNumber *price;//单价 不含配料

 -(NSDecimalNumber *) getTotalPrices;//得到总价

 @end
</code></pre><p>基类咖啡.m</p>
<pre><code>@interface Coffee()
@property(nonatomic,strong) NSString * _coffeeName;
@end

@implementation Coffee

@synthesize _coffeeName,price,ecoratorRelishChain;
- (id)init
{
    self = [super init];
    if (self) {
        _coffeeName=@&quot;咖啡名称&quot;;
        price = [[NSDecimalNumber alloc] initWithString:@&quot;20&quot;];
    }
    return self;
}

-(NSDecimalNumber *)getTotalPrices
{

    return [self.price decimalNumberByAdding: [ecoratorRelishChain getCountPrice]];
}

@end
</code></pre><hr>
<h2 id="-ecoratorrelish">二: 虚基类 EcoratorRelish</h2>
<p>EcoratorRelish 是 方糖 奶油  牛奶 盐 等等的抽象类 这个继承在button  点击的时候 可以自动将自己加入到chain (调料盘中)</p>
<p>这个类包含什么呢
{
. 自身的单价 --&gt;price
. 可以修改价钱的策略 --&gt; configPrivilege
}</p>
<p>方糖 等抽象出来的基类EcoratorRelish.h</p>
<pre><code>@interface  EcoratorRelish: UIButton
@property(nonatomic,strong)  NSDecimalNumber *price;//单价 
//Overload
-(void)configPrivilege;//可以配置优惠策略
-(DecoratorChain *)getComponentCoffee;
@end
</code></pre><p>EcoratorRelish.m</p>
<pre><code>@implementation  EcoratorRelish
@synthesize  price;

- (id)init
{
    self = [super init];
    if (self) {
        [self addTarget:self action:@selector(addDecoratorChain) forControlEvents:UIControlEventTouchUpInside];
    }
    return self;
}
//Overload
-(void)configPrivilege
{
    //可以配置优惠策略 
}

//获取当前的辅料坐在的ViewController
- (UIViewController *)getViewController {
    Class vcc = [UIViewController class];
    UIResponder *responder = self;
    while ((responder = [responder nextResponder]))
        if ([responder isKindOfClass: vcc])
            return (UIViewController *)responder;
    return nil;
}

//获取要装饰的咖啡的调味盒(chain)
-(DecoratorChain *)getEcoratorRelishChain
{
   return  [self getViewController].coffee.ecoratorRelishChain;
}

//将自己加到咖啡的调味盒(chain)
-(void)addDecoratorChain
{
    [[self getEcoratorRelishChain] addDecoratorRelish:self];
}

@end
</code></pre><hr>
<h2 id="-decoratorchain">三: 调料盒 DecoratorChain</h2>
<p>DecoratorChain.h</p>
<pre><code>//用于保存配料的chain
@interface  DecoratorChain: NSMutableArray
-(void)addDecoratorRelish:(EcoratorRelish*)ecoratorRelish;
@end
</code></pre><p>DecoratorChain.m</p>
<pre><code>@interface DecoratorChain()
@property(nonatomic,strong) NSDecimalNumber * _countPrice;
@end

@implementation DecoratorChain
@synthesize _countPrice;

- (id)init
{
    self = [super init];
    if (self) {
        _countPrice = [[NSDecimalNumber alloc]init];
    }
    return self;
}

-(void)addDecoratorRelish:(EcoratorRelish*)ecoratorRelish
{
    [self addObject:ecoratorRelish];
}

//得到当前所有chain 里面的总价
-(NSDecimalNumber*)getCountPrice
{
    for (EcoratorRelish *tmp  in self ) {
        [_countPrice decimalNumberByAdding:tmp.price];
    }
    return _countPrice;
}

@end
</code></pre><p>下面的实现代码大家应该都会写了吧. 其实回头看下 中间应用到的设计模式 最明显的是 装饰 和 组合 策略</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[What is the difference between Category and Class Extension?]]></title>
    <link href="http://hufeng825.github.com/2013/09/15/ios24/"/>
    <id>http://hufeng825.github.com/2013/09/15/ios24/</id>
    <published>2013-09-15T05:39:07.000Z</published>
    <updated>2013-09-15T06:21:06.000Z</updated>
    <content type="html"><![CDATA[<p>细心的人会发现当我们new 一个文件的时候会发现下图的部分.</p>
<img src="http://ww4.sinaimg.cn/mw690/a43af4ffjw1e8n5s8yocrj20km0e1766.jpg" width="400" height="300">

<p>但是这个问题来了Category 和 Extension 就近又什么区别呢?
<a id="more"></a></p>
<h2 id="1-category-">1:什么是Category?</h2>
<p>实现这样一种场景,当我们用我们用NSArray的时候经常会遇到要去重的操作,可是自带的NSArray并没有这个方法,想要用你第一印象是自己写个类继承他,OC 给我们提供了一个方法可以直接在原有的基础上进行扩展.这就Category.分类能够做到的事情主要是：即使在你不知道一个类的源码情况下，向这个类添加扩展的方法。一个类可以有n+个分类,这些分类的实现可以在不同的文件中.</p>
<p>下面是我写的一个分类</p>
<p>NSArray+Unique.h</p>
<pre><code>@interface NSArray (Unique)
- (NSArray *) uniqueMembers;
- (NSArray *) unionWithArray: (NSArray *) array;
@end
</code></pre><p>NSArray+Unique.m</p>
<pre><code>@implementation NSArray (Unique)
- (NSArray *) uniqueMembers
{
    NSMutableArray *copy = [self mutableCopy];
    for (id object in self)
    {
        [copy removeObjectIdenticalTo:object];
        [copy addObject:object];
    }
    return [copy autorelease];
}

- (NSArray *) unionWithArray: (NSArray *) anArray
{
    if (!anArray) return self;
    return [[self arrayByAddingObjectsFromArray:anArray] uniqueMembers];
}

@end
</code></pre><p>是不是很简单.但是应用Category还有如下</p>
<h3 id="-">需要注意的问题：</h3>
<ol>
<li><p>Category可以访问原始类的实例变量，但不能添加实例变量，如果想添加变量，那就通过继承创建子类来实现。  </p>
</li>
<li><p>Category的优先级要高,当类中的方法跟原使类中的方法重名的时候是会重载原始类的方法. </p>
</li>
<li><p>和普通接口有所区别的是，在Category的实现文件中的实例方法只要你不去调用它你可以不用实现所有声明的所有方法。</p>
</li>
<li><p>不要在Category 调用 Super方法</p>
</li>
</ol>
<h2 id="2-extension">2:什么是 Extension</h2>
<p> 扩展(Extension)人们往往以为就是匿名分类,因为他的语法看起来很像</p>
<p>下面是一个Extension</p>
<pre><code>@interface ExtensionClass : NSObject  
@property (retain, readonly) float value;
@end  


@interface ExtensionClass () { //注意此处：扩展  

}  
@property (retain, readwrite) float value; 
- (void)setValue:(float)newValue;  
@end  

@implementation ExtensionClass  

- (float)value {  
    return value;  
}  

- (void)setValue:(float)newValue {  
    value = newValue;  
}  

@end 
</code></pre><p><strong>虽然它们的语法的确很相似。虽然都可以用来为一个现有的类添加方法和属性，但它们的目的和行为却是不同的。</strong></p>
<h2 id="class-extensions-">Class extensions注意事项:</h2>
<ol>
<li><p>可以定义属性(实例变量)</p>
</li>
<li><p>在公共接口(类的声明中)中,开发者可以声明一个属性(实例变量)是只读的,随后在类扩展中声明为可写。这样，对外部代码而言,该属性(实例变量)将是只读的,而内部代码却可以使用它setter方法。</p>
</li>
<li><p>分类必须在第一个@interface中声明方法，并且在@implementation中提供实现，不然运行时出错。而类扩展的声明可以不在第一个@interface中去声明</p>
</li>
</ol>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ios笔记-- 多线程应该知道的那几件事 GCD NSThread NSOperation]]></title>
    <link href="http://hufeng825.github.com/2013/09/14/ios23/"/>
    <id>http://hufeng825.github.com/2013/09/14/ios23/</id>
    <published>2013-09-14T05:58:20.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>iphone5s 出来了，CPU 升级到了64位 可以应用到更大的内存了，同时对多线程的处理吞吐能力也教之前提升了十几倍。下面着中总结下ios 下多线程的知识点
<a id="more"></a></p>
</blockquote>
<img src="http://image.techweb.com.cn/edit/2013/0911/37841378870639jpg" class="left" width="400" height="200">



<h2 id="1-">1：现有的几种多线程</h2>
<table>
<thead>
<tr>
<th>概念</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td> NSThread</td>
<td>苹果公司的Cocoa框架共支持三种多线程机制，分别为NSThread、GCD（Grand Central Dispatch）、Cocoa NSOperatio。NSThree是官方推荐的线程处理方式，它在处理机制上，需要开发者负责手动管理Thread的生命周期，包括子线程与主线程之间的同步等。线程共享同一应用程序的部分内存空间，它们拥有对数据相同的访问权限。你得协调多个线程 对同一数据的访问，一般做法是在访问之前加锁，这会导致一定的性能开销。在 iOS 中我们可以使用多种形式的 thread。 比其他两个轻量级 需要自己管理线程的生命周期，线程同步。 线程同步对数据的加锁会有一定的系统开销</td>
</tr>
<tr>
<td> NSOperation</td>
<td>如果需要让线程同时并行运行多个，可以将线程加入队列（Queue）中，NSOperationQueue类就是一个线程队列管理类，他提供了线程并行、队列的管理。可以认为NSOperationQueue就是一个线程管理器，通过addOperations方法，我们可以一次性把多个（数组形式）线程添加到队列中。同时，NSOperationQueue允许通过setMaxConcurrentOperationCount方法设置队列的并行（同一时间）运行数量  </td>
</tr>
<tr>
<td> GCD</td>
<td>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。该方法在Mac OS X 10.6雪豹中首次推出，并随后被引入到了iOS4.0中。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术，它看起来象就其它语言的闭包(Closure)一样，但苹果把它叫做blocks。</td>
</tr>
</tbody>
</table>
<p>一般移动平台上系统都会有一个专门的检查机制，看程序有没有很长时间被阻塞住，没有回来检查主消息队列。发现这种情况一般都是把程 序作为“无响应”干掉。iOS一般情况下是10秒为上限。10秒内程序没有回到主消息循环就被干掉。在前台后台切换时更严格，大概是5秒左右。<a href="http://www.cnblogs.com/linyawen/archive/2012/07/24/2606709.html" target="_blank">注释1</a></p>
<h2 id="2-demo">2:简单的Demo</h2>
<p>因为GCD 是应用最广的 而且也是苹果现在极力鼓动开发者应用的 所以NSThread NSOperation 只做简单应用</p>
<h3 id="1-nsthread">1:NSThread</h3>
<h3 id="1-1-nsthread-">1.1 NSThread 有两种直接创建方式：</h3>
<p>第一个是实例方法--直接创建线程并且开始运行线程</p>
<ul>
<li>(id)initWithTarget:(id)target selector:(SEL)selector object:(id)</li>
</ul>
<p>第二个是类方法--先创建线程对象，然后再运行线程操作，在运行线程操作前可以设置线程的优先级等线程信息</p>
<ul>
<li>(void)detachNewThreadSelector:(SEL)aSelector toTarget:(id)aTarget withObject:(id)anArgument</li>
</ul>
<p><em>selector</em> :线程执行的方法，这个selector只能有一个参数，而且不能有返回值。<br><em>target</em>  :selector消息发送的对象<br><em>argument</em> :传输给target的唯一参数，也可以是nil    </p>
<h3 id="1-2-">1.2线程间通信</h3>
<p>a 在应用程序主线程中做事情： </p>
<figure class="highlight"><pre><span class="tag">performSelectorOnMainThread</span><span class="pseudo">:withObject</span><span class="pseudo">:waitUntilDone</span>: <span class="tag">performSelectorOnMainThread</span><span class="pseudo">:withObject</span><span class="pseudo">:waitUntilDone</span><span class="pseudo">:modes</span>:
</pre></figure>

<p>b 在指定线程中做事情：</p>
<figure class="highlight"><pre><span class="tag">performSelector</span><span class="pseudo">:onThread</span><span class="pseudo">:withObject</span><span class="pseudo">:waitUntilDone</span>: <span class="tag">performSelector</span><span class="pseudo">:onThread</span><span class="pseudo">:withObject</span><span class="pseudo">:waitUntilDone</span><span class="pseudo">:modes</span>:
</pre></figure>

<p>c 在当前线程中做事情：</p>
<figure class="highlight"><pre><span class="tag">performSelector</span><span class="pseudo">:withObject</span><span class="pseudo">:afterDelay</span>:
<span class="tag">performSelector</span><span class="pseudo">:withObject</span><span class="pseudo">:afterDelay</span><span class="pseudo">:inModes</span>:
</pre></figure>

<p>d 取消发送给当前线程的某个消息</p>
<figure class="highlight"><pre><span class="tag">cancelPreviousPerformRequestsWithTarget</span>: 
<span class="tag">cancelPreviousPerformRequestsWithTarget</span><span class="pseudo">:selector</span><span class="pseudo">:object</span>:
</pre></figure>

<h3 id="2-nsoperation">2:NSOperation</h3>
<p>首先是建立NSOperationQueue和NSOperations。NSOperationQueue会建立一个线程管理器，每个加入到线程operation会有序的执行。  </p>
<figure class="highlight"><pre>
NSOperationQueue *queue = [NSOperationQueue <span class="keyword">new</span>];
NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:<span class="keyword">self</span> <span class="keyword">selector</span>:@<span class="keyword">selector</span>(doWork:) object:someObject]; 
[queue addObject:operation]; 
[operation release];
</pre></figure>

<p>使用NSOperationQueue的过程：  </p>
<pre><code>1.  建立一个NSOperationQueue的对象  
2.  建立一个NSOperation的对象  
3.  将operation加入到NSOperationQueue中  
4.  release掉operation  
</code></pre><p>NSInvocationOperation，NSInvocationOperation是NSOperation的子类，允许运行在operation中的targer和selector</p>
<h3 id="3-">3：多线程互斥同步问题</h3>
<p><a href="http://www.cnblogs.com/Quains/archive/2013/07/10/3182823.html" target="_blank">注释2</a></p>
<p>在iOS中有几种方法来解决多线程访问同一个内存地址的互斥同步问题：</p>
<ul>
<li>方法一，@synchronized(id anObject),(最简单的方法)
会自动对参数对象加锁，保证临界区内的代码线程安全</li>
</ul>
<figure class="highlight"><pre><span class="at_rule">@<span class="function">synchronized(self)</span> {</span>
        <span class="comment">// 这段代码对其他 @synchronized(self) 都是互斥的</span>
        <span class="comment">// self 指向同一个对象</span>
}
</pre></figure>

<ul>
<li>方法二，NSLock</li>
</ul>
<p>NSLock对象实现了NSLocking protocol，包含几个方法：
lock，加锁
unlock，解锁
tryLock，尝试加锁，如果失败了，并不会阻塞线程，只是立即返回NO
lockBeforeDate:，在指定的date之前暂时阻塞线程（如果没有获取锁的话），如果到期还没有获取锁，则线程被唤醒，函数立即返回NO
比如
：
    NSLock *theLock = [[NSLock alloc] init]; </p>
<pre><code>if ([theLock lock]) {

//do something here

[theLock unlock]; 

} 
</code></pre><ul>
<li>方法三，NSRecursiveLock，递归锁</li>
</ul>
<p>NSRecursiveLock，多次调用不会阻塞已获取该锁的线程。</p>
<pre><code>NSRecursiveLock *theLock = [[NSRecursiveLock alloc] init]; 
void MyRecursiveFunction(int value) { 
    [theLock lock]; 
    if (value != 0) { 
        –value; 
        MyRecursiveFunction(value); 
    }
    [theLock unlock]; 
} 
MyRecursiveFunction(5);
</code></pre><ul>
<li>方法四，NSConditionLock，条件锁</li>
</ul>
<p>NSConditionLock，条件锁，可以设置条件</p>
<pre><code>//公共部分
id condLock = [[NSConditionLock alloc] initWithCondition:NO_DATA]; 

//线程一，生产者
while(true) { 

[condLock lockWhenCondition:NO_DATA]; 

//生产数据
[condLock unlockWithCondition:HAS_DATA];

}

//线程二，消费者
while (true) { 

[condLock lockWhenCondition:HAS_DATA

//消费
[condLock unlockWithCondition:NO_DATA]; 
}
</code></pre><ul>
<li>方法五，NSDistributedLock，分布锁</li>
</ul>
<p>NSDistributedLock，分布锁，文件方式实现，可以跨进程
用tryLock方法获取锁。
用unlock方法释放锁。
如果一个获取锁的进程在释放锁之前挂了，那么锁就一直得不到释放了，此时可以通过breakLock强行获取锁。</p>
<p><strong>本章节(多线程互斥同步问题)参考自:<a href="http://blog.sina.com.cn/s/blog_72819b170101590n.html" target="_blank">http://blog.sina.com.cn/s/blog_72819b170101590n.html</a></strong></p>
<h2 id="3-gcd-">3:GCD多线程互斥同步问题(阻塞线程的方式去实现同步)</h2>
<p><a href="http://blog.devtang.com/blog/2012/02/22/use-gcd/" target="_blank">注释3</a></p>
<h3 id="1-">1.串行队列</h3>
<p>(1)GCD下的dispatch_queue队列都是FIFO队列,都会按照提交到队列的顺序执行.
只是根据队列的性质,分为  </p>
<p><1>串行队列:用户队列、主线程队列 </p>
<p><2>并行队列. </p>
<p>(2)同步(dispatch_sync)、异步方式(dispatch_async). 配合串行队列和并行队列使用.<br>同步队列直接提交两个任务就可以.
// 串形队列
    dispatch_queue_t serilQueue = dispatch_queue_create(&quot;com.quains.myQueue&quot;, 0);</p>
<pre><code>//开始时间
NSDate *startTime = [NSDate date];


__block UIImage *image = nil;

//1.先去网上下载图片
dispatch_async(serilQueue, ^{
   //下载图片
});

//2.在主线程展示到界面里
dispatch_async(serilQueue, ^{

    NSLog(@&quot;%@&quot;,[NSThread currentThread]);

    // 在主线程展示
    dispatch_async(dispatch_get_main_queue(), ^{
      //显示图片
});

//3.清理
dispatch_release(serilQueue);
[image release];
</code></pre><p><strong>注意:</strong></p>
<p>(1) __block变量分配在栈,retain下,防止被回收. </p>
<p>(2)dispatch要手动create和release. </p>
<p>(3)提交到主线程队列的时候,慎用同步dispatch_sync方法,有可能造成死锁.  因为主线程队列是串行队列,要等队列里的任务一个一个执行.所以提交一个任务到队列,如果用同步方法就会阻塞住主线程,而主线程又要等主线程队列里的任务都执行完才能执行那个刚提交的,所以主线程队列里还有其他的任务的话,但他已经被阻塞住了,没法先完成队列里的其他任务,即,最后一个任务也没机会执行到,于是造成死锁.</p>
<p>(4)提交到串行队列可以用同步方式,也可以用异步方式. </p>
<h3 id="2-">2.并行队列</h3>
<p>采用并行队列的时候,可以采用同步的方式把任务提交到队列里去,即可以实现同步的方式</p>
<p>//新建一个队列
    dispatch_queue_t concurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>
<pre><code>//记时
NSDate *startTime = [NSDate date];

//加入队列
dispatch_async(concurrentQueue, ^{
    __block UIImage *image = nil;

    //1.先去网上下载图片
    dispatch_sync(concurrentQueue, ^{
        //下载图片
    });

    //2.在主线程展示到界面里
    dispatch_sync(dispatch_get_main_queue(), ^{
        //显示图片
    });
});
</code></pre><p>两个同步的任务用一个异步的包起来,提交到并行队列里去,即可实现同步的方式.</p>
<h3 id="3-">3.使用分组方式</h3>
<p>group本身是将几个有关联的任务组合起来,然后提供给开发者一个知道这个group结束的点.
虽然这个只有一个任务,但是可以利用group的结束点,去阻塞线程,从而来实现同步方式.</p>
<p>例如让后台2个线程并行执行，然后等2个线程都结束后，再汇总执行结果。这个可以用dispatch_group, dispatch_group_async 和 dispatch_group_notify来实现，示例如下：</p>
<figure class="highlight"><pre> dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();
 dispatch_group_async(<span class="keyword">group</span>, dispatch_get_global_queue(<span class="number">0</span>,<span class="number">0</span>), ^{
      <span class="comment">// 并行执行的线程一</span>
 });
 dispatch_group_async(<span class="keyword">group</span>, dispatch_get_global_queue(<span class="number">0</span>,<span class="number">0</span>), ^{
      <span class="comment">// 并行执行的线程二</span>
 });
 dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_global_queue(<span class="number">0</span>,<span class="number">0</span>), ^{
      <span class="comment">// 汇总结果</span>
 });
</pre></figure>

<pre><code>dispatch_group_t group = dispatch_group_create();

dispatch_queue_t queue = dispatch_get_global_queue(0, 0);

NSDate *startTime = [NSDate date];

__block UIImage *image = nil;

dispatch_group_async(group, queue, ^{
    //1.先去网上下载图片
    });

// 2.等下载好了再在刷新主线程
dispatch_group_notify(group, queue, ^{

    //在主线程展示到界面里
    dispatch_async(dispatch_get_main_queue(), ^{
     //显示图片
    });

});

// 释放掉
dispatch_release(group);
</code></pre><p>dispatch_group 也要手动创建和释放.
dispatch_notify()提供了一个知道group什么时候结束的点. 当然也可以使用dispatch_wait()去阻塞</p>
<h3 id="4-">4.信号量</h3>
<p>信号量 和 琐 的作用差不多,可以用来实现同步的方式. 
但是信号量通常用在 允许几个线程同时访问一个资源,通过信号量来控制访问的线程个数.</p>
<p>// 信号量初始化为1
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</p>
<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(0, 0);

NSDate *startTime = [NSDate date];

__block UIImage *image = nil;


//1.先去网上下载图片
dispatch_async(queue, ^{

    // wait操作-1
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    // 开始下载
    // signal操作+1
    dispatch_semaphore_signal(semaphore);
});


// 2.等下载好了再在刷新主线程
dispatch_async(dispatch_get_main_queue(), ^{

    // wait操作-1
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    //显示图片
    // signal操作+1
    dispatch_semaphore_signal(semaphore);
});
</code></pre><p>dispatch_wait会阻塞线程并且检测信号量的值,直到信号量值大于0才会开始往下执行,同时对信号量执行-1操作.<br>dispatch_signal则是+1操作.</p>
<h3 id="3-">3.后台运行</h3>
<p>GCD的另一个用处是可以让程序在后台较长久的运行。在没有使用GCD时，当app被按home键退出后，app仅有最多5秒钟的时候做一些保存或清理资源的工作。但是在使用GCD后，app最多有10分钟的时间在后台长久运行。这个时间可以用来做清理本地缓存，发送统计数据等工作。</p>
<p>让程序在后台长久运行的示例代码如下：</p>
<figure class="highlight"><pre><span class="comment">// AppDelegate.h文件</span>
<span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) UIBackgroundTaskIdentifier backgroundUpdateTask;

<span class="comment">// AppDelegate.m文件</span>
- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application
{
    [<span class="keyword">self</span> beingBackgroundUpdateTask];
    <span class="comment">// 在这里加上你需要长久运行的代码</span>
    [<span class="keyword">self</span> endBackgroundUpdateTask];
}

- (<span class="keyword">void</span>)beingBackgroundUpdateTask
{
    <span class="keyword">self</span><span class="variable">.backgroundUpdateTask</span> = [[<span class="built_in">UIApplication</span> sharedApplication] beginBackgroundTaskWithExpirationHandler:^{
        [<span class="keyword">self</span> endBackgroundUpdateTask];
    }];
}

- (<span class="keyword">void</span>)endBackgroundUpdateTask
{
    [[<span class="built_in">UIApplication</span> sharedApplication] endBackgroundTask: <span class="keyword">self</span><span class="variable">.backgroundUpdateTask</span>];
    <span class="keyword">self</span><span class="variable">.backgroundUpdateTask</span> = UIBackgroundTaskInvalid;
}
</pre></figure>

<hr>
<p>[1] <a href="http://www.cnblogs.com/linyawen/archive/2012/07/24/2606709.html" target="_blank">http://www.cnblogs.com/linyawen/archive/2012/07/24/2606709.html</a></p>
<p>[2] <a href="http://www.cnblogs.com/Quains/archive/2013/07/10/3182823.html" target="_blank">http://www.cnblogs.com/Quains/archive/2013/07/10/3182823.html</a></p>
<p>[3] <a href="http://blog.devtang.com/blog/2012/02/22/use-gcd/" target="_blank">http://blog.devtang.com/blog/2012/02/22/use-gcd/</a></p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ios笔记--block应该知道的那几件事]]></title>
    <link href="http://hufeng825.github.com/2013/09/11/ios22/"/>
    <id>http://hufeng825.github.com/2013/09/11/ios22/</id>
    <published>2013-09-11T15:32:18.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<p>block 现在已经基本上已经使用非常普遍了,在引用中也又很多坑,下面把block开发中应该知道的那几件事总结下.
<a id="more"></a></p>
<h2 id="-inline-block">:内联(inline)Block</h2>
<blockquote>
<p>内联block 说白了就是block被嵌入到一个函数中 
例如:</p>
</blockquote>
<p><strong>typedef void (^HelloBlock)(void);</strong></p>
<figure class="highlight"><pre><span class="pp">- <span class="params">(void)</span> BlockTest{
HelloBlock myBlock= ^<span class="params">(void)</span>{
NSLog<span class="params">(@<span class="string">"Hello Block"</span>)</span>;
};
myBlock<span class="params">()</span>;
}</span>
</pre></figure>

<h2 id="-">注意事项</h2>
<h3 id="1-block-">1.内联的block中内部定义的变量 自己本身有读写权限</h3>
<h3 id="2-block-__block">2.block内部要修改外部变量 需要将外部变量声明__block</h3>
<h3 id="3-block-retain-block-copy-release">3.Block retain是无效的，要想保留block生命周期，可以通过copy来实现，记得release</h3>
<h3 id="4-block-retaincount-retain-circle-__block-block-">4.被block的应用的对象，retainCount会自动加一，为了打破这种 retain circle，可以在对象前加__block，这样block块就不会维护这个对象了</h3>
<p> 下面的写法如果不加上_block a无法dealloc</p>
<figure class="highlight"><pre>
<span class="label">__block A  a =[ [[A alloc] init] withBlock:</span>^{

 [<span class="literal">a</span> action]<span class="comment">;</span>

 [ <span class="literal">a</span> release]<span class="comment">;</span>

}]<span class="comment">; //这样A的dealloc方法就会调用</span>
</pre></figure>

<figure class="highlight"><pre>
<span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ： <span class="title">UIViewViewController</span> </span>
 {
        <span class="built_in">NSString</span> *_string;
 }

 __block ViewController *controller = <span class="keyword">self</span>;   
    _block = ^{
         <span class="built_in">NSLog</span>(@<span class="string">"string %@"</span>,controller-&gt;_string);
    };
</pre></figure>

<h3 id="5-block-self-c-copy-">5.在独立的block中不能引用self，如果需要访问可以使用参数传递的方法(可以把其考虑成c+中参数传入函数指针对应copy)**</h3>
<h3 id="6-">6.不要随便用.语法</h3>
<figure class="highlight"><pre><span class="preprocessor">#import <span class="title">&lt;UIKit/UIKit.h&gt;</span>   </span>
<span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> : <span class="title">NSObject</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *stringProperty;  
<span class="keyword">@end</span>
</pre></figure>

<figure class="highlight"><pre><span class="preprocessor">#import <span class="title">"GCDAppDelegate.h"</span> </span>
<span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span> </span>
<span class="keyword">@synthesize</span> stringProperty;  
- (<span class="keyword">void</span>) BlockTestError{
HelloBlock myBlock= ^(<span class="keyword">void</span>){
	<span class="keyword">self</span><span class="variable">.stringProperty</span> = @<span class="string">"Block Objects"</span>; 
	<span class="built_in">NSLog</span>(@<span class="string">"String property = %@"</span>, <span class="keyword">self</span><span class="variable">.stringProperty</span>);<span class="comment">//运行错误</span>
};
myBlock();
}}  

- (<span class="keyword">void</span>) BlockTestCorrect{
	HelloBlock myBlock= ^(<span class="keyword">void</span>){
		[<span class="keyword">self</span> setStringProperty:@<span class="string">"Block Objects"</span>];
	    <span class="built_in">NSLog</span>(@<span class="string">"self.stringProperty = %@"</span>, [<span class="keyword">self</span> stringProperty]); <span class="comment">//运行ok</span>
	};
myBlock();
}}  
<span class="keyword">@end</span>
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[读 林锐博士的项目管理 笔记1]]></title>
    <link href="http://hufeng825.github.com/2013/09/09/project0/"/>
    <id>http://hufeng825.github.com/2013/09/09/project0/</id>
    <published>2013-09-09T08:07:57.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="-">软件挣钱难的问题</h2>
<p><a id="more"></a></p>
<h3 id="-">一、承接合同项目，为甲方开发软件系统。</h3>
<ol>
<li><p>市场上能够承接到的合同项目，利润很小。而高利润的项目则被有权势的人或机构掌控。 </p>
</li>
<li><p>项目需求和验收受制于客户。开发过程中，客户会不断变更需求，导致开发方不断修改软件，项目验收被不断地延后，开发方成本（包括机会成本）越来越高。</p>
</li>
<li><p>缺乏规模复制效益。由于合同项目都是针对特定客户（甲方）的特定需求而签订的，即使做成功了一个合同项目，也很难“复制这个项目”直接卖给下一个客户。</p>
</li>
</ol>
<h3 id="-">二、开发并销售通用软件产品</h3>
<ol>
<li><p>凡是面向个人的通用软件产品，由于盗版原因，几乎无法靠卖软件来挣钱。</p>
</li>
<li><p>只有企业级软件产品不容易被大量盗版，可以走“通用软件产品盈利模式”，难度非常高。开发方必须把自己打造成为“企业级应用的领导者”，否则客户不信任你的方法和产品，产品就无法通用。于是客户提出的个性化需求越来越多，回到了“合同项目盈利模式”。 </p>
</li>
</ol>
<h3 id="-">三、运营模式</h3>
<ol>
<li><p>互联网公司的业务太容易被模仿，同质化竞争严重。每个领域都死掉了成千上万的相同业务的互联网公司，最终只有少数几家可以活下来，极大地浪费社会财富。</p>
</li>
<li><p>互联网公司的另一个大缺点是太浮躁，过分追求快而导致根基不扎实，国内绝大多数互联网公司的软件研发管理，要比传统软件公司混乱得多。</p>
</li>
</ol>
<hr>
<blockquote>
<p>软件企业要想多挣钱，靠“开源节流”。“开源”主要靠优化盈利模式，使得现有的技术和资源产生更高的效益。“节流”主要靠改进管理，使企业的所有经营环节更加合理，减少不必要的成本，省下来的钱也就成了利润</p>
</blockquote>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/项目管理/" term="项目管理"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[mac 下更新DNS 缓存]]></title>
    <link href="http://hufeng825.github.com/2013/09/03/mac4/"/>
    <id>http://hufeng825.github.com/2013/09/03/mac4/</id>
    <published>2013-09-03T09:14:30.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<p>开始的时候难免遇到修改host的时候，但是host后没有即刻生效，可使用终端命令手动清除DNS缓存：</p>
<figure class="highlight"><pre>dscacheutil <span class="attribute">-flushcache</span>
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
    <category scheme="http://hufeng825.github.com/categories/ios/mac/" term="mac"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[判断地图坐标是否在区域内]]></title>
    <link href="http://hufeng825.github.com/2013/09/03/23/"/>
    <id>http://hufeng825.github.com/2013/09/03/23/</id>
    <published>2013-09-03T08:51:48.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>此方法与前一篇文章中的得到UIView某点的色值达到的效果一直，通常为了保持精度 两个方法一起使用。</p>
</blockquote>
<p><a id="more"></a></p>
<figure class="highlight"><pre>-(<span class="keyword">IBAction</span>)foundTap:(UITapGestureRecognizer *)recognizer
{
    <span class="built_in">CGPoint</span> point = [recognizer locationInView:<span class="keyword">self</span><span class="variable">.mapView</span>];

    CLLocationCoordinate2D tapPoint = [<span class="keyword">self</span><span class="variable">.mapView</span> convertPoint:point toCoordinateFromView:<span class="keyword">self</span><span class="variable">.view</span>];

    [<span class="keyword">self</span> pointInsideOverlay:tapPoint];

    <span class="keyword">if</span> (isInside) 
     {
       ....
     }
}
</pre></figure>

<p>Here is a method to call from the previous to check if the point is inside the overlay:</p>
<figure class="highlight"><pre>-(<span class="keyword">void</span>)pointInsideOverlay:(CLLocationCoordinate2D )tapPoint 
{
    isInside = <span class="literal">FALSE</span>; 

    MKPolygonView *polygonView = (MKPolygonView *)[mapView viewForOverlay:polygonOverlay];

    MKMapPoint mapPoint = MKMapPointForCoordinate(tapPoint);

    <span class="built_in">CGPoint</span> polygonViewPoint = [polygonView pointForMapPoint:mapPoint];

    <span class="built_in">BOOL</span> mapCoordinateIsInPolygon = CGPathContainsPoint(polygonView<span class="variable">.path</span>, <span class="literal">NULL</span>, polygonViewPoint, <span class="literal">NO</span>);

        <span class="keyword">if</span> ( !mapCoordinateIsInPolygon )

            <span class="comment">//we are finding points that are inside the overlay</span>
        {
            isInside = <span class="literal">TRUE</span>;
        }
}
</pre></figure>

<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e89eyhiwqbj20hs0qo769.jpg" class="center" width="300" height="600">

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[How to get the color of a pixel in an UIView?]]></title>
    <link href="http://hufeng825.github.com/2013/09/03/22/"/>
    <id>http://hufeng825.github.com/2013/09/03/22/</id>
    <published>2013-09-03T08:33:35.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<p>记得一年前做招行掌上生活M+的时候 其中有个需求是画一画功能，就是在地图上用手指画个圈 然后得到这个圈里面所有指定商户。
当时为了精度 除了利用 </p>
<figure class="highlight"><pre><span class="built_in">BOOL</span> mapCoordinateIsInPolygon = CGPathContainsPoint(polygonView<span class="variable">.path</span>, <span class="literal">NULL</span>, polygonViewPoint, <span class="literal">NO</span>);
</pre></figure>

<p>来验证此点是否在画的区域内 同时为了精度 还用到了点位的颜色色值进行校验。</p>
<p>无法把全部代码给出 下面把 如何得到uiview 某点的函数给出</p>
<p> UIView+ColorOfPoint.h</p>
<figure class="highlight"><pre><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">ColorOfPoint</span>)</span>
- (<span class="built_in">UIColor</span> *) colorOfPoint:(<span class="built_in">CGPoint</span>)point;
<span class="keyword">@end</span>
</pre></figure>

<p> UIView+ColorOfPoint.m</p>
<figure class="highlight"><pre><span class="preprocessor">#import <span class="title">"UIView+ColorOfPoint.h"</span></span>
<span class="preprocessor">#import <span class="title">&lt;QuartzCore/QuartzCore.h&gt;</span></span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">ColorOfPoint</span>)</span>

- (<span class="built_in">UIColor</span> *) colorOfPoint:(<span class="built_in">CGPoint</span>)point
{
    <span class="keyword">unsigned</span> <span class="keyword">char</span> pixel[<span class="number">4</span>] = {<span class="number">0</span>};
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(pixel, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, colorSpace, kCGImageAlphaPremultipliedLast);

    CGContextTranslateCTM(context, -point<span class="variable">.x</span>, -point<span class="variable">.y</span>);

    [<span class="keyword">self</span><span class="variable">.layer</span> renderInContext:context];

    CGContextRelease(context);
    CGColorSpaceRelease(colorSpace);

    <span class="comment">//NSLog(@"pixel: %d %d %d %d", pixel[0], pixel[1], pixel[2], pixel[3]);</span>

    <span class="built_in">UIColor</span> *color = [<span class="built_in">UIColor</span> colorWithRed:pixel[<span class="number">0</span>]/<span class="number">255.0</span> green:pixel[<span class="number">1</span>]/<span class="number">255.0</span> blue:pixel[<span class="number">2</span>]/<span class="number">255.0</span> alpha:pixel[<span class="number">3</span>]/<span class="number">255.0</span>];

    <span class="keyword">return</span> color;
}
</pre></figure>

<p>@end</p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e89eyhiwqbj20hs0qo769.jpg" class="center" width="300" height="600" title="模拟器">

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[svn命令总结]]></title>
    <link href="http://hufeng825.github.com/2013/09/03/svn9/"/>
    <id>http://hufeng825.github.com/2013/09/03/svn9/</id>
    <published>2013-09-03T06:08:30.000Z</published>
    <updated>2013-09-15T05:04:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-">1. 创建分支</h2>
<p>svn cp <a href="http://svn.trunk/" target="_blank">http://svn.trunk/</a> <a href="http://svn.branches/" target="_blank">http://svn.branches/</a>  –m “create a branch”
<a id="more"></a></p>
<h2 id="2-">2. 合并分支</h2>
<h3 id="1-branch-trunk-">1、在某个branch里合并trunk上的修改，</h3>
<p>进入分支目录，然后执行：</p>
<figure class="highlight"><pre>svn <span class="built_in">merge</span> <span class="keyword">http</span>://svn/repo/trunk
</pre></figure>

<h3 id="2-trunk-branch-">2、在trunk上合并branch的修改。</h3>
<p>进入trunk目录，然后执行</p>
<figure class="highlight"><pre>svn merge --reintegrate <span class="symbol">http:</span>/<span class="regexp">/svn/repo</span><span class="regexp">/branches/branch</span>1
</pre></figure>

<h2 id="3-checkout-">3. 将文件checkout到本地目录</h2>
<p>svn checkout path（path是服务器上的目录）</p>
<figure class="highlight"><pre>例如：svn checkout svn:<span class="comment">//192.168.1.1/pro/domain</span>
简写：svn co
</pre></figure>

<h2 id="4-">4. 往版本库中添加新的文件</h2>
<p>svn add file</p>
<figure class="highlight"><pre>例如：svn addtest<span class="preprocessor">.php</span>(添加test<span class="preprocessor">.php</span>)
svn <span class="keyword">add</span> *<span class="preprocessor">.php</span>(添加当前目录下所有的php文件)
</pre></figure>

<h2 id="5-">5. 将改动的文件提交到版本库</h2>
<p>svn commit -m “LogMessage“ [-N] [--no-unlock] PATH(如果选择了保持锁，就使用–no-unlock开关)</p>
<figure class="highlight"><pre>例如：svn <span class="operator"><span class="keyword">commit</span> -m “<span class="keyword">add</span> test file <span class="keyword">for</span> my test“ test.php
简写：svn ci</span>
</pre></figure>

<h2 id="6-">6. 加锁/解锁</h2>
<p>svn lock -m “LockMessage“ [--force] PATH</p>
<figure class="highlight"><pre>例如：svn <span class="keyword">lock</span> -m “<span class="keyword">lock</span> test file“ test.php
svn unlock PATH
</pre></figure>

<h2 id="7-">7. 更新到某个版本</h2>
<p>svn update -r m path</p>
<p>例如：</p>
<figure class="highlight"><pre>svn <span class="operator"><span class="keyword">update</span>如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。
svn <span class="keyword">update</span> -r <span class="number">200</span> test.php(将版本库中的文件test.php还原到版本<span class="number">200</span>)
svn <span class="keyword">update</span> test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先<span class="keyword">update</span>，修改文件，然后清除svn resolved，最后再提交<span class="keyword">commit</span>)</span>
</pre></figure>

<p>简写：svn up</p>
<h2 id="8-">8.查看文件或者目录状态</h2>
<ol>
<li>svn status path（目录下的文件和子目录的状态，正常状态不显示）</li>
</ol>
<p>【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】</p>
<ol>
<li>svn status -v path(显示文件和子目录状态)
第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。<br><strong>注：</strong> svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。
简写：svn st</li>
</ol>
<h2 id="9-">9.删除文件</h2>
<p>svn delete path -m “delete test fle“</p>
<p>例如：</p>
<figure class="highlight"><pre>svn <span class="built_in">delete</span> svn://<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>/pro/domain/test.php -m “<span class="built_in">delete</span> test <span class="built_in">file</span>”
或者直接svn <span class="built_in">delete</span> test.php 然后再svn ci -m ‘<span class="built_in">delete</span> test <span class="built_in">file</span>‘，
</pre></figure>

<p>推荐使用这种简写：svn (del, remove, rm)</p>
<h2 id="10-">10.查看日志</h2>
<p>svn log path
例如：</p>
<figure class="highlight"><pre>svn <span class="keyword">log</span> test.php 显示这个文件的所有修改记录，及其版本号的变化
</pre></figure>

<h2 id="11-">11.查看文件详细信息</h2>
<p>svn info path</p>
<p>例如：</p>
<figure class="highlight"><pre>svn info test<span class="preprocessor">.php</span>
</pre></figure>

<h2 id="12-">12.比较差异</h2>
<p>svn diff path(将修改的文件与基础版本比较)</p>
<p>例如：</p>
<figure class="highlight"><pre>svn diff test<span class="preprocessor">.php</span>
</pre></figure>

<p>svn diff -r m:n path(对版本m和版本n比较差异)</p>
<p>例如：</p>
<figure class="highlight"><pre><span class="tag">svn</span> <span class="tag">diff</span> <span class="tag">-r</span> 200<span class="pseudo">:201</span> <span class="tag">test</span><span class="class">.php</span>
</pre></figure>

<p>简写：svn di</p>
<h2 id="13-">13.将两个版本之间的差异合并到当前文件</h2>
<p>svn merge -r m:n path
例如：</p>
<figure class="highlight"><pre><span class="tag">svn</span> <span class="tag">merge</span> <span class="tag">-r</span> 200<span class="pseudo">:205</span> <span class="tag">test</span><span class="class">.php</span>（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下）
</pre></figure>

<h2 id="14-svn-">14.SVN 帮助</h2>
<p>svn help<br>svn help ci  </p>
<h2 id="15-">15.版本库下的文件和目录列表</h2>
<p>svn list path
显示path目录下的所有属于版本库的文件和目录<br>简写：svn ls</p>
<h2 id="16-">16.创建纳入版本控制下的新目录</h2>
<p>svn mkdir: 创建纳入版本控制下的新目录。</p>
<p>用法: </p>
<ol>
<li>mkdir PATH…</li>
<li>mkdir URL…</li>
</ol>
<p>创建版本控制的目录。</p>
<ol>
<li>每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增调度，以待下一次的提交。</li>
<li>每个以URL指定的目录，都会透过立即提交于仓库中创建。在这两个情况下，所有的中间目录都必须事先存在。</li>
</ol>
<h2 id="17-">17.恢复本地修改</h2>
<p>svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert:<br>用法: revert PATH…<br>注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录</p>
<h2 id="18-url-">18.代码库URL变更</h2>
<p>svn switch (sw): 更新工作副本至不同的URL。</p>
<p>用法: </p>
<ol>
<li>switch URL [PATH]</li>
<li><p>switch –relocate FROM TO [PATH...]</p>
<ul>
<li><p>更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的方法。</p>
</li>
<li><p>改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动(比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用这个命令更新工作副本与仓库的对应关系。</p>
</li>
</ul>
</li>
</ol>
<h2 id="19-">19.解决冲突</h2>
<p>svn resolved: 移除工作副本的目录或文件的“冲突”状态。 </p>
<p>用法: resolved PATH…</p>
<p><strong>注意:</strong> 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的
相关文件，然后让 PATH 可以再次提交。</p>
<h2 id="20-url-">20.输出指定文件或URL的内容。</h2>
<p>svn cat 目标[@版本]…如果指定了版本，将从指定的版本开始查找。  </p>
<p>svn cat -r PREV filename &gt; filename (PREV 是上一版本,也可以写具体版本号,这样输出结果是可以提交的)  </p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/svn/" term="svn"/>
  </entry>
</feed>
